[
  {
    "objectName": "count",
    "signature": "property count",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/count",
    "packagePath": "cjs",
    "changeType": "removed",
    "isBreaking": true,
    "oldSource": "property count",
    "newSource": "",
    "documentation": "Property count",
    "description": "Removed property count",
    "message": "This is a removed change.\n\nPackage type: javascript\n\n⚠️ This is a breaking change.\n\nDocumentation:\n\nProperty count\n\nOld source code:\n\n```typescript\nproperty count\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property count",
    "packageType": "javascript"
  },
  {
    "objectName": "defaultProps",
    "signature": "property defaultProps",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/defaultProps",
    "packagePath": "cjs",
    "changeType": "removed",
    "isBreaking": true,
    "oldSource": "property defaultProps",
    "newSource": "",
    "documentation": "Property defaultProps",
    "description": "Removed property defaultProps",
    "message": "This is a removed change.\n\nPackage type: javascript\n\n⚠️ This is a breaking change.\n\nDocumentation:\n\nProperty defaultProps\n\nOld source code:\n\n```typescript\nproperty defaultProps\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property defaultProps",
    "packageType": "javascript"
  },
  {
    "objectName": "ElementType",
    "signature": "type ElementType<P = any> = | { [K in keyof JSX.IntrinsicElements]: P extends JSX.IntrinsicElements[K] ? K : never;",
    "objectType": "type",
    "objectIdentifier": "react/React/ElementType",
    "packagePath": "React",
    "changeType": "removed",
    "isBreaking": true,
    "oldSource": "type ElementType<P = any> = | { [K in keyof JSX.IntrinsicElements]: P extends JSX.IntrinsicElements[K] ? K : never;",
    "newSource": "",
    "documentation": "",
    "description": "Removed type ElementType",
    "message": "This is a removed change.\n\nPackage type: javascript\n\n⚠️ This is a breaking change.\n\nDocumentation:\n\nType ElementType from React.\n\nSignature: type ElementType<P = any> =\n        | {\n            [K in keyof JSX.IntrinsicElements]: P extends JSX.IntrinsicElements[K] ? K : never;\n\nOld source code:\n\n```typescript\ntype ElementType<P = any> = | { [K in keyof JSX.IntrinsicElements]: P extends JSX.IntrinsicElements[K] ? K : never;\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Type ElementType from React.\n\nSignature: type ElementType<P = any> =\n        | {\n            [K in keyof JSX.IntrinsicElements]: P extends JSX.IntrinsicElements[K] ? K : never;",
    "packageType": "javascript"
  },
  {
    "objectName": "framesToPop",
    "signature": "property framesToPop",
    "objectType": "property",
    "objectIdentifier": "react/umd/react/development/framesToPop",
    "packagePath": "umd",
    "changeType": "removed",
    "isBreaking": true,
    "oldSource": "property framesToPop",
    "newSource": "",
    "documentation": "Property framesToPop",
    "description": "Removed property framesToPop",
    "message": "This is a removed change.\n\nPackage type: javascript\n\n⚠️ This is a breaking change.\n\nDocumentation:\n\nProperty framesToPop\n\nOld source code:\n\n```typescript\nproperty framesToPop\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property framesToPop",
    "packageType": "javascript"
  },
  {
    "objectName": "func",
    "signature": "property func",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/func",
    "packagePath": "cjs",
    "changeType": "removed",
    "isBreaking": true,
    "oldSource": "property func",
    "newSource": "",
    "documentation": "Property func",
    "description": "Removed property func",
    "message": "This is a removed change.\n\nPackage type: javascript\n\n⚠️ This is a breaking change.\n\nDocumentation:\n\nProperty func\n\nOld source code:\n\n```typescript\nproperty func\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property func",
    "packageType": "javascript"
  },
  {
    "objectName": "getCurrentStack",
    "signature": "property getCurrentStack",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/getCurrentStack",
    "packagePath": "cjs",
    "changeType": "removed",
    "isBreaking": true,
    "oldSource": "property getCurrentStack",
    "newSource": "",
    "documentation": "Property getCurrentStack",
    "description": "Removed property getCurrentStack",
    "message": "This is a removed change.\n\nPackage type: javascript\n\n⚠️ This is a breaking change.\n\nDocumentation:\n\nProperty getCurrentStack\n\nOld source code:\n\n```typescript\nproperty getCurrentStack\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property getCurrentStack",
    "packageType": "javascript"
  },
  {
    "objectName": "getDefaultProps",
    "signature": "property getDefaultProps",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/getDefaultProps",
    "packagePath": "cjs",
    "changeType": "removed",
    "isBreaking": true,
    "oldSource": "property getDefaultProps",
    "newSource": "",
    "documentation": "Property getDefaultProps",
    "description": "Removed property getDefaultProps",
    "message": "This is a removed change.\n\nPackage type: javascript\n\n⚠️ This is a breaking change.\n\nDocumentation:\n\nProperty getDefaultProps\n\nOld source code:\n\n```typescript\nproperty getDefaultProps\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property getDefaultProps",
    "packageType": "javascript"
  },
  {
    "objectName": "getStackAddendum",
    "signature": "property getStackAddendum",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/getStackAddendum",
    "packagePath": "cjs",
    "changeType": "removed",
    "isBreaking": true,
    "oldSource": "property getStackAddendum",
    "newSource": "",
    "documentation": "Property getStackAddendum",
    "description": "Removed property getStackAddendum",
    "message": "This is a removed change.\n\nPackage type: javascript\n\n⚠️ This is a breaking change.\n\nDocumentation:\n\nProperty getStackAddendum\n\nOld source code:\n\n```typescript\nproperty getStackAddendum\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property getStackAddendum",
    "packageType": "javascript"
  },
  {
    "objectName": "keyPrefix",
    "signature": "property keyPrefix",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/keyPrefix",
    "packagePath": "cjs",
    "changeType": "removed",
    "isBreaking": true,
    "oldSource": "property keyPrefix",
    "newSource": "",
    "documentation": "Property keyPrefix",
    "description": "Removed property keyPrefix",
    "message": "This is a removed change.\n\nPackage type: javascript\n\n⚠️ This is a breaking change.\n\nDocumentation:\n\nProperty keyPrefix\n\nOld source code:\n\n```typescript\nproperty keyPrefix\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property keyPrefix",
    "packageType": "javascript"
  },
  {
    "objectName": "propTypes",
    "signature": "property propTypes",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/propTypes",
    "packagePath": "cjs",
    "changeType": "removed",
    "isBreaking": true,
    "oldSource": "property propTypes",
    "newSource": "",
    "documentation": "Property propTypes",
    "description": "Removed property propTypes",
    "message": "This is a removed change.\n\nPackage type: javascript\n\n⚠️ This is a breaking change.\n\nDocumentation:\n\nProperty propTypes\n\nOld source code:\n\n```typescript\nproperty propTypes\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property propTypes",
    "packageType": "javascript"
  },
  {
    "objectName": "React",
    "signature": "property React",
    "objectType": "property",
    "objectIdentifier": "react/umd/react/development/React",
    "packagePath": "umd",
    "changeType": "removed",
    "isBreaking": true,
    "oldSource": "property React",
    "newSource": "",
    "documentation": "Property React",
    "description": "Removed property React",
    "message": "This is a removed change.\n\nPackage type: javascript\n\n⚠️ This is a breaking change.\n\nDocumentation:\n\nProperty React\n\nOld source code:\n\n```typescript\nproperty React\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property React",
    "packageType": "javascript"
  },
  {
    "objectName": "result",
    "signature": "property result",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/result",
    "packagePath": "cjs",
    "changeType": "removed",
    "isBreaking": true,
    "oldSource": "property result",
    "newSource": "",
    "documentation": "Property result",
    "description": "Removed property result",
    "message": "This is a removed change.\n\nPackage type: javascript\n\n⚠️ This is a breaking change.\n\nDocumentation:\n\nProperty result\n\nOld source code:\n\n```typescript\nproperty result\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property result",
    "packageType": "javascript"
  },
  {
    "objectName": "thatReturns",
    "signature": "property thatReturns",
    "objectType": "property",
    "objectIdentifier": "react/umd/react/development/thatReturns",
    "packagePath": "umd",
    "changeType": "removed",
    "isBreaking": true,
    "oldSource": "property thatReturns",
    "newSource": "",
    "documentation": "Property thatReturns",
    "description": "Removed property thatReturns",
    "message": "This is a removed change.\n\nPackage type: javascript\n\n⚠️ This is a breaking change.\n\nDocumentation:\n\nProperty thatReturns\n\nOld source code:\n\n```typescript\nproperty thatReturns\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property thatReturns",
    "packageType": "javascript"
  },
  {
    "objectName": "thatReturnsArgument",
    "signature": "property thatReturnsArgument",
    "objectType": "property",
    "objectIdentifier": "react/umd/react/development/thatReturnsArgument",
    "packagePath": "umd",
    "changeType": "removed",
    "isBreaking": true,
    "oldSource": "property thatReturnsArgument",
    "newSource": "",
    "documentation": "Property thatReturnsArgument",
    "description": "Removed property thatReturnsArgument",
    "message": "This is a removed change.\n\nPackage type: javascript\n\n⚠️ This is a breaking change.\n\nDocumentation:\n\nProperty thatReturnsArgument\n\nOld source code:\n\n```typescript\nproperty thatReturnsArgument\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property thatReturnsArgument",
    "packageType": "javascript"
  },
  {
    "objectName": "thatReturnsFalse",
    "signature": "property thatReturnsFalse",
    "objectType": "property",
    "objectIdentifier": "react/umd/react/development/thatReturnsFalse",
    "packagePath": "umd",
    "changeType": "removed",
    "isBreaking": true,
    "oldSource": "property thatReturnsFalse",
    "newSource": "",
    "documentation": "Property thatReturnsFalse",
    "description": "Removed property thatReturnsFalse",
    "message": "This is a removed change.\n\nPackage type: javascript\n\n⚠️ This is a breaking change.\n\nDocumentation:\n\nProperty thatReturnsFalse\n\nOld source code:\n\n```typescript\nproperty thatReturnsFalse\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property thatReturnsFalse",
    "packageType": "javascript"
  },
  {
    "objectName": "thatReturnsNull",
    "signature": "property thatReturnsNull",
    "objectType": "property",
    "objectIdentifier": "react/umd/react/development/thatReturnsNull",
    "packagePath": "umd",
    "changeType": "removed",
    "isBreaking": true,
    "oldSource": "property thatReturnsNull",
    "newSource": "",
    "documentation": "Property thatReturnsNull",
    "description": "Removed property thatReturnsNull",
    "message": "This is a removed change.\n\nPackage type: javascript\n\n⚠️ This is a breaking change.\n\nDocumentation:\n\nProperty thatReturnsNull\n\nOld source code:\n\n```typescript\nproperty thatReturnsNull\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property thatReturnsNull",
    "packageType": "javascript"
  },
  {
    "objectName": "thatReturnsThis",
    "signature": "property thatReturnsThis",
    "objectType": "property",
    "objectIdentifier": "react/umd/react/development/thatReturnsThis",
    "packagePath": "umd",
    "changeType": "removed",
    "isBreaking": true,
    "oldSource": "property thatReturnsThis",
    "newSource": "",
    "documentation": "Property thatReturnsThis",
    "description": "Removed property thatReturnsThis",
    "message": "This is a removed change.\n\nPackage type: javascript\n\n⚠️ This is a breaking change.\n\nDocumentation:\n\nProperty thatReturnsThis\n\nOld source code:\n\n```typescript\nproperty thatReturnsThis\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property thatReturnsThis",
    "packageType": "javascript"
  },
  {
    "objectName": "thatReturnsTrue",
    "signature": "property thatReturnsTrue",
    "objectType": "property",
    "objectIdentifier": "react/umd/react/development/thatReturnsTrue",
    "packagePath": "umd",
    "changeType": "removed",
    "isBreaking": true,
    "oldSource": "property thatReturnsTrue",
    "newSource": "",
    "documentation": "Property thatReturnsTrue",
    "description": "Removed property thatReturnsTrue",
    "message": "This is a removed change.\n\nPackage type: javascript\n\n⚠️ This is a breaking change.\n\nDocumentation:\n\nProperty thatReturnsTrue\n\nOld source code:\n\n```typescript\nproperty thatReturnsTrue\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property thatReturnsTrue",
    "packageType": "javascript"
  },
  {
    "objectName": "Timeout",
    "signature": "property Timeout",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/Timeout",
    "packagePath": "cjs",
    "changeType": "removed",
    "isBreaking": true,
    "oldSource": "property Timeout",
    "newSource": "",
    "documentation": "Property Timeout",
    "description": "Removed property Timeout",
    "message": "This is a removed change.\n\nPackage type: javascript\n\n⚠️ This is a breaking change.\n\nDocumentation:\n\nProperty Timeout\n\nOld source code:\n\n```typescript\nproperty Timeout\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property Timeout",
    "packageType": "javascript"
  },
  {
    "objectName": "type",
    "signature": "property type",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/type",
    "packagePath": "cjs",
    "changeType": "removed",
    "isBreaking": true,
    "oldSource": "property type",
    "newSource": "",
    "documentation": "Property type",
    "description": "Removed property type",
    "message": "This is a removed change.\n\nPackage type: javascript\n\n⚠️ This is a breaking change.\n\nDocumentation:\n\nProperty type\n\nOld source code:\n\n```typescript\nproperty type\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property type",
    "packageType": "javascript"
  },
  {
    "objectName": "act",
    "signature": "function act",
    "objectType": "function",
    "objectIdentifier": "react/functions/act",
    "packagePath": "react",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function act",
    "documentation": "",
    "description": "Added new function act",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nFunction act from react.\n\nSignature: function act\n\nNew source code:\n\n```typescript\nfunction act\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Function act from react.\n\nSignature: function act",
    "packageType": "javascript"
  },
  {
    "objectName": "act",
    "signature": "act: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/act",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "act: any",
    "documentation": "Exported variable act",
    "description": "Added new variable act",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable act\n\nNew source code:\n\n```typescript\nact: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable act",
    "packageType": "javascript"
  },
  {
    "objectName": "act",
    "signature": "property act",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/act",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property act",
    "documentation": "Property act",
    "description": "Added new property act",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty act\n\nNew source code:\n\n```typescript\nproperty act\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property act",
    "packageType": "javascript"
  },
  {
    "objectName": "actQueue",
    "signature": "property actQueue",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/actQueue",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property actQueue",
    "documentation": "Property actQueue",
    "description": "Added new property actQueue",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty actQueue\n\nNew source code:\n\n```typescript\nproperty actQueue\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property actQueue",
    "packageType": "javascript"
  },
  {
    "objectName": "c",
    "signature": "function c",
    "objectType": "function",
    "objectIdentifier": "react/cjs/react-compiler-runtime/development/c",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function c",
    "documentation": "Module: cjs/react-compiler-runtime.development",
    "description": "Added new function c",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nModule: cjs/react-compiler-runtime.development\n\nNew source code:\n\n```typescript\nfunction c\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Module: cjs/react-compiler-runtime.development",
    "packageType": "javascript"
  },
  {
    "objectName": "c",
    "signature": "c: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react-compiler-runtime/development/c",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "c: any",
    "documentation": "Exported variable c",
    "description": "Added new variable c",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable c\n\nNew source code:\n\n```typescript\nc: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable c",
    "packageType": "javascript"
  },
  {
    "objectName": "c",
    "signature": "property c",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react-compiler-runtime/development/c",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property c",
    "documentation": "Property c",
    "description": "Added new property c",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty c\n\nNew source code:\n\n```typescript\nproperty c\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property c",
    "packageType": "javascript"
  },
  {
    "objectName": "cache",
    "signature": "function cache",
    "objectType": "function",
    "objectIdentifier": "react/functions/cache",
    "packagePath": "react",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function cache",
    "documentation": "",
    "description": "Added new function cache",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nFunction cache from react.\n\nSignature: function cache\n\nNew source code:\n\n```typescript\nfunction cache\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Function cache from react.\n\nSignature: function cache",
    "packageType": "javascript"
  },
  {
    "objectName": "cache",
    "signature": "cache: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/cache",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "cache: any",
    "documentation": "Exported variable cache",
    "description": "Added new variable cache",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable cache\n\nNew source code:\n\n```typescript\ncache: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable cache",
    "packageType": "javascript"
  },
  {
    "objectName": "cache",
    "signature": "property cache",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/cache",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property cache",
    "documentation": "Property cache",
    "description": "Added new property cache",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty cache\n\nNew source code:\n\n```typescript\nproperty cache\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property cache",
    "packageType": "javascript"
  },
  {
    "objectName": "captureOwnerStack",
    "signature": "function captureOwnerStack",
    "objectType": "function",
    "objectIdentifier": "react/cjs/react/development/captureOwnerStack",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function captureOwnerStack",
    "documentation": "Module: cjs/react.development",
    "description": "Added new function captureOwnerStack",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nModule: cjs/react.development\n\nNew source code:\n\n```typescript\nfunction captureOwnerStack\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Module: cjs/react.development",
    "packageType": "javascript"
  },
  {
    "objectName": "captureOwnerStack",
    "signature": "captureOwnerStack: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/captureOwnerStack",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "captureOwnerStack: any",
    "documentation": "Exported variable captureOwnerStack",
    "description": "Added new variable captureOwnerStack",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable captureOwnerStack\n\nNew source code:\n\n```typescript\ncaptureOwnerStack: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable captureOwnerStack",
    "packageType": "javascript"
  },
  {
    "objectName": "captureOwnerStack",
    "signature": "property captureOwnerStack",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/captureOwnerStack",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property captureOwnerStack",
    "documentation": "Property captureOwnerStack",
    "description": "Added new property captureOwnerStack",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty captureOwnerStack\n\nNew source code:\n\n```typescript\nproperty captureOwnerStack\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property captureOwnerStack",
    "packageType": "javascript"
  },
  {
    "objectName": "Children",
    "signature": "function Children",
    "objectType": "function",
    "objectIdentifier": "react/cjs/react/development/Children",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function Children",
    "documentation": "Module: cjs/react.development",
    "description": "Added new function Children",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nModule: cjs/react.development\n\nNew source code:\n\n```typescript\nfunction Children\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Module: cjs/react.development",
    "packageType": "javascript"
  },
  {
    "objectName": "Children",
    "signature": "Children: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/Children",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "Children: any",
    "documentation": "Exported variable Children",
    "description": "Added new variable Children",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable Children\n\nNew source code:\n\n```typescript\nChildren: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable Children",
    "packageType": "javascript"
  },
  {
    "objectName": "Children",
    "signature": "property Children",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/Children",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property Children",
    "documentation": "Property Children",
    "description": "Added new property Children",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty Children\n\nNew source code:\n\n```typescript\nproperty Children\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property Children",
    "packageType": "javascript"
  },
  {
    "objectName": "cloneElement",
    "signature": "function cloneElement",
    "objectType": "function",
    "objectIdentifier": "react/cjs/react/development/cloneElement",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function cloneElement",
    "documentation": "Module: cjs/react.development",
    "description": "Added new function cloneElement",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nModule: cjs/react.development\n\nNew source code:\n\n```typescript\nfunction cloneElement\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Module: cjs/react.development",
    "packageType": "javascript"
  },
  {
    "objectName": "cloneElement",
    "signature": "cloneElement: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/cloneElement",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "cloneElement: any",
    "documentation": "Exported variable cloneElement",
    "description": "Added new variable cloneElement",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable cloneElement\n\nNew source code:\n\n```typescript\ncloneElement: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable cloneElement",
    "packageType": "javascript"
  },
  {
    "objectName": "cloneElement",
    "signature": "property cloneElement",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/cloneElement",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property cloneElement",
    "documentation": "Property cloneElement",
    "description": "Added new property cloneElement",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty cloneElement\n\nNew source code:\n\n```typescript\nproperty cloneElement\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property cloneElement",
    "packageType": "javascript"
  },
  {
    "objectName": "Component",
    "signature": "function Component",
    "objectType": "function",
    "objectIdentifier": "react/cjs/react/development/Component",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function Component",
    "documentation": "Module: cjs/react.development",
    "description": "Added new function Component",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nModule: cjs/react.development\n\nNew source code:\n\n```typescript\nfunction Component\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Module: cjs/react.development",
    "packageType": "javascript"
  },
  {
    "objectName": "Component",
    "signature": "Component: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/Component",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "Component: any",
    "documentation": "Exported variable Component",
    "description": "Added new variable Component",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable Component\n\nNew source code:\n\n```typescript\nComponent: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable Component",
    "packageType": "javascript"
  },
  {
    "objectName": "Component",
    "signature": "property Component",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/Component",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property Component",
    "documentation": "Property Component",
    "description": "Added new property Component",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty Component\n\nNew source code:\n\n```typescript\nproperty Component\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property Component",
    "packageType": "javascript"
  },
  {
    "objectName": "createContext",
    "signature": "function createContext",
    "objectType": "function",
    "objectIdentifier": "react/cjs/react/development/createContext",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function createContext",
    "documentation": "Module: cjs/react.development",
    "description": "Added new function createContext",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nModule: cjs/react.development\n\nNew source code:\n\n```typescript\nfunction createContext\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Module: cjs/react.development",
    "packageType": "javascript"
  },
  {
    "objectName": "createContext",
    "signature": "createContext: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/createContext",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "createContext: any",
    "documentation": "Exported variable createContext",
    "description": "Added new variable createContext",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable createContext\n\nNew source code:\n\n```typescript\ncreateContext: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable createContext",
    "packageType": "javascript"
  },
  {
    "objectName": "createContext",
    "signature": "property createContext",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/createContext",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property createContext",
    "documentation": "Property createContext",
    "description": "Added new property createContext",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty createContext\n\nNew source code:\n\n```typescript\nproperty createContext\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property createContext",
    "packageType": "javascript"
  },
  {
    "objectName": "createElement",
    "signature": "function createElement",
    "objectType": "function",
    "objectIdentifier": "react/cjs/react/development/createElement",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function createElement",
    "documentation": "Module: cjs/react.development",
    "description": "Added new function createElement",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nModule: cjs/react.development\n\nNew source code:\n\n```typescript\nfunction createElement\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Module: cjs/react.development",
    "packageType": "javascript"
  },
  {
    "objectName": "createElement",
    "signature": "createElement: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/createElement",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "createElement: any",
    "documentation": "Exported variable createElement",
    "description": "Added new variable createElement",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable createElement\n\nNew source code:\n\n```typescript\ncreateElement: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable createElement",
    "packageType": "javascript"
  },
  {
    "objectName": "createElement",
    "signature": "property createElement",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/createElement",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property createElement",
    "documentation": "Property createElement",
    "description": "Added new property createElement",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty createElement\n\nNew source code:\n\n```typescript\nproperty createElement\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property createElement",
    "packageType": "javascript"
  },
  {
    "objectName": "createRef",
    "signature": "function createRef",
    "objectType": "function",
    "objectIdentifier": "react/cjs/react/development/createRef",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function createRef",
    "documentation": "Module: cjs/react.development",
    "description": "Added new function createRef",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nModule: cjs/react.development\n\nNew source code:\n\n```typescript\nfunction createRef\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Module: cjs/react.development",
    "packageType": "javascript"
  },
  {
    "objectName": "createRef",
    "signature": "createRef: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/createRef",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "createRef: any",
    "documentation": "Exported variable createRef",
    "description": "Added new variable createRef",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable createRef\n\nNew source code:\n\n```typescript\ncreateRef: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable createRef",
    "packageType": "javascript"
  },
  {
    "objectName": "createRef",
    "signature": "property createRef",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/createRef",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property createRef",
    "documentation": "Property createRef",
    "description": "Added new property createRef",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty createRef\n\nNew source code:\n\n```typescript\nproperty createRef\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property createRef",
    "packageType": "javascript"
  },
  {
    "objectName": "didUsePromise",
    "signature": "property didUsePromise",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/didUsePromise",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property didUsePromise",
    "documentation": "Property didUsePromise",
    "description": "Added new property didUsePromise",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty didUsePromise\n\nNew source code:\n\n```typescript\nproperty didUsePromise\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property didUsePromise",
    "packageType": "javascript"
  },
  {
    "objectName": "displayName",
    "signature": "property displayName",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/displayName",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property displayName",
    "documentation": "Property displayName",
    "description": "Added new property displayName",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty displayName\n\nNew source code:\n\n```typescript\nproperty displayName\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property displayName",
    "packageType": "javascript"
  },
  {
    "objectName": "forwardRef",
    "signature": "function forwardRef",
    "objectType": "function",
    "objectIdentifier": "react/cjs/react/development/forwardRef",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function forwardRef",
    "documentation": "Module: cjs/react.development",
    "description": "Added new function forwardRef",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nModule: cjs/react.development\n\nNew source code:\n\n```typescript\nfunction forwardRef\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Module: cjs/react.development",
    "packageType": "javascript"
  },
  {
    "objectName": "forwardRef",
    "signature": "forwardRef: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/forwardRef",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "forwardRef: any",
    "documentation": "Exported variable forwardRef",
    "description": "Added new variable forwardRef",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable forwardRef\n\nNew source code:\n\n```typescript\nforwardRef: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable forwardRef",
    "packageType": "javascript"
  },
  {
    "objectName": "forwardRef",
    "signature": "property forwardRef",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/forwardRef",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property forwardRef",
    "documentation": "Property forwardRef",
    "description": "Added new property forwardRef",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty forwardRef\n\nNew source code:\n\n```typescript\nproperty forwardRef\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property forwardRef",
    "packageType": "javascript"
  },
  {
    "objectName": "Fragment",
    "signature": "function Fragment",
    "objectType": "function",
    "objectIdentifier": "react/cjs/react-jsx-dev-runtime/development/Fragment",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function Fragment",
    "documentation": "Module: cjs/react-jsx-dev-runtime.development",
    "description": "Added new function Fragment",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nModule: cjs/react-jsx-dev-runtime.development\n\nNew source code:\n\n```typescript\nfunction Fragment\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Module: cjs/react-jsx-dev-runtime.development",
    "packageType": "javascript"
  },
  {
    "objectName": "Fragment",
    "signature": "Fragment: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react-jsx-dev-runtime/development/Fragment",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "Fragment: any",
    "documentation": "Exported variable Fragment",
    "description": "Added new variable Fragment",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable Fragment\n\nNew source code:\n\n```typescript\nFragment: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable Fragment",
    "packageType": "javascript"
  },
  {
    "objectName": "Fragment",
    "signature": "property Fragment",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react-jsx-dev-runtime/development/Fragment",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property Fragment",
    "documentation": "Property Fragment",
    "description": "Added new property Fragment",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty Fragment\n\nNew source code:\n\n```typescript\nproperty Fragment\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property Fragment",
    "packageType": "javascript"
  },
  {
    "objectName": "FragmentProps",
    "signature": "interface FragmentProps",
    "objectType": "interface",
    "objectIdentifier": "react/interfaces/FragmentProps",
    "packagePath": "react",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "interface FragmentProps",
    "documentation": "",
    "description": "Added new interface FragmentProps",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nInterface FragmentProps from react.\n\nSignature: interface FragmentProps\n\nNew source code:\n\n```typescript\ninterface FragmentProps\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Interface FragmentProps from react.\n\nSignature: interface FragmentProps",
    "packageType": "javascript"
  },
  {
    "objectName": "FragmentProps.children",
    "signature": "children: React.ReactNode",
    "objectType": "property",
    "objectIdentifier": "react/interfaces/FragmentProps.children",
    "packagePath": "FragmentProps",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "children: React.ReactNode",
    "documentation": "",
    "description": "Added new property FragmentProps.children",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty FragmentProps.children from FragmentProps.\n\nSignature: children: React.ReactNode\n\nNew source code:\n\n```typescript\nchildren: React.ReactNode\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property FragmentProps.children from FragmentProps.\n\nSignature: children: React.ReactNode",
    "packageType": "javascript"
  },
  {
    "objectName": "isValidElement",
    "signature": "function isValidElement",
    "objectType": "function",
    "objectIdentifier": "react/cjs/react/development/isValidElement",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function isValidElement",
    "documentation": "Module: cjs/react.development",
    "description": "Added new function isValidElement",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nModule: cjs/react.development\n\nNew source code:\n\n```typescript\nfunction isValidElement\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Module: cjs/react.development",
    "packageType": "javascript"
  },
  {
    "objectName": "isValidElement",
    "signature": "isValidElement: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/isValidElement",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "isValidElement: any",
    "documentation": "Exported variable isValidElement",
    "description": "Added new variable isValidElement",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable isValidElement\n\nNew source code:\n\n```typescript\nisValidElement: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable isValidElement",
    "packageType": "javascript"
  },
  {
    "objectName": "isValidElement",
    "signature": "property isValidElement",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/isValidElement",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property isValidElement",
    "documentation": "Property isValidElement",
    "description": "Added new property isValidElement",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty isValidElement\n\nNew source code:\n\n```typescript\nproperty isValidElement\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property isValidElement",
    "packageType": "javascript"
  },
  {
    "objectName": "jsx",
    "signature": "function jsx",
    "objectType": "function",
    "objectIdentifier": "react/cjs/react-jsx-dev-runtime/react-server/development/jsx",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function jsx",
    "documentation": "Module: cjs/react-jsx-dev-runtime.react-server.development",
    "description": "Added new function jsx",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nModule: cjs/react-jsx-dev-runtime.react-server.development\n\nNew source code:\n\n```typescript\nfunction jsx\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Module: cjs/react-jsx-dev-runtime.react-server.development",
    "packageType": "javascript"
  },
  {
    "objectName": "jsx",
    "signature": "jsx: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react-jsx-dev-runtime/react-server/development/jsx",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "jsx: any",
    "documentation": "Exported variable jsx",
    "description": "Added new variable jsx",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable jsx\n\nNew source code:\n\n```typescript\njsx: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable jsx",
    "packageType": "javascript"
  },
  {
    "objectName": "jsx",
    "signature": "property jsx",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react-jsx-dev-runtime/react-server/development/jsx",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property jsx",
    "documentation": "Property jsx",
    "description": "Added new property jsx",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty jsx\n\nNew source code:\n\n```typescript\nproperty jsx\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property jsx",
    "packageType": "javascript"
  },
  {
    "objectName": "jsxDEV",
    "signature": "function jsxDEV",
    "objectType": "function",
    "objectIdentifier": "react/cjs/react-jsx-dev-runtime/development/jsxDEV",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function jsxDEV",
    "documentation": "Module: cjs/react-jsx-dev-runtime.development",
    "description": "Added new function jsxDEV",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nModule: cjs/react-jsx-dev-runtime.development\n\nNew source code:\n\n```typescript\nfunction jsxDEV\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Module: cjs/react-jsx-dev-runtime.development",
    "packageType": "javascript"
  },
  {
    "objectName": "jsxDEV",
    "signature": "jsxDEV: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react-jsx-dev-runtime/development/jsxDEV",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "jsxDEV: any",
    "documentation": "Exported variable jsxDEV",
    "description": "Added new variable jsxDEV",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable jsxDEV\n\nNew source code:\n\n```typescript\njsxDEV: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable jsxDEV",
    "packageType": "javascript"
  },
  {
    "objectName": "jsxDEV",
    "signature": "property jsxDEV",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react-jsx-dev-runtime/development/jsxDEV",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property jsxDEV",
    "documentation": "Property jsxDEV",
    "description": "Added new property jsxDEV",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty jsxDEV\n\nNew source code:\n\n```typescript\nproperty jsxDEV\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property jsxDEV",
    "packageType": "javascript"
  },
  {
    "objectName": "jsxs",
    "signature": "function jsxs",
    "objectType": "function",
    "objectIdentifier": "react/cjs/react-jsx-dev-runtime/react-server/development/jsxs",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function jsxs",
    "documentation": "Module: cjs/react-jsx-dev-runtime.react-server.development",
    "description": "Added new function jsxs",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nModule: cjs/react-jsx-dev-runtime.react-server.development\n\nNew source code:\n\n```typescript\nfunction jsxs\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Module: cjs/react-jsx-dev-runtime.react-server.development",
    "packageType": "javascript"
  },
  {
    "objectName": "jsxs",
    "signature": "jsxs: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react-jsx-dev-runtime/react-server/development/jsxs",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "jsxs: any",
    "documentation": "Exported variable jsxs",
    "description": "Added new variable jsxs",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable jsxs\n\nNew source code:\n\n```typescript\njsxs: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable jsxs",
    "packageType": "javascript"
  },
  {
    "objectName": "jsxs",
    "signature": "property jsxs",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react-jsx-dev-runtime/react-server/development/jsxs",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property jsxs",
    "documentation": "Property jsxs",
    "description": "Added new property jsxs",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty jsxs\n\nNew source code:\n\n```typescript\nproperty jsxs\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property jsxs",
    "packageType": "javascript"
  },
  {
    "objectName": "key",
    "signature": "property key",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/key",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property key",
    "documentation": "Property key",
    "description": "Added new property key",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty key\n\nNew source code:\n\n```typescript\nproperty key\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property key",
    "packageType": "javascript"
  },
  {
    "objectName": "lazy",
    "signature": "function lazy",
    "objectType": "function",
    "objectIdentifier": "react/cjs/react/development/lazy",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function lazy",
    "documentation": "Module: cjs/react.development",
    "description": "Added new function lazy",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nModule: cjs/react.development\n\nNew source code:\n\n```typescript\nfunction lazy\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Module: cjs/react.development",
    "packageType": "javascript"
  },
  {
    "objectName": "lazy",
    "signature": "lazy: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/lazy",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "lazy: any",
    "documentation": "Exported variable lazy",
    "description": "Added new variable lazy",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable lazy\n\nNew source code:\n\n```typescript\nlazy: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable lazy",
    "packageType": "javascript"
  },
  {
    "objectName": "lazy",
    "signature": "property lazy",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/lazy",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property lazy",
    "documentation": "Property lazy",
    "description": "Added new property lazy",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty lazy\n\nNew source code:\n\n```typescript\nproperty lazy\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property lazy",
    "packageType": "javascript"
  },
  {
    "objectName": "memo",
    "signature": "function memo",
    "objectType": "function",
    "objectIdentifier": "react/cjs/react/development/memo",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function memo",
    "documentation": "Module: cjs/react.development",
    "description": "Added new function memo",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nModule: cjs/react.development\n\nNew source code:\n\n```typescript\nfunction memo\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Module: cjs/react.development",
    "packageType": "javascript"
  },
  {
    "objectName": "memo",
    "signature": "memo: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/memo",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "memo: any",
    "documentation": "Exported variable memo",
    "description": "Added new variable memo",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable memo\n\nNew source code:\n\n```typescript\nmemo: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable memo",
    "packageType": "javascript"
  },
  {
    "objectName": "memo",
    "signature": "property memo",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/memo",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property memo",
    "documentation": "Property memo",
    "description": "Added new property memo",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty memo\n\nNew source code:\n\n```typescript\nproperty memo\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property memo",
    "packageType": "javascript"
  },
  {
    "objectName": "o",
    "signature": "property o",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/react-server/development/o",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property o",
    "documentation": "Property o",
    "description": "Added new property o",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty o\n\nNew source code:\n\n```typescript\nproperty o\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property o",
    "packageType": "javascript"
  },
  {
    "objectName": "onmessage",
    "signature": "property onmessage",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/onmessage",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property onmessage",
    "documentation": "Property onmessage",
    "description": "Added new property onmessage",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty onmessage\n\nNew source code:\n\n```typescript\nproperty onmessage\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property onmessage",
    "packageType": "javascript"
  },
  {
    "objectName": "p",
    "signature": "property p",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/react-server/development/p",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property p",
    "documentation": "Property p",
    "description": "Added new property p",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty p\n\nNew source code:\n\n```typescript\nproperty p\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property p",
    "packageType": "javascript"
  },
  {
    "objectName": "Profiler",
    "signature": "function Profiler",
    "objectType": "function",
    "objectIdentifier": "react/cjs/react/development/Profiler",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function Profiler",
    "documentation": "Module: cjs/react.development",
    "description": "Added new function Profiler",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nModule: cjs/react.development\n\nNew source code:\n\n```typescript\nfunction Profiler\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Module: cjs/react.development",
    "packageType": "javascript"
  },
  {
    "objectName": "Profiler",
    "signature": "Profiler: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/Profiler",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "Profiler: any",
    "documentation": "Exported variable Profiler",
    "description": "Added new variable Profiler",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable Profiler\n\nNew source code:\n\n```typescript\nProfiler: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable Profiler",
    "packageType": "javascript"
  },
  {
    "objectName": "Profiler",
    "signature": "property Profiler",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/Profiler",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property Profiler",
    "documentation": "Property Profiler",
    "description": "Added new property Profiler",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty Profiler\n\nNew source code:\n\n```typescript\nproperty Profiler\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property Profiler",
    "packageType": "javascript"
  },
  {
    "objectName": "PureComponent",
    "signature": "function PureComponent",
    "objectType": "function",
    "objectIdentifier": "react/cjs/react/development/PureComponent",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function PureComponent",
    "documentation": "Module: cjs/react.development",
    "description": "Added new function PureComponent",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nModule: cjs/react.development\n\nNew source code:\n\n```typescript\nfunction PureComponent\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Module: cjs/react.development",
    "packageType": "javascript"
  },
  {
    "objectName": "PureComponent",
    "signature": "PureComponent: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/PureComponent",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "PureComponent: any",
    "documentation": "Exported variable PureComponent",
    "description": "Added new variable PureComponent",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable PureComponent\n\nNew source code:\n\n```typescript\nPureComponent: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable PureComponent",
    "packageType": "javascript"
  },
  {
    "objectName": "PureComponent",
    "signature": "property PureComponent",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/PureComponent",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property PureComponent",
    "documentation": "Property PureComponent",
    "description": "Added new property PureComponent",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty PureComponent\n\nNew source code:\n\n```typescript\nproperty PureComponent\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property PureComponent",
    "packageType": "javascript"
  },
  {
    "objectName": "reason",
    "signature": "property reason",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/reason",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property reason",
    "documentation": "Property reason",
    "description": "Added new property reason",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty reason\n\nNew source code:\n\n```typescript\nproperty reason\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property reason",
    "packageType": "javascript"
  },
  {
    "objectName": "s",
    "signature": "property s",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/react-server/development/s",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property s",
    "documentation": "Property s",
    "description": "Added new property s",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty s\n\nNew source code:\n\n```typescript\nproperty s\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property s",
    "packageType": "javascript"
  },
  {
    "objectName": "startTransition",
    "signature": "function startTransition",
    "objectType": "function",
    "objectIdentifier": "react/cjs/react/development/startTransition",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function startTransition",
    "documentation": "Module: cjs/react.development",
    "description": "Added new function startTransition",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nModule: cjs/react.development\n\nNew source code:\n\n```typescript\nfunction startTransition\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Module: cjs/react.development",
    "packageType": "javascript"
  },
  {
    "objectName": "startTransition",
    "signature": "startTransition: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/startTransition",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "startTransition: any",
    "documentation": "Exported variable startTransition",
    "description": "Added new variable startTransition",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable startTransition\n\nNew source code:\n\n```typescript\nstartTransition: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable startTransition",
    "packageType": "javascript"
  },
  {
    "objectName": "startTransition",
    "signature": "property startTransition",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/startTransition",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property startTransition",
    "documentation": "Property startTransition",
    "description": "Added new property startTransition",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty startTransition\n\nNew source code:\n\n```typescript\nproperty startTransition\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property startTransition",
    "packageType": "javascript"
  },
  {
    "objectName": "status",
    "signature": "property status",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/status",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property status",
    "documentation": "Property status",
    "description": "Added new property status",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty status\n\nNew source code:\n\n```typescript\nproperty status\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property status",
    "packageType": "javascript"
  },
  {
    "objectName": "StrictMode",
    "signature": "function StrictMode",
    "objectType": "function",
    "objectIdentifier": "react/cjs/react/development/StrictMode",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function StrictMode",
    "documentation": "Module: cjs/react.development",
    "description": "Added new function StrictMode",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nModule: cjs/react.development\n\nNew source code:\n\n```typescript\nfunction StrictMode\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Module: cjs/react.development",
    "packageType": "javascript"
  },
  {
    "objectName": "StrictMode",
    "signature": "StrictMode: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/StrictMode",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "StrictMode: any",
    "documentation": "Exported variable StrictMode",
    "description": "Added new variable StrictMode",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable StrictMode\n\nNew source code:\n\n```typescript\nStrictMode: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable StrictMode",
    "packageType": "javascript"
  },
  {
    "objectName": "StrictMode",
    "signature": "property StrictMode",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/StrictMode",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property StrictMode",
    "documentation": "Property StrictMode",
    "description": "Added new property StrictMode",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty StrictMode\n\nNew source code:\n\n```typescript\nproperty StrictMode\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property StrictMode",
    "packageType": "javascript"
  },
  {
    "objectName": "Suspense",
    "signature": "function Suspense",
    "objectType": "function",
    "objectIdentifier": "react/cjs/react/development/Suspense",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function Suspense",
    "documentation": "Module: cjs/react.development",
    "description": "Added new function Suspense",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nModule: cjs/react.development\n\nNew source code:\n\n```typescript\nfunction Suspense\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Module: cjs/react.development",
    "packageType": "javascript"
  },
  {
    "objectName": "Suspense",
    "signature": "Suspense: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/Suspense",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "Suspense: any",
    "documentation": "Exported variable Suspense",
    "description": "Added new variable Suspense",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable Suspense\n\nNew source code:\n\n```typescript\nSuspense: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable Suspense",
    "packageType": "javascript"
  },
  {
    "objectName": "Suspense",
    "signature": "property Suspense",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/Suspense",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property Suspense",
    "documentation": "Property Suspense",
    "description": "Added new property Suspense",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty Suspense\n\nNew source code:\n\n```typescript\nproperty Suspense\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property Suspense",
    "packageType": "javascript"
  },
  {
    "objectName": "T",
    "signature": "property T",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/T",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property T",
    "documentation": "Property T",
    "description": "Added new property T",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty T\n\nNew source code:\n\n```typescript\nproperty T\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property T",
    "packageType": "javascript"
  },
  {
    "objectName": "TransitionStartFunction",
    "signature": "interface TransitionStartFunction",
    "objectType": "interface",
    "objectIdentifier": "react/interfaces/TransitionStartFunction",
    "packagePath": "react",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "interface TransitionStartFunction",
    "documentation": "",
    "description": "Added new interface TransitionStartFunction",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nInterface TransitionStartFunction from react.\n\nSignature: interface TransitionStartFunction\n\nNew source code:\n\n```typescript\ninterface TransitionStartFunction\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Interface TransitionStartFunction from react.\n\nSignature: interface TransitionStartFunction",
    "packageType": "javascript"
  },
  {
    "objectName": "TransitionStartFunction.callback",
    "signature": "callback: TransitionFunction): void",
    "objectType": "property",
    "objectIdentifier": "react/interfaces/TransitionStartFunction.callback",
    "packagePath": "TransitionStartFunction",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "callback: TransitionFunction): void",
    "documentation": "",
    "description": "Added new property TransitionStartFunction.callback",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty TransitionStartFunction.callback from TransitionStartFunction.\n\nSignature: callback: TransitionFunction): void\n\nNew source code:\n\n```typescript\ncallback: TransitionFunction): void\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property TransitionStartFunction.callback from TransitionStartFunction.\n\nSignature: callback: TransitionFunction): void",
    "packageType": "javascript"
  },
  {
    "objectName": "unstable_useCacheRefresh",
    "signature": "function unstable_useCacheRefresh",
    "objectType": "function",
    "objectIdentifier": "react/cjs/react/development/unstable_useCacheRefresh",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function unstable_useCacheRefresh",
    "documentation": "Module: cjs/react.development",
    "description": "Added new function unstable_useCacheRefresh",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nModule: cjs/react.development\n\nNew source code:\n\n```typescript\nfunction unstable_useCacheRefresh\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Module: cjs/react.development",
    "packageType": "javascript"
  },
  {
    "objectName": "unstable_useCacheRefresh",
    "signature": "unstable_useCacheRefresh: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/unstable_useCacheRefresh",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "unstable_useCacheRefresh: any",
    "documentation": "Exported variable unstable_useCacheRefresh",
    "description": "Added new variable unstable_useCacheRefresh",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable unstable_useCacheRefresh\n\nNew source code:\n\n```typescript\nunstable_useCacheRefresh: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable unstable_useCacheRefresh",
    "packageType": "javascript"
  },
  {
    "objectName": "unstable_useCacheRefresh",
    "signature": "property unstable_useCacheRefresh",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/unstable_useCacheRefresh",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property unstable_useCacheRefresh",
    "documentation": "Property unstable_useCacheRefresh",
    "description": "Added new property unstable_useCacheRefresh",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty unstable_useCacheRefresh\n\nNew source code:\n\n```typescript\nproperty unstable_useCacheRefresh\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property unstable_useCacheRefresh",
    "packageType": "javascript"
  },
  {
    "objectName": "use",
    "signature": "function use",
    "objectType": "function",
    "objectIdentifier": "react/functions/use",
    "packagePath": "react",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function use",
    "documentation": "",
    "description": "Added new function use",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nFunction use from react.\n\nSignature: function use\n\nNew source code:\n\n```typescript\nfunction use\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Function use from react.\n\nSignature: function use",
    "packageType": "javascript"
  },
  {
    "objectName": "use",
    "signature": "use: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/use",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "use: any",
    "documentation": "Exported variable use",
    "description": "Added new variable use",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable use\n\nNew source code:\n\n```typescript\nuse: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable use",
    "packageType": "javascript"
  },
  {
    "objectName": "use",
    "signature": "property use",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/use",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property use",
    "documentation": "Property use",
    "description": "Added new property use",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty use\n\nNew source code:\n\n```typescript\nproperty use\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property use",
    "packageType": "javascript"
  },
  {
    "objectName": "useActionState",
    "signature": "function useActionState",
    "objectType": "function",
    "objectIdentifier": "react/functions/useActionState",
    "packagePath": "react",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function useActionState",
    "documentation": "",
    "description": "Added new function useActionState",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nFunction useActionState from react.\n\nSignature: function useActionState\n\nNew source code:\n\n```typescript\nfunction useActionState\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Function useActionState from react.\n\nSignature: function useActionState",
    "packageType": "javascript"
  },
  {
    "objectName": "useActionState",
    "signature": "useActionState: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/useActionState",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "useActionState: any",
    "documentation": "Exported variable useActionState",
    "description": "Added new variable useActionState",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable useActionState\n\nNew source code:\n\n```typescript\nuseActionState: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable useActionState",
    "packageType": "javascript"
  },
  {
    "objectName": "useActionState",
    "signature": "property useActionState",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/useActionState",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property useActionState",
    "documentation": "Property useActionState",
    "description": "Added new property useActionState",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty useActionState\n\nNew source code:\n\n```typescript\nproperty useActionState\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property useActionState",
    "packageType": "javascript"
  },
  {
    "objectName": "useCallback",
    "signature": "function useCallback",
    "objectType": "function",
    "objectIdentifier": "react/cjs/react/development/useCallback",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function useCallback",
    "documentation": "Module: cjs/react.development",
    "description": "Added new function useCallback",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nModule: cjs/react.development\n\nNew source code:\n\n```typescript\nfunction useCallback\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Module: cjs/react.development",
    "packageType": "javascript"
  },
  {
    "objectName": "useCallback",
    "signature": "useCallback: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/useCallback",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "useCallback: any",
    "documentation": "Exported variable useCallback",
    "description": "Added new variable useCallback",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable useCallback\n\nNew source code:\n\n```typescript\nuseCallback: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable useCallback",
    "packageType": "javascript"
  },
  {
    "objectName": "useCallback",
    "signature": "property useCallback",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/useCallback",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property useCallback",
    "documentation": "Property useCallback",
    "description": "Added new property useCallback",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty useCallback\n\nNew source code:\n\n```typescript\nproperty useCallback\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property useCallback",
    "packageType": "javascript"
  },
  {
    "objectName": "useContext",
    "signature": "function useContext",
    "objectType": "function",
    "objectIdentifier": "react/cjs/react/development/useContext",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function useContext",
    "documentation": "Module: cjs/react.development",
    "description": "Added new function useContext",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nModule: cjs/react.development\n\nNew source code:\n\n```typescript\nfunction useContext\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Module: cjs/react.development",
    "packageType": "javascript"
  },
  {
    "objectName": "useContext",
    "signature": "useContext: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/useContext",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "useContext: any",
    "documentation": "Exported variable useContext",
    "description": "Added new variable useContext",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable useContext\n\nNew source code:\n\n```typescript\nuseContext: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable useContext",
    "packageType": "javascript"
  },
  {
    "objectName": "useContext",
    "signature": "property useContext",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/useContext",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property useContext",
    "documentation": "Property useContext",
    "description": "Added new property useContext",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty useContext\n\nNew source code:\n\n```typescript\nproperty useContext\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property useContext",
    "packageType": "javascript"
  },
  {
    "objectName": "useDebugValue",
    "signature": "function useDebugValue",
    "objectType": "function",
    "objectIdentifier": "react/cjs/react/development/useDebugValue",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function useDebugValue",
    "documentation": "Module: cjs/react.development",
    "description": "Added new function useDebugValue",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nModule: cjs/react.development\n\nNew source code:\n\n```typescript\nfunction useDebugValue\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Module: cjs/react.development",
    "packageType": "javascript"
  },
  {
    "objectName": "useDebugValue",
    "signature": "useDebugValue: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/useDebugValue",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "useDebugValue: any",
    "documentation": "Exported variable useDebugValue",
    "description": "Added new variable useDebugValue",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable useDebugValue\n\nNew source code:\n\n```typescript\nuseDebugValue: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable useDebugValue",
    "packageType": "javascript"
  },
  {
    "objectName": "useDebugValue",
    "signature": "property useDebugValue",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/useDebugValue",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property useDebugValue",
    "documentation": "Property useDebugValue",
    "description": "Added new property useDebugValue",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty useDebugValue\n\nNew source code:\n\n```typescript\nproperty useDebugValue\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property useDebugValue",
    "packageType": "javascript"
  },
  {
    "objectName": "useDeferredValue",
    "signature": "function useDeferredValue",
    "objectType": "function",
    "objectIdentifier": "react/functions/useDeferredValue",
    "packagePath": "react",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function useDeferredValue",
    "documentation": "Used to represent DOM API's where users can either pass true or false as a boolean or as its equivalent strings. type Booleanish = boolean | \"true\" | \"false\"; @see {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/crossorigin MDN} type CrossOrigin = \"anonymous\" | \"use-credentials\" | \"\" | undefined; declare const UNDEFINED_VOID_ONLY: unique symbol; @internal Use `Awaited<ReactNode>` instead // Helper type to enable `Awaited<ReactNode>`. // Must be a copy of the non-thenables of `ReactNode`. type AwaitedReactNode = | React.ReactElement | string | number | bigint | Iterable<React.ReactNode> | React.ReactPortal | boolean | null | undefined | React.DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES[ keyof React.DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES ]; The function returned from an effect passed to {@link React.useEffect useEffect}, which can be used to clean up the effect when the component unmounts. * @see {@link https://react.dev/reference/react/useEffect React Docs} type Destructor = () => void | { [UNDEFINED_VOID_ONLY]: never }; type VoidOrUndefinedOnly = void | { [UNDEFINED_VOID_ONLY]: never }; // eslint-disable-next-line @definitelytyped/export-just-namespace export = React; export as namespace React; declare namespace React { // // React Elements // ---------------------------------------------------------------------- Used to retrieve the possible components which accept a given set of props. * Can be passed no type parameters to get a union of all possible components and tags. * Is a superset of {@link ComponentType}. * @template P The props to match against. If not passed, defaults to any. @template Tag An optional tag to match against. If not passed, attempts to match against all possible tags. * @example * ```tsx // All components and tags (img, embed etc.) // which accept `src` type SrcComponents = ElementType<{ src: any }>; ``` * @example * ```tsx // All components type AllComponents = ElementType; ``` * @example * ```tsx // All custom components which match `src`, and tags which // match `src`, narrowed down to just `audio` and `embed` type SrcComponents = ElementType<{ src: any }, 'audio' | 'embed'>; ``` type ElementType<P = any, Tag extends keyof JSX.IntrinsicElements = keyof JSX.IntrinsicElements> = | { [K in Tag]: P extends JSX.IntrinsicElements[K] ? K : never }[Tag] | ComponentType<P>; Represents any user-defined component, either as a function or a class. * Similar to {@link JSXElementConstructor}, but with extra properties like {@link FunctionComponent.defaultProps defaultProps }. * @template P The props the component accepts. * @see {@link ComponentClass} @see {@link FunctionComponent} type ComponentType<P = {}> = ComponentClass<P> | FunctionComponent<P>; Represents any user-defined component, either as a function or a class. * Similar to {@link ComponentType}, but without extra properties like {@link FunctionComponent.defaultProps defaultProps }. * @template P The props the component accepts. type JSXElementConstructor<P> = | (( props: P, ) => ReactNode | Promise<ReactNode>) // constructor signature must match React.Component | (new(props: P) => Component<any, any>); Created by {@link createRef}, or {@link useRef} when passed `null`. * @template T The type of the ref's value. * @example * ```tsx const ref = createRef<HTMLDivElement>(); * ref.current = document.createElement('div'); // Error ``` interface RefObject<T> { The current value of the ref. current: T; } interface DO_NOT_USE_OR_YOU_WILL_BE_FIRED_CALLBACK_REF_RETURN_VALUES { } A callback fired whenever the ref's value changes. * @template T The type of the ref's value. * @see {@link https://react.dev/reference/react-dom/components/common#ref-callback React Docs} * @example * ```tsx <div ref={(node) => console.log(node)} /> ``` type RefCallback<T> = { bivarianceHack( instance: T | null, ): | void | (() => VoidOrUndefinedOnly) | DO_NOT_USE_OR_YOU_WILL_BE_FIRED_CALLBACK_REF_RETURN_VALUES[ keyof DO_NOT_USE_OR_YOU_WILL_BE_FIRED_CALLBACK_REF_RETURN_VALUES ]; }[\"bivarianceHack\"]; A union type of all possible shapes for React refs. * @see {@link RefCallback} @see {@link RefObject} type Ref<T> = RefCallback<T> | RefObject<T | null> | null; @deprecated Use `Ref` instead. String refs are no longer supported. If you're typing a library with support for React versions with string refs, use `RefAttributes<T>['ref']` instead. type LegacyRef<T> = Ref<T>; @deprecated Use `ComponentRef<T>` instead * Retrieves the type of the 'ref' prop for a given component type or tag name. * @template C The component type. * @example * ```tsx type MyComponentRef = React.ElementRef<typeof MyComponent>; ``` * @example * ```tsx type DivRef = React.ElementRef<'div'>; ``` type ElementRef< C extends | ForwardRefExoticComponent<any> | { new(props: any): Component<any> } | ((props: any) => ReactNode) | keyof JSX.IntrinsicElements, > = ComponentRef<C>; type ComponentState = any; A value which uniquely identifies a node among items in an array. * @see {@link https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key React Docs} type Key = string | number | bigint; @internal The props any component can receive. You don't have to add this type. All components automatically accept these props. ```tsx const Component = () => <div />; <Component key=\"one\" /> ``` * WARNING: The implementation of a component will never have access to these attributes. The following example would be incorrect usage because {@link Component} would never have access to `key`: ```tsx const Component = (props: React.Attributes) => props.key; ``` interface Attributes { key?: Key | null | undefined; } The props any component accepting refs can receive. Class components, built-in browser components (e.g. `div`) and forwardRef components can receive refs and automatically accept these props. ```tsx const Component = forwardRef(() => <div />); <Component ref={(current) => console.log(current)} /> ``` * You only need this type if you manually author the types of props that need to be compatible with legacy refs. ```tsx interface Props extends React.RefAttributes<HTMLDivElement> {} declare const Component: React.FunctionComponent<Props>; ``` * Otherwise it's simpler to directly use {@link Ref} since you can safely use the props type to describe to props that a consumer can pass to the component as well as describing the props the implementation of a component \"sees\". {@link RefAttributes} is generally not safe to describe both consumer and seen props. * ```tsx interface Props extends { ref?: React.Ref<HTMLDivElement> | undefined; } declare const Component: React.FunctionComponent<Props>; ``` * WARNING: The implementation of a component will not have access to the same type in versions of React supporting string refs. The following example would be incorrect usage because {@link Component} would never have access to a `ref` with type `string` ```tsx const Component = (props: React.RefAttributes) => props.ref; ``` interface RefAttributes<T> extends Attributes { Allows getting a ref to the component instance. Once the component unmounts, React will set `ref.current` to `null` (or call the ref with `null` if you passed a callback ref). * @see {@link https://react.dev/learn/referencing-values-with-refs#refs-and-the-dom React Docs} ref?: Ref<T> | undefined; } Represents the built-in attributes available to class components. interface ClassAttributes<T> extends RefAttributes<T> { } Represents a JSX element. * Where {@link ReactNode} represents everything that can be rendered, `ReactElement` only represents JSX. * @template P The type of the props object @template T The type of the component or tag * @example * ```tsx const element: ReactElement = <div />; ``` interface ReactElement< P = unknown, T extends string | JSXElementConstructor<any> = string | JSXElementConstructor<any>, > { type: T; props: P; key: string | null; } @deprecated interface ReactComponentElement< T extends keyof JSX.IntrinsicElements | JSXElementConstructor<any>, P = Pick<ComponentProps<T>, Exclude<keyof ComponentProps<T>, \"key\" | \"ref\">>, > extends ReactElement<P, Exclude<T, number>> {} @deprecated Use `ReactElement<P, React.FunctionComponent<P>>` interface FunctionComponentElement<P> extends ReactElement<P, FunctionComponent<P>> { @deprecated Use `element.props.ref` instead. ref?: (\"ref\" extends keyof P ? P extends { ref?: infer R | undefined } ? R : never : never) | undefined; } @deprecated Use `ReactElement<P, React.ComponentClass<P>>` type CElement<P, T extends Component<P, ComponentState>> = ComponentElement<P, T>; @deprecated Use `ReactElement<P, React.ComponentClass<P>>` interface ComponentElement<P, T extends Component<P, ComponentState>> extends ReactElement<P, ComponentClass<P>> { @deprecated Use `element.props.ref` instead. ref?: Ref<T> | undefined; } @deprecated Use {@link ComponentElement} instead. type ClassicElement<P> = CElement<P, ClassicComponent<P, ComponentState>>; // string fallback for custom web-components @deprecated Use `ReactElement<P, string>` interface DOMElement<P extends HTMLAttributes<T> | SVGAttributes<T>, T extends Element> extends ReactElement<P, string> { @deprecated Use `element.props.ref` instead. ref: Ref<T>; } // ReactHTML for ReactHTMLElement interface ReactHTMLElement<T extends HTMLElement> extends DetailedReactHTMLElement<AllHTMLAttributes<T>, T> {} interface DetailedReactHTMLElement<P extends HTMLAttributes<T>, T extends HTMLElement> extends DOMElement<P, T> { type: HTMLElementType; } // ReactSVG for ReactSVGElement interface ReactSVGElement extends DOMElement<SVGAttributes<SVGElement>, SVGElement> { type: SVGElementType; } interface ReactPortal extends ReactElement { children: ReactNode; } Different release channels declare additional types of ReactNode this particular release channel accepts. App or library types should never augment this interface. interface DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES {} Represents all of the things React can render. * Where {@link ReactElement} only represents JSX, `ReactNode` represents everything that can be rendered. * @see {@link https://react-typescript-cheatsheet.netlify.app/docs/react-types/reactnode/ React TypeScript Cheatsheet} * @example * ```tsx // Typing children type Props = { children: ReactNode } * const Component = ({ children }: Props) => <div>{children}</div> * <Component>hello</Component> ``` * @example * ```tsx // Typing a custom element type Props = { customElement: ReactNode } * const Component = ({ customElement }: Props) => <div>{customElement}</div> * <Component customElement={<div>hello</div>} /> ``` // non-thenables need to be kept in sync with AwaitedReactNode type ReactNode = | ReactElement | string | number | bigint | Iterable<ReactNode> | ReactPortal | boolean | null | undefined | DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES[ keyof DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES ] | Promise<AwaitedReactNode>; // // Top Level API // ---------------------------------------------------------------------- // DOM Elements // TODO: generalize this to everything in `keyof ReactHTML`, not just \"input\" function createElement( type: \"input\", props?: InputHTMLAttributes<HTMLInputElement> & ClassAttributes<HTMLInputElement> | null, ...children: ReactNode[] ): DetailedReactHTMLElement<InputHTMLAttributes<HTMLInputElement>, HTMLInputElement>; function createElement<P extends HTMLAttributes<T>, T extends HTMLElement>( type: HTMLElementType, props?: ClassAttributes<T> & P | null, ...children: ReactNode[] ): DetailedReactHTMLElement<P, T>; function createElement<P extends SVGAttributes<T>, T extends SVGElement>( type: SVGElementType, props?: ClassAttributes<T> & P | null, ...children: ReactNode[] ): ReactSVGElement; function createElement<P extends DOMAttributes<T>, T extends Element>( type: string, props?: ClassAttributes<T> & P | null, ...children: ReactNode[] ): DOMElement<P, T>; // Custom components function createElement<P extends {}>( type: FunctionComponent<P>, props?: Attributes & P | null, ...children: ReactNode[] ): FunctionComponentElement<P>; function createElement<P extends {}, T extends Component<P, ComponentState>, C extends ComponentClass<P>>( type: ClassType<P, T, C>, props?: ClassAttributes<T> & P | null, ...children: ReactNode[] ): CElement<P, T>; function createElement<P extends {}>( type: FunctionComponent<P> | ComponentClass<P> | string, props?: Attributes & P | null, ...children: ReactNode[] ): ReactElement<P>; // DOM Elements // ReactHTMLElement function cloneElement<P extends HTMLAttributes<T>, T extends HTMLElement>( element: DetailedReactHTMLElement<P, T>, props?: P, ...children: ReactNode[] ): DetailedReactHTMLElement<P, T>; // ReactHTMLElement, less specific function cloneElement<P extends HTMLAttributes<T>, T extends HTMLElement>( element: ReactHTMLElement<T>, props?: P, ...children: ReactNode[] ): ReactHTMLElement<T>; // SVGElement function cloneElement<P extends SVGAttributes<T>, T extends SVGElement>( element: ReactSVGElement, props?: P, ...children: ReactNode[] ): ReactSVGElement; // DOM Element (has to be the last, because type checking stops at first overload that fits) function cloneElement<P extends DOMAttributes<T>, T extends Element>( element: DOMElement<P, T>, props?: DOMAttributes<T> & P, ...children: ReactNode[] ): DOMElement<P, T>; // Custom components function cloneElement<P>( element: FunctionComponentElement<P>, props?: Partial<P> & Attributes, ...children: ReactNode[] ): FunctionComponentElement<P>; function cloneElement<P, T extends Component<P, ComponentState>>( element: CElement<P, T>, props?: Partial<P> & ClassAttributes<T>, ...children: ReactNode[] ): CElement<P, T>; function cloneElement<P>( element: ReactElement<P>, props?: Partial<P> & Attributes, ...children: ReactNode[] ): ReactElement<P>; Describes the props accepted by a Context {@link Provider}. * @template T The type of the value the context provides. interface ProviderProps<T> { value: T; children?: ReactNode | undefined; } Describes the props accepted by a Context {@link Consumer}. * @template T The type of the value the context provides. interface ConsumerProps<T> { children: (value: T) => ReactNode; } An object masquerading as a component. These are created by functions like {@link forwardRef}, {@link memo}, and {@link createContext}. * In order to make TypeScript work, we pretend that they are normal components. * But they are, in fact, not callable - instead, they are objects which are treated specially by the renderer. * @template P The props the component accepts. interface ExoticComponent<P = {}> { (props: P): ReactNode; readonly $$typeof: symbol; } An {@link ExoticComponent} with a `displayName` property applied to it. * @template P The props the component accepts. interface NamedExoticComponent<P = {}> extends ExoticComponent<P> { Used in debugging messages. You might want to set it explicitly if you want to display a different name for debugging purposes. * @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs} displayName?: string | undefined; } An {@link ExoticComponent} with a `propTypes` property applied to it. * @template P The props the component accepts. interface ProviderExoticComponent<P> extends ExoticComponent<P> { } Used to retrieve the type of a context object from a {@link Context}. * @template C The context object. * @example * ```tsx import { createContext } from 'react'; * const MyContext = createContext({ foo: 'bar' }); * type ContextType = ContextType<typeof MyContext>; // ContextType = { foo: string } ``` type ContextType<C extends Context<any>> = C extends Context<infer T> ? T : never; Wraps your components to specify the value of this context for all components inside. * @see {@link https://react.dev/reference/react/createContext#provider React Docs} * @example * ```tsx import { createContext } from 'react'; * const ThemeContext = createContext('light'); * function App() { return ( <ThemeContext.Provider value=\"dark\"> <Toolbar /> </ThemeContext.Provider> ); } ``` type Provider<T> = ProviderExoticComponent<ProviderProps<T>>; The old way to read context, before {@link useContext} existed. * @see {@link https://react.dev/reference/react/createContext#consumer React Docs} * @example * ```tsx import { UserContext } from './user-context'; * function Avatar() { return ( <UserContext.Consumer> {user => <img src={user.profileImage} alt={user.name} />} </UserContext.Consumer> ); } ``` type Consumer<T> = ExoticComponent<ConsumerProps<T>>; Context lets components pass information deep down without explicitly passing props. * Created from {@link createContext} * @see {@link https://react.dev/learn/passing-data-deeply-with-context React Docs} @see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/context/ React TypeScript Cheatsheet} * @example * ```tsx import { createContext } from 'react'; * const ThemeContext = createContext('light'); ``` interface Context<T> extends Provider<T> { Provider: Provider<T>; Consumer: Consumer<T>; Used in debugging messages. You might want to set it explicitly if you want to display a different name for debugging purposes. * @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs} displayName?: string | undefined; } Lets you create a {@link Context} that components can provide or read. * @param defaultValue The value you want the context to have when there is no matching {@link Provider} in the tree above the component reading the context. This is meant as a \"last resort\" fallback. * @see {@link https://react.dev/reference/react/createContext#reference React Docs} @see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/context/ React TypeScript Cheatsheet} * @example * ```tsx import { createContext } from 'react'; * const ThemeContext = createContext('light'); function App() { return ( <ThemeContext value=\"dark\"> <Toolbar /> </ThemeContext> ); } ``` function createContext<T>( // If you thought this should be optional, see // https://github.com/DefinitelyTyped/DefinitelyTyped/pull/24509#issuecomment-382213106 defaultValue: T, ): Context<T>; function isValidElement<P>(object: {} | null | undefined): object is ReactElement<P>; const Children: { map<T, C>( children: C | readonly C[], fn: (child: C, index: number) => T, ): C extends null | undefined ? C : Array<Exclude<T, boolean | null | undefined>>; forEach<C>(children: C | readonly C[], fn: (child: C, index: number) => void): void; count(children: any): number; only<C>(children: C): C extends any[] ? never : C; toArray(children: ReactNode | ReactNode[]): Array<Exclude<ReactNode, boolean | null | undefined>>; }; export interface FragmentProps { children?: React.ReactNode; } Lets you group elements without a wrapper node. * @see {@link https://react.dev/reference/react/Fragment React Docs} * @example * ```tsx import { Fragment } from 'react'; * <Fragment> <td>Hello</td> <td>World</td> </Fragment> ``` * @example * ```tsx // Using the <></> shorthand syntax: * <> <td>Hello</td> <td>World</td> </> ``` const Fragment: ExoticComponent<FragmentProps>; Lets you find common bugs in your components early during development. * @see {@link https://react.dev/reference/react/StrictMode React Docs} * @example * ```tsx import { StrictMode } from 'react'; * <StrictMode> <App /> </StrictMode> ``` const StrictMode: ExoticComponent<{ children?: ReactNode | undefined }>; The props accepted by {@link Suspense}. * @see {@link https://react.dev/reference/react/Suspense React Docs} interface SuspenseProps { children?: ReactNode | undefined; A fallback react tree to show when a Suspense child (like React.lazy) suspends fallback?: ReactNode; A name for this Suspense boundary for instrumentation purposes. The name will help identify this boundary in React DevTools. name?: string | undefined; } Lets you display a fallback until its children have finished loading. * @see {@link https://react.dev/reference/react/Suspense React Docs} * @example * ```tsx import { Suspense } from 'react'; * <Suspense fallback={<Loading />}> <ProfileDetails /> </Suspense> ``` const Suspense: ExoticComponent<SuspenseProps>; const version: string; The callback passed to {@link ProfilerProps.onRender}. * @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs} type ProfilerOnRenderCallback = ( The string id prop of the {@link Profiler} tree that has just committed. This lets you identify which part of the tree was committed if you are using multiple profilers. * @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs} id: string, This lets you know whether the tree has just been mounted for the first time or re-rendered due to a change in props, state, or hooks. * @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs} phase: \"mount\" | \"update\" | \"nested-update\", The number of milliseconds spent rendering the {@link Profiler} and its descendants for the current update. This indicates how well the subtree makes use of memoization (e.g. {@link memo} and {@link useMemo}). Ideally this value should decrease significantly after the initial mount as many of the descendants will only need to re-render if their specific props change. * @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs} actualDuration: number, The number of milliseconds estimating how much time it would take to re-render the entire {@link Profiler} subtree without any optimizations. It is calculated by summing up the most recent render durations of each component in the tree. This value estimates a worst-case cost of rendering (e.g. the initial mount or a tree with no memoization). Compare {@link actualDuration} against it to see if memoization is working. * @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs} baseDuration: number, A numeric timestamp for when React began rendering the current update. * @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs} startTime: number, A numeric timestamp for when React committed the current update. This value is shared between all profilers in a commit, enabling them to be grouped if desirable. * @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs} commitTime: number, ) => void; The props accepted by {@link Profiler}. * @see {@link https://react.dev/reference/react/Profiler React Docs} interface ProfilerProps { children?: ReactNode | undefined; id: string; onRender: ProfilerOnRenderCallback; } Lets you measure rendering performance of a React tree programmatically. * @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs} * @example * ```tsx <Profiler id=\"App\" onRender={onRender}> <App /> </Profiler> ``` const Profiler: ExoticComponent<ProfilerProps>; // // Component API // ---------------------------------------------------------------------- type ReactInstance = Component<any> | Element; // Base component for plain JS classes interface Component<P = {}, S = {}, SS = any> extends ComponentLifecycle<P, S, SS> {} class Component<P, S> { If set, `this.context` will be set at runtime to the current value of the given Context. * @example * ```ts type MyContext = number const Ctx = React.createContext<MyContext>(0) * class Foo extends React.Component { static contextType = Ctx context!: React.ContextType<typeof Ctx> render () { return <>My context's value: {this.context}</>; } } ``` * @see {@link https://react.dev/reference/react/Component#static-contexttype} static contextType?: Context<any> | undefined; Ignored by React. @deprecated Only kept in types for backwards compatibility. Will be removed in a future major release. static propTypes?: any; If using the new style context, re-declare this in your class to be the `React.ContextType` of your `static contextType`. Should be used with type annotation or static contextType. * @example ```ts static contextType = MyContext // For TS pre-3.7: context!: React.ContextType<typeof MyContext> // For TS 3.7 and above: declare context: React.ContextType<typeof MyContext> ``` * @see {@link https://react.dev/reference/react/Component#context React Docs} context: unknown; // Keep in sync with constructor signature of JSXElementConstructor and ComponentClass. constructor(props: P); // We MUST keep setState() as a unified signature because it allows proper checking of the method return type. // See: https://github.com/DefinitelyTyped/DefinitelyTyped/issues/18365#issuecomment-351013257 // Also, the ` | S` allows intellisense to not be dumbisense setState<K extends keyof S>( state: ((prevState: Readonly<S>, props: Readonly<P>) => Pick<S, K> | S | null) | (Pick<S, K> | S | null), callback?: () => void, ): void; forceUpdate(callback?: () => void): void; render(): ReactNode; readonly props: Readonly<P>; state: Readonly<S>; } class PureComponent<P = {}, S = {}, SS = any> extends Component<P, S, SS> {} @deprecated Use `ClassicComponent` from `create-react-class` * @see {@link https://legacy.reactjs.org/docs/react-without-es6.html Legacy React Docs} @see {@link https://www.npmjs.com/package/create-react-class `create-react-class` on npm} interface ClassicComponent<P = {}, S = {}> extends Component<P, S> { replaceState(nextState: S, callback?: () => void): void; isMounted(): boolean; getInitialState?(): S; } // // Class Interfaces // ---------------------------------------------------------------------- Represents the type of a function component. Can optionally receive a type argument that represents the props the component receives. * @template P The props the component accepts. @see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/function_components React TypeScript Cheatsheet} @alias for {@link FunctionComponent} * @example * ```tsx // With props: type Props = { name: string } * const MyComponent: FC<Props> = (props) => { return <div>{props.name}</div> } ``` * @example * ```tsx // Without props: const MyComponentWithoutProps: FC = () => { return <div>MyComponentWithoutProps</div> } ``` type FC<P = {}> = FunctionComponent<P>; Represents the type of a function component. Can optionally receive a type argument that represents the props the component accepts. * @template P The props the component accepts. @see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/function_components React TypeScript Cheatsheet} * @example * ```tsx // With props: type Props = { name: string } * const MyComponent: FunctionComponent<Props> = (props) => { return <div>{props.name}</div> } ``` * @example * ```tsx // Without props: const MyComponentWithoutProps: FunctionComponent = () => { return <div>MyComponentWithoutProps</div> } ``` interface FunctionComponent<P = {}> { (props: P): ReactNode | Promise<ReactNode>; Ignored by React. @deprecated Only kept in types for backwards compatibility. Will be removed in a future major release. propTypes?: any; Used in debugging messages. You might want to set it explicitly if you want to display a different name for debugging purposes. * @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs} * @example * ```tsx * const MyComponent: FC = () => { return <div>Hello!</div> } * MyComponent.displayName = 'MyAwesomeComponent' ``` displayName?: string | undefined; } The type of the ref received by a {@link ForwardRefRenderFunction}. * @see {@link ForwardRefRenderFunction} // Making T nullable is assuming the refs will be managed by React or the component impl will write it somewhere else. // But this isn't necessarily true. We haven't heard complains about it yet and hopefully `forwardRef` is removed from React before we do. type ForwardedRef<T> = ((instance: T | null) => void) | RefObject<T | null> | null; The type of the function passed to {@link forwardRef}. This is considered different to a normal {@link FunctionComponent} because it receives an additional argument, * @param props Props passed to the component, if any. @param ref A ref forwarded to the component of type {@link ForwardedRef}. * @template T The type of the forwarded ref. @template P The type of the props the component accepts. * @see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/forward_and_create_ref/ React TypeScript Cheatsheet} @see {@link forwardRef} interface ForwardRefRenderFunction<T, P = {}> { (props: P, ref: ForwardedRef<T>): ReactNode; Used in debugging messages. You might want to set it explicitly if you want to display a different name for debugging purposes. * Will show `ForwardRef(${Component.displayName || Component.name})` in devtools by default, but can be given its own specific name. * @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs} displayName?: string | undefined; Ignored by React. @deprecated Only kept in types for backwards compatibility. Will be removed in a future major release. propTypes?: any; } Represents a component class in React. * @template P The props the component accepts. @template S The internal state of the component. interface ComponentClass<P = {}, S = ComponentState> extends StaticLifecycle<P, S> { // constructor signature must match React.Component new(props: P): Component<P, S>; Ignored by React. @deprecated Only kept in types for backwards compatibility. Will be removed in a future major release. propTypes?: any; contextType?: Context<any> | undefined; defaultProps?: Partial<P> | undefined; Used in debugging messages. You might want to set it explicitly if you want to display a different name for debugging purposes. * @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs} displayName?: string | undefined; } @deprecated Use `ClassicComponentClass` from `create-react-class` * @see {@link https://legacy.reactjs.org/docs/react-without-es6.html Legacy React Docs} @see {@link https://www.npmjs.com/package/create-react-class `create-react-class` on npm} interface ClassicComponentClass<P = {}> extends ComponentClass<P> { new(props: P): ClassicComponent<P, ComponentState>; getDefaultProps?(): P; } Used in {@link createElement} and {@link createFactory} to represent a class. * An intersection type is used to infer multiple type parameters from a single argument, which is useful for many top-level API defs. See {@link https://github.com/Microsoft/TypeScript/issues/7234 this GitHub issue} for more info. type ClassType<P, T extends Component<P, ComponentState>, C extends ComponentClass<P>> = & C & (new(props: P) => T); // // Component Specs and Lifecycle // ---------------------------------------------------------------------- // This should actually be something like `Lifecycle<P, S> | DeprecatedLifecycle<P, S>`, // as React will _not_ call the deprecated lifecycle methods if any of the new lifecycle // methods are present. interface ComponentLifecycle<P, S, SS = any> extends NewLifecycle<P, S, SS>, DeprecatedLifecycle<P, S> { Called immediately after a component is mounted. Setting state here will trigger re-rendering. componentDidMount?(): void; Called to determine whether the change in props and state should trigger a re-render. * `Component` always returns true. `PureComponent` implements a shallow comparison on props and state and returns true if any props or states have changed. * If false is returned, {@link Component.render}, `componentWillUpdate` and `componentDidUpdate` will not be called. shouldComponentUpdate?(nextProps: Readonly<P>, nextState: Readonly<S>, nextContext: any): boolean; Called immediately before a component is destroyed. Perform any necessary cleanup in this method, such as cancelled network requests, or cleaning up any DOM elements created in `componentDidMount`. componentWillUnmount?(): void; Catches exceptions generated in descendant components. Unhandled exceptions will cause the entire component tree to unmount. componentDidCatch?(error: Error, errorInfo: ErrorInfo): void; } // Unfortunately, we have no way of declaring that the component constructor must implement this interface StaticLifecycle<P, S> { getDerivedStateFromProps?: GetDerivedStateFromProps<P, S> | undefined; getDerivedStateFromError?: GetDerivedStateFromError<P, S> | undefined; } type GetDerivedStateFromProps<P, S> = Returns an update to a component's state based on its new props and old state. * Note: its presence prevents any of the deprecated lifecycle methods from being invoked (nextProps: Readonly<P>, prevState: S) => Partial<S> | null; type GetDerivedStateFromError<P, S> = This lifecycle is invoked after an error has been thrown by a descendant component. It receives the error that was thrown as a parameter and should return a value to update state. * Note: its presence prevents any of the deprecated lifecycle methods from being invoked (error: any) => Partial<S> | null; // This should be \"infer SS\" but can't use it yet interface NewLifecycle<P, S, SS> { Runs before React applies the result of {@link Component.render render} to the document, and returns an object to be given to {@link componentDidUpdate}. Useful for saving things such as scroll position before {@link Component.render render} causes changes to it. * Note: the presence of this method prevents any of the deprecated lifecycle events from running. getSnapshotBeforeUpdate?(prevProps: Readonly<P>, prevState: Readonly<S>): SS | null; Called immediately after updating occurs. Not called for the initial render. * The snapshot is only present if {@link getSnapshotBeforeUpdate} is present and returns non-null. componentDidUpdate?(prevProps: Readonly<P>, prevState: Readonly<S>, snapshot?: SS): void; } interface DeprecatedLifecycle<P, S> { Called immediately before mounting occurs, and before {@link Component.render}. Avoid introducing any side-effects or subscriptions in this method. * Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate} or {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents this from being invoked. * @deprecated 16.3, use {@link ComponentLifecycle.componentDidMount componentDidMount} or the constructor instead; will stop working in React 17 @see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#initializing-state} @see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path} componentWillMount?(): void; Called immediately before mounting occurs, and before {@link Component.render}. Avoid introducing any side-effects or subscriptions in this method. * This method will not stop working in React 17. * Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate} or {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents this from being invoked. * @deprecated 16.3, use {@link ComponentLifecycle.componentDidMount componentDidMount} or the constructor instead @see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#initializing-state} @see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path} UNSAFE_componentWillMount?(): void; Called when the component may be receiving new props. React may call this even if props have not changed, so be sure to compare new and existing props if you only want to handle changes. * Calling {@link Component.setState} generally does not trigger this method. * Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate} or {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents this from being invoked. * @deprecated 16.3, use static {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} instead; will stop working in React 17 @see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#updating-state-based-on-props} @see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path} componentWillReceiveProps?(nextProps: Readonly<P>, nextContext: any): void; Called when the component may be receiving new props. React may call this even if props have not changed, so be sure to compare new and existing props if you only want to handle changes. * Calling {@link Component.setState} generally does not trigger this method. * This method will not stop working in React 17. * Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate} or {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents this from being invoked. * @deprecated 16.3, use static {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} instead @see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#updating-state-based-on-props} @see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path} UNSAFE_componentWillReceiveProps?(nextProps: Readonly<P>, nextContext: any): void; Called immediately before rendering when new props or state is received. Not called for the initial render. * Note: You cannot call {@link Component.setState} here. * Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate} or {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents this from being invoked. * @deprecated 16.3, use getSnapshotBeforeUpdate instead; will stop working in React 17 @see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#reading-dom-properties-before-an-update} @see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path} componentWillUpdate?(nextProps: Readonly<P>, nextState: Readonly<S>, nextContext: any): void; Called immediately before rendering when new props or state is received. Not called for the initial render. * Note: You cannot call {@link Component.setState} here. * This method will not stop working in React 17. * Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate} or {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents this from being invoked. * @deprecated 16.3, use getSnapshotBeforeUpdate instead @see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#reading-dom-properties-before-an-update} @see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path} UNSAFE_componentWillUpdate?(nextProps: Readonly<P>, nextState: Readonly<S>, nextContext: any): void; } function createRef<T>(): RefObject<T | null>; The type of the component returned from {@link forwardRef}. * @template P The props the component accepts, if any. * @see {@link ExoticComponent} interface ForwardRefExoticComponent<P> extends NamedExoticComponent<P> { Ignored by React. @deprecated Only kept in types for backwards compatibility. Will be removed in a future major release. propTypes?: any; } Lets your component expose a DOM node to a parent component using a ref. * @see {@link https://react.dev/reference/react/forwardRef React Docs} @see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/forward_and_create_ref/ React TypeScript Cheatsheet} * @param render See the {@link ForwardRefRenderFunction}. * @template T The type of the DOM node. @template P The props the component accepts, if any. * @example * ```tsx interface Props { children?: ReactNode; type: \"submit\" | \"button\"; } * export const FancyButton = forwardRef<HTMLButtonElement, Props>((props, ref) => ( <button ref={ref} className=\"MyClassName\" type={props.type}> {props.children} </button> )); ``` function forwardRef<T, P = {}>( render: ForwardRefRenderFunction<T, PropsWithoutRef<P>>, ): ForwardRefExoticComponent<PropsWithoutRef<P> & RefAttributes<T>>; Omits the 'ref' attribute from the given props object. * @template Props The props object type. type PropsWithoutRef<Props> = // Omit would not be sufficient for this. We'd like to avoid unnecessary mapping and need a distributive conditional to support unions. // see: https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types // https://github.com/Microsoft/TypeScript/issues/28339 Props extends any ? (\"ref\" extends keyof Props ? Omit<Props, \"ref\"> : Props) : Props; Ensures that the props do not include string ref, which cannot be forwarded @deprecated Use `Props` directly. `PropsWithRef<Props>` is just an alias for `Props` type PropsWithRef<Props> = Props; type PropsWithChildren<P = unknown> = P & { children?: ReactNode | undefined }; Used to retrieve the props a component accepts. Can either be passed a string, indicating a DOM element (e.g. 'div', 'span', etc.) or the type of a React component. * It's usually better to use {@link ComponentPropsWithRef} or {@link ComponentPropsWithoutRef} instead of this type, as they let you be explicit about whether or not to include the `ref` prop. * @see {@link https://react-typescript-cheatsheet.netlify.app/docs/react-types/componentprops/ React TypeScript Cheatsheet} * @example * ```tsx // Retrieves the props an 'input' element accepts type InputProps = React.ComponentProps<'input'>; ``` * @example * ```tsx const MyComponent = (props: { foo: number, bar: string }) => <div />; * // Retrieves the props 'MyComponent' accepts type MyComponentProps = React.ComponentProps<typeof MyComponent>; ``` type ComponentProps<T extends keyof JSX.IntrinsicElements | JSXElementConstructor<any>> = T extends JSXElementConstructor<infer Props> ? Props : T extends keyof JSX.IntrinsicElements ? JSX.IntrinsicElements[T] : {}; Used to retrieve the props a component accepts with its ref. Can either be passed a string, indicating a DOM element (e.g. 'div', 'span', etc.) or the type of a React component. * @see {@link https://react-typescript-cheatsheet.netlify.app/docs/react-types/componentprops/ React TypeScript Cheatsheet} * @example * ```tsx // Retrieves the props an 'input' element accepts type InputProps = React.ComponentPropsWithRef<'input'>; ``` * @example * ```tsx const MyComponent = (props: { foo: number, bar: string }) => <div />; * // Retrieves the props 'MyComponent' accepts type MyComponentPropsWithRef = React.ComponentPropsWithRef<typeof MyComponent>; ``` type ComponentPropsWithRef<T extends ElementType> = T extends JSXElementConstructor<infer Props> // If it's a class i.e. newable we're dealing with a class component ? T extends abstract new(args: any) => any ? PropsWithoutRef<Props> & RefAttributes<InstanceType<T>> : Props : ComponentProps<T>; Used to retrieve the props a custom component accepts with its ref. * Unlike {@link ComponentPropsWithRef}, this only works with custom components, i.e. components you define yourself. This is to improve type-checking performance. * @example * ```tsx const MyComponent = (props: { foo: number, bar: string }) => <div />; * // Retrieves the props 'MyComponent' accepts type MyComponentPropsWithRef = React.CustomComponentPropsWithRef<typeof MyComponent>; ``` type CustomComponentPropsWithRef<T extends ComponentType> = T extends JSXElementConstructor<infer Props> // If it's a class i.e. newable we're dealing with a class component ? T extends abstract new(args: any) => any ? PropsWithoutRef<Props> & RefAttributes<InstanceType<T>> : Props : never; Used to retrieve the props a component accepts without its ref. Can either be passed a string, indicating a DOM element (e.g. 'div', 'span', etc.) or the type of a React component. * @see {@link https://react-typescript-cheatsheet.netlify.app/docs/react-types/componentprops/ React TypeScript Cheatsheet} * @example * ```tsx // Retrieves the props an 'input' element accepts type InputProps = React.ComponentPropsWithoutRef<'input'>; ``` * @example * ```tsx const MyComponent = (props: { foo: number, bar: string }) => <div />; * // Retrieves the props 'MyComponent' accepts type MyComponentPropsWithoutRef = React.ComponentPropsWithoutRef<typeof MyComponent>; ``` type ComponentPropsWithoutRef<T extends ElementType> = PropsWithoutRef<ComponentProps<T>>; Retrieves the type of the 'ref' prop for a given component type or tag name. * @template C The component type. * @example * ```tsx type MyComponentRef = React.ComponentRef<typeof MyComponent>; ``` * @example * ```tsx type DivRef = React.ComponentRef<'div'>; ``` type ComponentRef<T extends ElementType> = ComponentPropsWithRef<T> extends RefAttributes<infer Method> ? Method : never; // will show `Memo(${Component.displayName || Component.name})` in devtools by default, // but can be given its own specific name type MemoExoticComponent<T extends ComponentType<any>> = NamedExoticComponent<CustomComponentPropsWithRef<T>> & { readonly type: T; }; Lets you skip re-rendering a component when its props are unchanged. * @see {@link https://react.dev/reference/react/memo React Docs} * @param Component The component to memoize. @param propsAreEqual A function that will be used to determine if the props have changed. * @example * ```tsx import { memo } from 'react'; * const SomeComponent = memo(function SomeComponent(props: { foo: string }) { // ... }); ``` function memo<P extends object>( Component: FunctionComponent<P>, propsAreEqual?: (prevProps: Readonly<P>, nextProps: Readonly<P>) => boolean, ): NamedExoticComponent<P>; function memo<T extends ComponentType<any>>( Component: T, propsAreEqual?: (prevProps: Readonly<ComponentProps<T>>, nextProps: Readonly<ComponentProps<T>>) => boolean, ): MemoExoticComponent<T>; interface LazyExoticComponent<T extends ComponentType<any>> extends ExoticComponent<CustomComponentPropsWithRef<T>> { readonly _result: T; } Lets you defer loading a component’s code until it is rendered for the first time. * @see {@link https://react.dev/reference/react/lazy React Docs} * @param load A function that returns a `Promise` or another thenable (a `Promise`-like object with a then method). React will not call `load` until the first time you attempt to render the returned component. After React first calls load, it will wait for it to resolve, and then render the resolved value’s `.default` as a React component. Both the returned `Promise` and the `Promise`’s resolved value will be cached, so React will not call load more than once. If the `Promise` rejects, React will throw the rejection reason for the nearest Error Boundary to handle. * @example * ```tsx import { lazy } from 'react'; * const MarkdownPreview = lazy(() => import('./MarkdownPreview.js')); ``` function lazy<T extends ComponentType<any>>( load: () => Promise<{ default: T }>, ): LazyExoticComponent<T>; // // React Hooks // ---------------------------------------------------------------------- The instruction passed to a {@link Dispatch} function in {@link useState} to tell React what the next value of the {@link useState} should be. * Often found wrapped in {@link Dispatch}. * @template S The type of the state. * @example * ```tsx // This return type correctly represents the type of // `setCount` in the example below. const useCustomState = (): Dispatch<SetStateAction<number>> => { const [count, setCount] = useState(0); * return setCount; } ``` type SetStateAction<S> = S | ((prevState: S) => S); A function that can be used to update the state of a {@link useState} or {@link useReducer} hook. type Dispatch<A> = (value: A) => void; A {@link Dispatch} function can sometimes be called without any arguments. type DispatchWithoutAction = () => void; // Limit the reducer to accept only 0 or 1 action arguments // eslint-disable-next-line @definitelytyped/no-single-element-tuple-type type AnyActionArg = [] | [any]; // Get the dispatch type from the reducer arguments (captures optional action argument correctly) type ActionDispatch<ActionArg extends AnyActionArg> = (...args: ActionArg) => void; // Unlike redux, the actions _can_ be anything type Reducer<S, A> = (prevState: S, action: A) => S; // If useReducer accepts a reducer without action, dispatch may be called without any parameters. type ReducerWithoutAction<S> = (prevState: S) => S; // types used to try and prevent the compiler from reducing S // to a supertype common with the second argument to useReducer() type ReducerState<R extends Reducer<any, any>> = R extends Reducer<infer S, any> ? S : never; type DependencyList = readonly unknown[]; // NOTE: callbacks are _only_ allowed to return either void, or a destructor. type EffectCallback = () => void | Destructor; @deprecated Use `RefObject` instead. interface MutableRefObject<T> { current: T; } // This will technically work if you give a Consumer<T> or Provider<T> but it's deprecated and warns Accepts a context object (the value returned from `React.createContext`) and returns the current context value, as given by the nearest context provider for the given context. * @version 16.8.0 @see {@link https://react.dev/reference/react/useContext} function useContext<T>(context: Context<T> /*, (not public API) observedBits?: number|boolean ): T; Returns a stateful value, and a function to update it. * @version 16.8.0 @see {@link https://react.dev/reference/react/useState} function useState<S>(initialState: S | (() => S)): [S, Dispatch<SetStateAction<S>>]; // convenience overload when first argument is omitted Returns a stateful value, and a function to update it. * @version 16.8.0 @see {@link https://react.dev/reference/react/useState} function useState<S = undefined>(): [S | undefined, Dispatch<SetStateAction<S | undefined>>]; An alternative to `useState`. * `useReducer` is usually preferable to `useState` when you have complex state logic that involves multiple sub-values. It also lets you optimize performance for components that trigger deep updates because you can pass `dispatch` down instead of callbacks. * @version 16.8.0 @see {@link https://react.dev/reference/react/useReducer} function useReducer<S, A extends AnyActionArg>( reducer: (prevState: S, ...args: A) => S, initialState: S, ): [S, ActionDispatch<A>]; An alternative to `useState`. * `useReducer` is usually preferable to `useState` when you have complex state logic that involves multiple sub-values. It also lets you optimize performance for components that trigger deep updates because you can pass `dispatch` down instead of callbacks. * @version 16.8.0 @see {@link https://react.dev/reference/react/useReducer} function useReducer<S, A extends AnyActionArg>( reducer: (prevState: S, ...args: A) => S, initialState: S, ): [S, ActionDispatch<A>]; An alternative to `useState`. * `useReducer` is usually preferable to `useState` when you have complex state logic that involves multiple sub-values. It also lets you optimize performance for components that trigger deep updates because you can pass `dispatch` down instead of callbacks. * @version 16.8.0 @see {@link https://react.dev/reference/react/useReducer} function useReducer<S, I, A extends AnyActionArg>( reducer: (prevState: S, ...args: A) => S, initialArg: I, init: (i: I) => S, ): [S, ActionDispatch<A>]; `useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument (`initialValue`). The returned object will persist for the full lifetime of the component. * Note that `useRef()` is useful for more than the `ref` attribute. It’s handy for keeping any mutable value around similar to how you’d use instance fields in classes. * @version 16.8.0 @see {@link https://react.dev/reference/react/useRef} function useRef<T>(initialValue: T): RefObject<T>; // convenience overload for refs given as a ref prop as they typically start with a null value `useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument (`initialValue`). The returned object will persist for the full lifetime of the component. * Note that `useRef()` is useful for more than the `ref` attribute. It’s handy for keeping any mutable value around similar to how you’d use instance fields in classes. * @version 16.8.0 @see {@link https://react.dev/reference/react/useRef} function useRef<T>(initialValue: T | null): RefObject<T | null>; // convenience overload for undefined initialValue `useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument (`initialValue`). The returned object will persist for the full lifetime of the component. * Note that `useRef()` is useful for more than the `ref` attribute. It’s handy for keeping any mutable value around similar to how you’d use instance fields in classes. * @version 16.8.0 @see {@link https://react.dev/reference/react/useRef} function useRef<T>(initialValue: T | undefined): RefObject<T | undefined>; The signature is identical to `useEffect`, but it fires synchronously after all DOM mutations. Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside `useLayoutEffect` will be flushed synchronously, before the browser has a chance to paint. * Prefer the standard `useEffect` when possible to avoid blocking visual updates. * If you’re migrating code from a class component, `useLayoutEffect` fires in the same phase as `componentDidMount` and `componentDidUpdate`. * @version 16.8.0 @see {@link https://react.dev/reference/react/useLayoutEffect} function useLayoutEffect(effect: EffectCallback, deps?: DependencyList): void; Accepts a function that contains imperative, possibly effectful code. * @param effect Imperative function that can return a cleanup function @param deps If present, effect will only activate if the values in the list change. * @version 16.8.0 @see {@link https://react.dev/reference/react/useEffect} function useEffect(effect: EffectCallback, deps?: DependencyList): void; // NOTE: this does not accept strings, but this will have to be fixed by removing strings from type Ref<T> `useImperativeHandle` customizes the instance value that is exposed to parent components when using `ref`. As always, imperative code using refs should be avoided in most cases. * `useImperativeHandle` should be used with `React.forwardRef`. * @version 16.8.0 @see {@link https://react.dev/reference/react/useImperativeHandle} function useImperativeHandle<T, R extends T>(ref: Ref<T> | undefined, init: () => R, deps?: DependencyList): void; // I made 'inputs' required here and in useMemo as there's no point to memoizing without the memoization key // useCallback(X) is identical to just using X, useMemo(() => Y) is identical to just using Y. `useCallback` will return a memoized version of the callback that only changes if one of the `inputs` has changed. * @version 16.8.0 @see {@link https://react.dev/reference/react/useCallback} // A specific function type would not trigger implicit any. // See https://github.com/DefinitelyTyped/DefinitelyTyped/issues/52873#issuecomment-845806435 for a comparison between `Function` and more specific types. // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type function useCallback<T extends Function>(callback: T, deps: DependencyList): T; `useMemo` will only recompute the memoized value when one of the `deps` has changed. * @version 16.8.0 @see {@link https://react.dev/reference/react/useMemo} // allow undefined, but don't make it optional as that is very likely a mistake function useMemo<T>(factory: () => T, deps: DependencyList): T; `useDebugValue` can be used to display a label for custom hooks in React DevTools. * NOTE: We don’t recommend adding debug values to every custom hook. It’s most valuable for custom hooks that are part of shared libraries. * @version 16.8.0 @see {@link https://react.dev/reference/react/useDebugValue} // the name of the custom hook is itself derived from the function name at runtime: // it's just the function name without the \"use\" prefix. function useDebugValue<T>(value: T, format?: (value: T) => any): void; export type TransitionFunction = () => VoidOrUndefinedOnly | Promise<VoidOrUndefinedOnly>; // strange definition to allow vscode to show documentation on the invocation export interface TransitionStartFunction { State updates caused inside the callback are allowed to be deferred. * **If some state update causes a component to suspend, that state update should be wrapped in a transition.** * @param callback A function which causes state updates that can be deferred. (callback: TransitionFunction): void; } Returns a deferred version of the value that may “lag behind” it. * This is commonly used to keep the interface responsive when you have something that renders immediately based on user input and something that needs to wait for a data fetch. * A good example of this is a text input. * @param value The value that is going to be deferred @param initialValue A value to use during the initial render of a component. If this option is omitted, `useDeferredValue` will not defer during the initial render, because there’s no previous version of `value` that it can render instead. * @see {@link https://react.dev/reference/react/useDeferredValue}",
    "description": "Added new function useDeferredValue",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nUsed to represent DOM API's where users can either pass\ntrue or false as a boolean or as its equivalent strings.\n \ntype Booleanish = boolean | \"true\" | \"false\";\n@see {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/crossorigin MDN}\n \ntype CrossOrigin = \"anonymous\" | \"use-credentials\" | \"\" | undefined;\n\ndeclare const UNDEFINED_VOID_ONLY: unique symbol;\n@internal Use `Awaited<ReactNode>` instead\n \n// Helper type to enable `Awaited<ReactNode>`.\n// Must be a copy of the non-thenables of `ReactNode`.\ntype AwaitedReactNode =\n    | React.ReactElement\n    | string\n    | number\n    | bigint\n    | Iterable<React.ReactNode>\n    | React.ReactPortal\n    | boolean\n    | null\n    | undefined\n    | React.DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES[\n        keyof React.DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES\n    ];\nThe function returned from an effect passed to {@link React.useEffect useEffect},\nwhich can be used to clean up the effect when the component unmounts.\n* @see {@link https://react.dev/reference/react/useEffect React Docs}\n \ntype Destructor = () => void | { [UNDEFINED_VOID_ONLY]: never };\ntype VoidOrUndefinedOnly = void | { [UNDEFINED_VOID_ONLY]: never };\n\n// eslint-disable-next-line @definitelytyped/export-just-namespace\nexport = React;\nexport as namespace React;\n\ndeclare namespace React {\n    //\n    // React Elements\n    // ----------------------------------------------------------------------\nUsed to retrieve the possible components which accept a given set of props.\n* Can be passed no type parameters to get a union of all possible components\nand tags.\n* Is a superset of {@link ComponentType}.\n* @template P The props to match against. If not passed, defaults to any.\n@template Tag An optional tag to match against. If not passed, attempts to match against all possible tags.\n* @example\n* ```tsx\n// All components and tags (img, embed etc.)\n// which accept `src`\ntype SrcComponents = ElementType<{ src: any }>;\n```\n* @example\n* ```tsx\n// All components\ntype AllComponents = ElementType;\n```\n* @example\n* ```tsx\n// All custom components which match `src`, and tags which\n// match `src`, narrowed down to just `audio` and `embed`\ntype SrcComponents = ElementType<{ src: any }, 'audio' | 'embed'>;\n```\n     \n    type ElementType<P = any, Tag extends keyof JSX.IntrinsicElements = keyof JSX.IntrinsicElements> =\n        | { [K in Tag]: P extends JSX.IntrinsicElements[K] ? K : never }[Tag]\n        | ComponentType<P>;\nRepresents any user-defined component, either as a function or a class.\n* Similar to {@link JSXElementConstructor}, but with extra properties like\n{@link FunctionComponent.defaultProps defaultProps }.\n* @template P The props the component accepts.\n* @see {@link ComponentClass}\n@see {@link FunctionComponent}\n     \n    type ComponentType<P = {}> = ComponentClass<P> | FunctionComponent<P>;\nRepresents any user-defined component, either as a function or a class.\n* Similar to {@link ComponentType}, but without extra properties like\n{@link FunctionComponent.defaultProps defaultProps }.\n* @template P The props the component accepts.\n     \n    type JSXElementConstructor<P> =\n        | ((\n            props: P,\n        ) => ReactNode | Promise<ReactNode>)\n        // constructor signature must match React.Component\n        | (new(props: P) => Component<any, any>);\nCreated by {@link createRef}, or {@link useRef} when passed `null`.\n* @template T The type of the ref's value.\n* @example\n* ```tsx\nconst ref = createRef<HTMLDivElement>();\n* ref.current = document.createElement('div'); // Error\n```\n     \n    interface RefObject<T> {\nThe current value of the ref.\n         \n        current: T;\n    }\n\n    interface DO_NOT_USE_OR_YOU_WILL_BE_FIRED_CALLBACK_REF_RETURN_VALUES {\n    }\nA callback fired whenever the ref's value changes.\n* @template T The type of the ref's value.\n* @see {@link https://react.dev/reference/react-dom/components/common#ref-callback React Docs}\n* @example\n* ```tsx\n<div ref={(node) => console.log(node)} />\n```\n     \n    type RefCallback<T> = {\n        bivarianceHack(\n            instance: T | null,\n        ):\n            | void\n            | (() => VoidOrUndefinedOnly)\n            | DO_NOT_USE_OR_YOU_WILL_BE_FIRED_CALLBACK_REF_RETURN_VALUES[\n                keyof DO_NOT_USE_OR_YOU_WILL_BE_FIRED_CALLBACK_REF_RETURN_VALUES\n            ];\n    }[\"bivarianceHack\"];\nA union type of all possible shapes for React refs.\n* @see {@link RefCallback}\n@see {@link RefObject}\n     \n\n    type Ref<T> = RefCallback<T> | RefObject<T | null> | null;\n@deprecated Use `Ref` instead. String refs are no longer supported.\nIf you're typing a library with support for React versions with string refs, use `RefAttributes<T>['ref']` instead.\n     \n    type LegacyRef<T> = Ref<T>;\n@deprecated Use `ComponentRef<T>` instead\n* Retrieves the type of the 'ref' prop for a given component type or tag name.\n* @template C The component type.\n* @example\n* ```tsx\ntype MyComponentRef = React.ElementRef<typeof MyComponent>;\n```\n* @example\n* ```tsx\ntype DivRef = React.ElementRef<'div'>;\n```\n     \n    type ElementRef<\n        C extends\n            | ForwardRefExoticComponent<any>\n            | { new(props: any): Component<any> }\n            | ((props: any) => ReactNode)\n            | keyof JSX.IntrinsicElements,\n    > = ComponentRef<C>;\n\n    type ComponentState = any;\nA value which uniquely identifies a node among items in an array.\n* @see {@link https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key React Docs}\n     \n    type Key = string | number | bigint;\n@internal The props any component can receive.\nYou don't have to add this type. All components automatically accept these props.\n```tsx\nconst Component = () => <div />;\n<Component key=\"one\" />\n```\n* WARNING: The implementation of a component will never have access to these attributes.\nThe following example would be incorrect usage because {@link Component} would never have access to `key`:\n```tsx\nconst Component = (props: React.Attributes) => props.key;\n```\n     \n    interface Attributes {\n        key?: Key | null | undefined;\n    }\nThe props any component accepting refs can receive.\nClass components, built-in browser components (e.g. `div`) and forwardRef components can receive refs and automatically accept these props.\n```tsx\nconst Component = forwardRef(() => <div />);\n<Component ref={(current) => console.log(current)} />\n```\n* You only need this type if you manually author the types of props that need to be compatible with legacy refs.\n```tsx\ninterface Props extends React.RefAttributes<HTMLDivElement> {}\ndeclare const Component: React.FunctionComponent<Props>;\n```\n* Otherwise it's simpler to directly use {@link Ref} since you can safely use the\nprops type to describe to props that a consumer can pass to the component\nas well as describing the props the implementation of a component \"sees\".\n{@link RefAttributes} is generally not safe to describe both consumer and seen props.\n* ```tsx\ninterface Props extends {\nref?: React.Ref<HTMLDivElement> | undefined;\n}\ndeclare const Component: React.FunctionComponent<Props>;\n```\n* WARNING: The implementation of a component will not have access to the same type in versions of React supporting string refs.\nThe following example would be incorrect usage because {@link Component} would never have access to a `ref` with type `string`\n```tsx\nconst Component = (props: React.RefAttributes) => props.ref;\n```\n     \n    interface RefAttributes<T> extends Attributes {\nAllows getting a ref to the component instance.\nOnce the component unmounts, React will set `ref.current` to `null`\n(or call the ref with `null` if you passed a callback ref).\n* @see {@link https://react.dev/learn/referencing-values-with-refs#refs-and-the-dom React Docs}\n         \n        ref?: Ref<T> | undefined;\n    }\nRepresents the built-in attributes available to class components.\n     \n    interface ClassAttributes<T> extends RefAttributes<T> {\n    }\nRepresents a JSX element.\n* Where {@link ReactNode} represents everything that can be rendered, `ReactElement`\nonly represents JSX.\n* @template P The type of the props object\n@template T The type of the component or tag\n* @example\n* ```tsx\nconst element: ReactElement = <div />;\n```\n     \n    interface ReactElement<\n        P = unknown,\n        T extends string | JSXElementConstructor<any> = string | JSXElementConstructor<any>,\n    > {\n        type: T;\n        props: P;\n        key: string | null;\n    }\n@deprecated\n     \n    interface ReactComponentElement<\n        T extends keyof JSX.IntrinsicElements | JSXElementConstructor<any>,\n        P = Pick<ComponentProps<T>, Exclude<keyof ComponentProps<T>, \"key\" | \"ref\">>,\n    > extends ReactElement<P, Exclude<T, number>> {}\n@deprecated Use `ReactElement<P, React.FunctionComponent<P>>`\n     \n    interface FunctionComponentElement<P> extends ReactElement<P, FunctionComponent<P>> {\n@deprecated Use `element.props.ref` instead.\n         \n        ref?: (\"ref\" extends keyof P ? P extends { ref?: infer R | undefined } ? R : never : never) | undefined;\n    }\n@deprecated Use `ReactElement<P, React.ComponentClass<P>>`\n     \n    type CElement<P, T extends Component<P, ComponentState>> = ComponentElement<P, T>;\n@deprecated Use `ReactElement<P, React.ComponentClass<P>>`\n     \n    interface ComponentElement<P, T extends Component<P, ComponentState>> extends ReactElement<P, ComponentClass<P>> {\n@deprecated Use `element.props.ref` instead.\n         \n        ref?: Ref<T> | undefined;\n    }\n@deprecated Use {@link ComponentElement} instead.\n     \n    type ClassicElement<P> = CElement<P, ClassicComponent<P, ComponentState>>;\n\n    // string fallback for custom web-components\n@deprecated Use `ReactElement<P, string>`\n     \n    interface DOMElement<P extends HTMLAttributes<T> | SVGAttributes<T>, T extends Element>\n        extends ReactElement<P, string>\n    {\n@deprecated Use `element.props.ref` instead.\n         \n        ref: Ref<T>;\n    }\n\n    // ReactHTML for ReactHTMLElement\n    interface ReactHTMLElement<T extends HTMLElement> extends DetailedReactHTMLElement<AllHTMLAttributes<T>, T> {}\n\n    interface DetailedReactHTMLElement<P extends HTMLAttributes<T>, T extends HTMLElement> extends DOMElement<P, T> {\n        type: HTMLElementType;\n    }\n\n    // ReactSVG for ReactSVGElement\n    interface ReactSVGElement extends DOMElement<SVGAttributes<SVGElement>, SVGElement> {\n        type: SVGElementType;\n    }\n\n    interface ReactPortal extends ReactElement {\n        children: ReactNode;\n    }\nDifferent release channels declare additional types of ReactNode this particular release channel accepts.\nApp or library types should never augment this interface.\n     \n    interface DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES {}\nRepresents all of the things React can render.\n* Where {@link ReactElement} only represents JSX, `ReactNode` represents everything that can be rendered.\n* @see {@link https://react-typescript-cheatsheet.netlify.app/docs/react-types/reactnode/ React TypeScript Cheatsheet}\n* @example\n* ```tsx\n// Typing children\ntype Props = { children: ReactNode }\n* const Component = ({ children }: Props) => <div>{children}</div>\n* <Component>hello</Component>\n```\n* @example\n* ```tsx\n// Typing a custom element\ntype Props = { customElement: ReactNode }\n* const Component = ({ customElement }: Props) => <div>{customElement}</div>\n* <Component customElement={<div>hello</div>} />\n```\n     \n    // non-thenables need to be kept in sync with AwaitedReactNode\n    type ReactNode =\n        | ReactElement\n        | string\n        | number\n        | bigint\n        | Iterable<ReactNode>\n        | ReactPortal\n        | boolean\n        | null\n        | undefined\n        | DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES[\n            keyof DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES\n        ]\n        | Promise<AwaitedReactNode>;\n\n    //\n    // Top Level API\n    // ----------------------------------------------------------------------\n\n    // DOM Elements\n    // TODO: generalize this to everything in `keyof ReactHTML`, not just \"input\"\n    function createElement(\n        type: \"input\",\n        props?: InputHTMLAttributes<HTMLInputElement> & ClassAttributes<HTMLInputElement> | null,\n        ...children: ReactNode[]\n    ): DetailedReactHTMLElement<InputHTMLAttributes<HTMLInputElement>, HTMLInputElement>;\n    function createElement<P extends HTMLAttributes<T>, T extends HTMLElement>(\n        type: HTMLElementType,\n        props?: ClassAttributes<T> & P | null,\n        ...children: ReactNode[]\n    ): DetailedReactHTMLElement<P, T>;\n    function createElement<P extends SVGAttributes<T>, T extends SVGElement>(\n        type: SVGElementType,\n        props?: ClassAttributes<T> & P | null,\n        ...children: ReactNode[]\n    ): ReactSVGElement;\n    function createElement<P extends DOMAttributes<T>, T extends Element>(\n        type: string,\n        props?: ClassAttributes<T> & P | null,\n        ...children: ReactNode[]\n    ): DOMElement<P, T>;\n\n    // Custom components\n\n    function createElement<P extends {}>(\n        type: FunctionComponent<P>,\n        props?: Attributes & P | null,\n        ...children: ReactNode[]\n    ): FunctionComponentElement<P>;\n    function createElement<P extends {}, T extends Component<P, ComponentState>, C extends ComponentClass<P>>(\n        type: ClassType<P, T, C>,\n        props?: ClassAttributes<T> & P | null,\n        ...children: ReactNode[]\n    ): CElement<P, T>;\n    function createElement<P extends {}>(\n        type: FunctionComponent<P> | ComponentClass<P> | string,\n        props?: Attributes & P | null,\n        ...children: ReactNode[]\n    ): ReactElement<P>;\n\n    // DOM Elements\n    // ReactHTMLElement\n    function cloneElement<P extends HTMLAttributes<T>, T extends HTMLElement>(\n        element: DetailedReactHTMLElement<P, T>,\n        props?: P,\n        ...children: ReactNode[]\n    ): DetailedReactHTMLElement<P, T>;\n    // ReactHTMLElement, less specific\n    function cloneElement<P extends HTMLAttributes<T>, T extends HTMLElement>(\n        element: ReactHTMLElement<T>,\n        props?: P,\n        ...children: ReactNode[]\n    ): ReactHTMLElement<T>;\n    // SVGElement\n    function cloneElement<P extends SVGAttributes<T>, T extends SVGElement>(\n        element: ReactSVGElement,\n        props?: P,\n        ...children: ReactNode[]\n    ): ReactSVGElement;\n    // DOM Element (has to be the last, because type checking stops at first overload that fits)\n    function cloneElement<P extends DOMAttributes<T>, T extends Element>(\n        element: DOMElement<P, T>,\n        props?: DOMAttributes<T> & P,\n        ...children: ReactNode[]\n    ): DOMElement<P, T>;\n\n    // Custom components\n    function cloneElement<P>(\n        element: FunctionComponentElement<P>,\n        props?: Partial<P> & Attributes,\n        ...children: ReactNode[]\n    ): FunctionComponentElement<P>;\n    function cloneElement<P, T extends Component<P, ComponentState>>(\n        element: CElement<P, T>,\n        props?: Partial<P> & ClassAttributes<T>,\n        ...children: ReactNode[]\n    ): CElement<P, T>;\n    function cloneElement<P>(\n        element: ReactElement<P>,\n        props?: Partial<P> & Attributes,\n        ...children: ReactNode[]\n    ): ReactElement<P>;\nDescribes the props accepted by a Context {@link Provider}.\n* @template T The type of the value the context provides.\n     \n    interface ProviderProps<T> {\n        value: T;\n        children?: ReactNode | undefined;\n    }\nDescribes the props accepted by a Context {@link Consumer}.\n* @template T The type of the value the context provides.\n     \n    interface ConsumerProps<T> {\n        children: (value: T) => ReactNode;\n    }\nAn object masquerading as a component. These are created by functions\nlike {@link forwardRef}, {@link memo}, and {@link createContext}.\n* In order to make TypeScript work, we pretend that they are normal\ncomponents.\n* But they are, in fact, not callable - instead, they are objects which\nare treated specially by the renderer.\n* @template P The props the component accepts.\n     \n    interface ExoticComponent<P = {}> {\n        (props: P): ReactNode;\n        readonly $$typeof: symbol;\n    }\nAn {@link ExoticComponent} with a `displayName` property applied to it.\n* @template P The props the component accepts.\n     \n    interface NamedExoticComponent<P = {}> extends ExoticComponent<P> {\nUsed in debugging messages. You might want to set it\nexplicitly if you want to display a different name for\ndebugging purposes.\n* @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs}\n         \n        displayName?: string | undefined;\n    }\nAn {@link ExoticComponent} with a `propTypes` property applied to it.\n* @template P The props the component accepts.\n     \n    interface ProviderExoticComponent<P> extends ExoticComponent<P> {\n    }\nUsed to retrieve the type of a context object from a {@link Context}.\n* @template C The context object.\n* @example\n* ```tsx\nimport { createContext } from 'react';\n* const MyContext = createContext({ foo: 'bar' });\n* type ContextType = ContextType<typeof MyContext>;\n// ContextType = { foo: string }\n```\n     \n    type ContextType<C extends Context<any>> = C extends Context<infer T> ? T : never;\nWraps your components to specify the value of this context for all components inside.\n* @see {@link https://react.dev/reference/react/createContext#provider React Docs}\n* @example\n* ```tsx\nimport { createContext } from 'react';\n* const ThemeContext = createContext('light');\n* function App() {\nreturn (\n<ThemeContext.Provider value=\"dark\">\n<Toolbar />\n</ThemeContext.Provider>\n);\n}\n```\n     \n    type Provider<T> = ProviderExoticComponent<ProviderProps<T>>;\nThe old way to read context, before {@link useContext} existed.\n* @see {@link https://react.dev/reference/react/createContext#consumer React Docs}\n* @example\n* ```tsx\nimport { UserContext } from './user-context';\n* function Avatar() {\nreturn (\n<UserContext.Consumer>\n{user => <img src={user.profileImage} alt={user.name} />}\n</UserContext.Consumer>\n);\n}\n```\n     \n    type Consumer<T> = ExoticComponent<ConsumerProps<T>>;\nContext lets components pass information deep down without explicitly\npassing props.\n* Created from {@link createContext}\n* @see {@link https://react.dev/learn/passing-data-deeply-with-context React Docs}\n@see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/context/ React TypeScript Cheatsheet}\n* @example\n* ```tsx\nimport { createContext } from 'react';\n* const ThemeContext = createContext('light');\n```\n     \n    interface Context<T> extends Provider<T> {\n        Provider: Provider<T>;\n        Consumer: Consumer<T>;\nUsed in debugging messages. You might want to set it\nexplicitly if you want to display a different name for\ndebugging purposes.\n* @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs}\n         \n        displayName?: string | undefined;\n    }\nLets you create a {@link Context} that components can provide or read.\n* @param defaultValue The value you want the context to have when there is no matching\n{@link Provider} in the tree above the component reading the context. This is meant\nas a \"last resort\" fallback.\n* @see {@link https://react.dev/reference/react/createContext#reference React Docs}\n@see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/context/ React TypeScript Cheatsheet}\n* @example\n* ```tsx\nimport { createContext } from 'react';\n* const ThemeContext = createContext('light');\nfunction App() {\nreturn (\n<ThemeContext value=\"dark\">\n<Toolbar />\n</ThemeContext>\n);\n}\n```\n     \n    function createContext<T>(\n        // If you thought this should be optional, see\n        // https://github.com/DefinitelyTyped/DefinitelyTyped/pull/24509#issuecomment-382213106\n        defaultValue: T,\n    ): Context<T>;\n\n    function isValidElement<P>(object: {} | null | undefined): object is ReactElement<P>;\n\n    const Children: {\n        map<T, C>(\n            children: C | readonly C[],\n            fn: (child: C, index: number) => T,\n        ): C extends null | undefined ? C : Array<Exclude<T, boolean | null | undefined>>;\n        forEach<C>(children: C | readonly C[], fn: (child: C, index: number) => void): void;\n        count(children: any): number;\n        only<C>(children: C): C extends any[] ? never : C;\n        toArray(children: ReactNode | ReactNode[]): Array<Exclude<ReactNode, boolean | null | undefined>>;\n    };\n\n    export interface FragmentProps {\n        children?: React.ReactNode;\n    }\nLets you group elements without a wrapper node.\n* @see {@link https://react.dev/reference/react/Fragment React Docs}\n* @example\n* ```tsx\nimport { Fragment } from 'react';\n* <Fragment>\n<td>Hello</td>\n<td>World</td>\n</Fragment>\n```\n* @example\n* ```tsx\n// Using the <></> shorthand syntax:\n* <>\n<td>Hello</td>\n<td>World</td>\n</>\n```\n     \n    const Fragment: ExoticComponent<FragmentProps>;\nLets you find common bugs in your components early during development.\n* @see {@link https://react.dev/reference/react/StrictMode React Docs}\n* @example\n* ```tsx\nimport { StrictMode } from 'react';\n* <StrictMode>\n<App />\n</StrictMode>\n```\n     \n    const StrictMode: ExoticComponent<{ children?: ReactNode | undefined }>;\nThe props accepted by {@link Suspense}.\n* @see {@link https://react.dev/reference/react/Suspense React Docs}\n     \n    interface SuspenseProps {\n        children?: ReactNode | undefined;\n\n         A fallback react tree to show when a Suspense child (like React.lazy) suspends \n        fallback?: ReactNode;\nA name for this Suspense boundary for instrumentation purposes.\nThe name will help identify this boundary in React DevTools.\n         \n        name?: string | undefined;\n    }\nLets you display a fallback until its children have finished loading.\n* @see {@link https://react.dev/reference/react/Suspense React Docs}\n* @example\n* ```tsx\nimport { Suspense } from 'react';\n* <Suspense fallback={<Loading />}>\n<ProfileDetails />\n</Suspense>\n```\n     \n    const Suspense: ExoticComponent<SuspenseProps>;\n    const version: string;\nThe callback passed to {@link ProfilerProps.onRender}.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n     \n    type ProfilerOnRenderCallback = (\nThe string id prop of the {@link Profiler} tree that has just committed. This lets\nyou identify which part of the tree was committed if you are using multiple\nprofilers.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n         \n        id: string,\nThis lets you know whether the tree has just been mounted for the first time\nor re-rendered due to a change in props, state, or hooks.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n         \n        phase: \"mount\" | \"update\" | \"nested-update\",\nThe number of milliseconds spent rendering the {@link Profiler} and its descendants\nfor the current update. This indicates how well the subtree makes use of\nmemoization (e.g. {@link memo} and {@link useMemo}). Ideally this value should decrease\nsignificantly after the initial mount as many of the descendants will only need to\nre-render if their specific props change.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n         \n        actualDuration: number,\nThe number of milliseconds estimating how much time it would take to re-render the entire\n{@link Profiler} subtree without any optimizations. It is calculated by summing up the most\nrecent render durations of each component in the tree. This value estimates a worst-case\ncost of rendering (e.g. the initial mount or a tree with no memoization). Compare\n{@link actualDuration} against it to see if memoization is working.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n         \n        baseDuration: number,\nA numeric timestamp for when React began rendering the current update.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n         \n        startTime: number,\nA numeric timestamp for when React committed the current update. This value is shared\nbetween all profilers in a commit, enabling them to be grouped if desirable.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n         \n        commitTime: number,\n    ) => void;\nThe props accepted by {@link Profiler}.\n* @see {@link https://react.dev/reference/react/Profiler React Docs}\n     \n    interface ProfilerProps {\n        children?: ReactNode | undefined;\n        id: string;\n        onRender: ProfilerOnRenderCallback;\n    }\nLets you measure rendering performance of a React tree programmatically.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n* @example\n* ```tsx\n<Profiler id=\"App\" onRender={onRender}>\n<App />\n</Profiler>\n```\n     \n    const Profiler: ExoticComponent<ProfilerProps>;\n\n    //\n    // Component API\n    // ----------------------------------------------------------------------\n\n    type ReactInstance = Component<any> | Element;\n\n    // Base component for plain JS classes\n    interface Component<P = {}, S = {}, SS = any> extends ComponentLifecycle<P, S, SS> {}\n    class Component<P, S> {\nIf set, `this.context` will be set at runtime to the current value of the given Context.\n* @example\n* ```ts\ntype MyContext = number\nconst Ctx = React.createContext<MyContext>(0)\n* class Foo extends React.Component {\nstatic contextType = Ctx\ncontext!: React.ContextType<typeof Ctx>\nrender () {\nreturn <>My context's value: {this.context}</>;\n}\n}\n```\n* @see {@link https://react.dev/reference/react/Component#static-contexttype}\n         \n        static contextType?: Context<any> | undefined;\nIgnored by React.\n@deprecated Only kept in types for backwards compatibility. Will be removed in a future major release.\n         \n        static propTypes?: any;\nIf using the new style context, re-declare this in your class to be the\n`React.ContextType` of your `static contextType`.\nShould be used with type annotation or static contextType.\n* @example\n```ts\nstatic contextType = MyContext\n// For TS pre-3.7:\ncontext!: React.ContextType<typeof MyContext>\n// For TS 3.7 and above:\ndeclare context: React.ContextType<typeof MyContext>\n```\n* @see {@link https://react.dev/reference/react/Component#context React Docs}\n         \n        context: unknown;\n\n        // Keep in sync with constructor signature of JSXElementConstructor and ComponentClass.\n        constructor(props: P);\n\n        // We MUST keep setState() as a unified signature because it allows proper checking of the method return type.\n        // See: https://github.com/DefinitelyTyped/DefinitelyTyped/issues/18365#issuecomment-351013257\n        // Also, the ` | S` allows intellisense to not be dumbisense\n        setState<K extends keyof S>(\n            state: ((prevState: Readonly<S>, props: Readonly<P>) => Pick<S, K> | S | null) | (Pick<S, K> | S | null),\n            callback?: () => void,\n        ): void;\n\n        forceUpdate(callback?: () => void): void;\n        render(): ReactNode;\n\n        readonly props: Readonly<P>;\n        state: Readonly<S>;\n    }\n\n    class PureComponent<P = {}, S = {}, SS = any> extends Component<P, S, SS> {}\n@deprecated Use `ClassicComponent` from `create-react-class`\n* @see {@link https://legacy.reactjs.org/docs/react-without-es6.html Legacy React Docs}\n@see {@link https://www.npmjs.com/package/create-react-class `create-react-class` on npm}\n     \n    interface ClassicComponent<P = {}, S = {}> extends Component<P, S> {\n        replaceState(nextState: S, callback?: () => void): void;\n        isMounted(): boolean;\n        getInitialState?(): S;\n    }\n\n    //\n    // Class Interfaces\n    // ----------------------------------------------------------------------\nRepresents the type of a function component. Can optionally\nreceive a type argument that represents the props the component\nreceives.\n* @template P The props the component accepts.\n@see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/function_components React TypeScript Cheatsheet}\n@alias for {@link FunctionComponent}\n* @example\n* ```tsx\n// With props:\ntype Props = { name: string }\n* const MyComponent: FC<Props> = (props) => {\nreturn <div>{props.name}</div>\n}\n```\n* @example\n* ```tsx\n// Without props:\nconst MyComponentWithoutProps: FC = () => {\nreturn <div>MyComponentWithoutProps</div>\n}\n```\n     \n    type FC<P = {}> = FunctionComponent<P>;\nRepresents the type of a function component. Can optionally\nreceive a type argument that represents the props the component\naccepts.\n* @template P The props the component accepts.\n@see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/function_components React TypeScript Cheatsheet}\n* @example\n* ```tsx\n// With props:\ntype Props = { name: string }\n* const MyComponent: FunctionComponent<Props> = (props) => {\nreturn <div>{props.name}</div>\n}\n```\n* @example\n* ```tsx\n// Without props:\nconst MyComponentWithoutProps: FunctionComponent = () => {\nreturn <div>MyComponentWithoutProps</div>\n}\n```\n     \n    interface FunctionComponent<P = {}> {\n        (props: P): ReactNode | Promise<ReactNode>;\nIgnored by React.\n@deprecated Only kept in types for backwards compatibility. Will be removed in a future major release.\n         \n        propTypes?: any;\nUsed in debugging messages. You might want to set it\nexplicitly if you want to display a different name for\ndebugging purposes.\n* @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs}\n* @example\n* ```tsx\n* const MyComponent: FC = () => {\nreturn <div>Hello!</div>\n}\n* MyComponent.displayName = 'MyAwesomeComponent'\n```\n         \n        displayName?: string | undefined;\n    }\nThe type of the ref received by a {@link ForwardRefRenderFunction}.\n* @see {@link ForwardRefRenderFunction}\n     \n    // Making T nullable is assuming the refs will be managed by React or the component impl will write it somewhere else.\n    // But this isn't necessarily true. We haven't heard complains about it yet and hopefully `forwardRef` is removed from React before we do.\n    type ForwardedRef<T> = ((instance: T | null) => void) | RefObject<T | null> | null;\nThe type of the function passed to {@link forwardRef}. This is considered different\nto a normal {@link FunctionComponent} because it receives an additional argument,\n* @param props Props passed to the component, if any.\n@param ref A ref forwarded to the component of type {@link ForwardedRef}.\n* @template T The type of the forwarded ref.\n@template P The type of the props the component accepts.\n* @see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/forward_and_create_ref/ React TypeScript Cheatsheet}\n@see {@link forwardRef}\n     \n    interface ForwardRefRenderFunction<T, P = {}> {\n        (props: P, ref: ForwardedRef<T>): ReactNode;\nUsed in debugging messages. You might want to set it\nexplicitly if you want to display a different name for\ndebugging purposes.\n* Will show `ForwardRef(${Component.displayName || Component.name})`\nin devtools by default, but can be given its own specific name.\n* @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs}\n         \n        displayName?: string | undefined;\nIgnored by React.\n@deprecated Only kept in types for backwards compatibility. Will be removed in a future major release.\n         \n        propTypes?: any;\n    }\nRepresents a component class in React.\n* @template P The props the component accepts.\n@template S The internal state of the component.\n     \n    interface ComponentClass<P = {}, S = ComponentState> extends StaticLifecycle<P, S> {\n        // constructor signature must match React.Component\n        new(props: P): Component<P, S>;\nIgnored by React.\n@deprecated Only kept in types for backwards compatibility. Will be removed in a future major release.\n         \n        propTypes?: any;\n        contextType?: Context<any> | undefined;\n        defaultProps?: Partial<P> | undefined;\nUsed in debugging messages. You might want to set it\nexplicitly if you want to display a different name for\ndebugging purposes.\n* @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs}\n         \n        displayName?: string | undefined;\n    }\n@deprecated Use `ClassicComponentClass` from `create-react-class`\n* @see {@link https://legacy.reactjs.org/docs/react-without-es6.html Legacy React Docs}\n@see {@link https://www.npmjs.com/package/create-react-class `create-react-class` on npm}\n     \n    interface ClassicComponentClass<P = {}> extends ComponentClass<P> {\n        new(props: P): ClassicComponent<P, ComponentState>;\n        getDefaultProps?(): P;\n    }\nUsed in {@link createElement} and {@link createFactory} to represent\na class.\n* An intersection type is used to infer multiple type parameters from\na single argument, which is useful for many top-level API defs.\nSee {@link https://github.com/Microsoft/TypeScript/issues/7234 this GitHub issue}\nfor more info.\n     \n    type ClassType<P, T extends Component<P, ComponentState>, C extends ComponentClass<P>> =\n        & C\n        & (new(props: P) => T);\n\n    //\n    // Component Specs and Lifecycle\n    // ----------------------------------------------------------------------\n\n    // This should actually be something like `Lifecycle<P, S> | DeprecatedLifecycle<P, S>`,\n    // as React will _not_ call the deprecated lifecycle methods if any of the new lifecycle\n    // methods are present.\n    interface ComponentLifecycle<P, S, SS = any> extends NewLifecycle<P, S, SS>, DeprecatedLifecycle<P, S> {\nCalled immediately after a component is mounted. Setting state here will trigger re-rendering.\n         \n        componentDidMount?(): void;\nCalled to determine whether the change in props and state should trigger a re-render.\n* `Component` always returns true.\n`PureComponent` implements a shallow comparison on props and state and returns true if any\nprops or states have changed.\n* If false is returned, {@link Component.render}, `componentWillUpdate`\nand `componentDidUpdate` will not be called.\n         \n        shouldComponentUpdate?(nextProps: Readonly<P>, nextState: Readonly<S>, nextContext: any): boolean;\nCalled immediately before a component is destroyed. Perform any necessary cleanup in this method, such as\ncancelled network requests, or cleaning up any DOM elements created in `componentDidMount`.\n         \n        componentWillUnmount?(): void;\nCatches exceptions generated in descendant components. Unhandled exceptions will cause\nthe entire component tree to unmount.\n         \n        componentDidCatch?(error: Error, errorInfo: ErrorInfo): void;\n    }\n\n    // Unfortunately, we have no way of declaring that the component constructor must implement this\n    interface StaticLifecycle<P, S> {\n        getDerivedStateFromProps?: GetDerivedStateFromProps<P, S> | undefined;\n        getDerivedStateFromError?: GetDerivedStateFromError<P, S> | undefined;\n    }\n\n    type GetDerivedStateFromProps<P, S> =\nReturns an update to a component's state based on its new props and old state.\n* Note: its presence prevents any of the deprecated lifecycle methods from being invoked\n         \n        (nextProps: Readonly<P>, prevState: S) => Partial<S> | null;\n\n    type GetDerivedStateFromError<P, S> =\nThis lifecycle is invoked after an error has been thrown by a descendant component.\nIt receives the error that was thrown as a parameter and should return a value to update state.\n* Note: its presence prevents any of the deprecated lifecycle methods from being invoked\n         \n        (error: any) => Partial<S> | null;\n\n    // This should be \"infer SS\" but can't use it yet\n    interface NewLifecycle<P, S, SS> {\nRuns before React applies the result of {@link Component.render render} to the document, and\nreturns an object to be given to {@link componentDidUpdate}. Useful for saving\nthings such as scroll position before {@link Component.render render} causes changes to it.\n* Note: the presence of this method prevents any of the deprecated\nlifecycle events from running.\n         \n        getSnapshotBeforeUpdate?(prevProps: Readonly<P>, prevState: Readonly<S>): SS | null;\nCalled immediately after updating occurs. Not called for the initial render.\n* The snapshot is only present if {@link getSnapshotBeforeUpdate} is present and returns non-null.\n         \n        componentDidUpdate?(prevProps: Readonly<P>, prevState: Readonly<S>, snapshot?: SS): void;\n    }\n\n    interface DeprecatedLifecycle<P, S> {\nCalled immediately before mounting occurs, and before {@link Component.render}.\nAvoid introducing any side-effects or subscriptions in this method.\n* Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate}\nor {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents\nthis from being invoked.\n* @deprecated 16.3, use {@link ComponentLifecycle.componentDidMount componentDidMount} or the constructor instead; will stop working in React 17\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#initializing-state}\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path}\n         \n        componentWillMount?(): void;\nCalled immediately before mounting occurs, and before {@link Component.render}.\nAvoid introducing any side-effects or subscriptions in this method.\n* This method will not stop working in React 17.\n* Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate}\nor {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents\nthis from being invoked.\n* @deprecated 16.3, use {@link ComponentLifecycle.componentDidMount componentDidMount} or the constructor instead\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#initializing-state}\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path}\n         \n        UNSAFE_componentWillMount?(): void;\nCalled when the component may be receiving new props.\nReact may call this even if props have not changed, so be sure to compare new and existing\nprops if you only want to handle changes.\n* Calling {@link Component.setState} generally does not trigger this method.\n* Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate}\nor {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents\nthis from being invoked.\n* @deprecated 16.3, use static {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} instead; will stop working in React 17\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#updating-state-based-on-props}\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path}\n         \n        componentWillReceiveProps?(nextProps: Readonly<P>, nextContext: any): void;\nCalled when the component may be receiving new props.\nReact may call this even if props have not changed, so be sure to compare new and existing\nprops if you only want to handle changes.\n* Calling {@link Component.setState} generally does not trigger this method.\n* This method will not stop working in React 17.\n* Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate}\nor {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents\nthis from being invoked.\n* @deprecated 16.3, use static {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} instead\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#updating-state-based-on-props}\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path}\n         \n        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<P>, nextContext: any): void;\nCalled immediately before rendering when new props or state is received. Not called for the initial render.\n* Note: You cannot call {@link Component.setState} here.\n* Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate}\nor {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents\nthis from being invoked.\n* @deprecated 16.3, use getSnapshotBeforeUpdate instead; will stop working in React 17\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#reading-dom-properties-before-an-update}\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path}\n         \n        componentWillUpdate?(nextProps: Readonly<P>, nextState: Readonly<S>, nextContext: any): void;\nCalled immediately before rendering when new props or state is received. Not called for the initial render.\n* Note: You cannot call {@link Component.setState} here.\n* This method will not stop working in React 17.\n* Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate}\nor {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents\nthis from being invoked.\n* @deprecated 16.3, use getSnapshotBeforeUpdate instead\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#reading-dom-properties-before-an-update}\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path}\n         \n        UNSAFE_componentWillUpdate?(nextProps: Readonly<P>, nextState: Readonly<S>, nextContext: any): void;\n    }\n\n    function createRef<T>(): RefObject<T | null>;\nThe type of the component returned from {@link forwardRef}.\n* @template P The props the component accepts, if any.\n* @see {@link ExoticComponent}\n     \n    interface ForwardRefExoticComponent<P> extends NamedExoticComponent<P> {\nIgnored by React.\n@deprecated Only kept in types for backwards compatibility. Will be removed in a future major release.\n         \n        propTypes?: any;\n    }\nLets your component expose a DOM node to a parent component\nusing a ref.\n* @see {@link https://react.dev/reference/react/forwardRef React Docs}\n@see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/forward_and_create_ref/ React TypeScript Cheatsheet}\n* @param render See the {@link ForwardRefRenderFunction}.\n* @template T The type of the DOM node.\n@template P The props the component accepts, if any.\n* @example\n* ```tsx\ninterface Props {\nchildren?: ReactNode;\ntype: \"submit\" | \"button\";\n}\n* export const FancyButton = forwardRef<HTMLButtonElement, Props>((props, ref) => (\n<button ref={ref} className=\"MyClassName\" type={props.type}>\n{props.children}\n</button>\n));\n```\n     \n    function forwardRef<T, P = {}>(\n        render: ForwardRefRenderFunction<T, PropsWithoutRef<P>>,\n    ): ForwardRefExoticComponent<PropsWithoutRef<P> & RefAttributes<T>>;\nOmits the 'ref' attribute from the given props object.\n* @template Props The props object type.\n     \n    type PropsWithoutRef<Props> =\n        // Omit would not be sufficient for this. We'd like to avoid unnecessary mapping and need a distributive conditional to support unions.\n        // see: https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types\n        // https://github.com/Microsoft/TypeScript/issues/28339\n        Props extends any ? (\"ref\" extends keyof Props ? Omit<Props, \"ref\"> : Props) : Props;\nEnsures that the props do not include string ref, which cannot be forwarded\n@deprecated Use `Props` directly. `PropsWithRef<Props>` is just an alias for `Props`\n     \n    type PropsWithRef<Props> = Props;\n\n    type PropsWithChildren<P = unknown> = P & { children?: ReactNode | undefined };\nUsed to retrieve the props a component accepts. Can either be passed a string,\nindicating a DOM element (e.g. 'div', 'span', etc.) or the type of a React\ncomponent.\n* It's usually better to use {@link ComponentPropsWithRef} or {@link ComponentPropsWithoutRef}\ninstead of this type, as they let you be explicit about whether or not to include\nthe `ref` prop.\n* @see {@link https://react-typescript-cheatsheet.netlify.app/docs/react-types/componentprops/ React TypeScript Cheatsheet}\n* @example\n* ```tsx\n// Retrieves the props an 'input' element accepts\ntype InputProps = React.ComponentProps<'input'>;\n```\n* @example\n* ```tsx\nconst MyComponent = (props: { foo: number, bar: string }) => <div />;\n* // Retrieves the props 'MyComponent' accepts\ntype MyComponentProps = React.ComponentProps<typeof MyComponent>;\n```\n     \n    type ComponentProps<T extends keyof JSX.IntrinsicElements | JSXElementConstructor<any>> = T extends\n        JSXElementConstructor<infer Props> ? Props\n        : T extends keyof JSX.IntrinsicElements ? JSX.IntrinsicElements[T]\n        : {};\nUsed to retrieve the props a component accepts with its ref. Can either be\npassed a string, indicating a DOM element (e.g. 'div', 'span', etc.) or the\ntype of a React component.\n* @see {@link https://react-typescript-cheatsheet.netlify.app/docs/react-types/componentprops/ React TypeScript Cheatsheet}\n* @example\n* ```tsx\n// Retrieves the props an 'input' element accepts\ntype InputProps = React.ComponentPropsWithRef<'input'>;\n```\n* @example\n* ```tsx\nconst MyComponent = (props: { foo: number, bar: string }) => <div />;\n* // Retrieves the props 'MyComponent' accepts\ntype MyComponentPropsWithRef = React.ComponentPropsWithRef<typeof MyComponent>;\n```\n     \n    type ComponentPropsWithRef<T extends ElementType> = T extends JSXElementConstructor<infer Props>\n        // If it's a class i.e. newable we're dealing with a class component\n        ? T extends abstract new(args: any) => any ? PropsWithoutRef<Props> & RefAttributes<InstanceType<T>>\n        : Props\n        : ComponentProps<T>;\nUsed to retrieve the props a custom component accepts with its ref.\n* Unlike {@link ComponentPropsWithRef}, this only works with custom\ncomponents, i.e. components you define yourself. This is to improve\ntype-checking performance.\n* @example\n* ```tsx\nconst MyComponent = (props: { foo: number, bar: string }) => <div />;\n* // Retrieves the props 'MyComponent' accepts\ntype MyComponentPropsWithRef = React.CustomComponentPropsWithRef<typeof MyComponent>;\n```\n     \n    type CustomComponentPropsWithRef<T extends ComponentType> = T extends JSXElementConstructor<infer Props>\n        // If it's a class i.e. newable we're dealing with a class component\n        ? T extends abstract new(args: any) => any ? PropsWithoutRef<Props> & RefAttributes<InstanceType<T>>\n        : Props\n        : never;\nUsed to retrieve the props a component accepts without its ref. Can either be\npassed a string, indicating a DOM element (e.g. 'div', 'span', etc.) or the\ntype of a React component.\n* @see {@link https://react-typescript-cheatsheet.netlify.app/docs/react-types/componentprops/ React TypeScript Cheatsheet}\n* @example\n* ```tsx\n// Retrieves the props an 'input' element accepts\ntype InputProps = React.ComponentPropsWithoutRef<'input'>;\n```\n* @example\n* ```tsx\nconst MyComponent = (props: { foo: number, bar: string }) => <div />;\n* // Retrieves the props 'MyComponent' accepts\ntype MyComponentPropsWithoutRef = React.ComponentPropsWithoutRef<typeof MyComponent>;\n```\n     \n    type ComponentPropsWithoutRef<T extends ElementType> = PropsWithoutRef<ComponentProps<T>>;\nRetrieves the type of the 'ref' prop for a given component type or tag name.\n* @template C The component type.\n* @example\n* ```tsx\ntype MyComponentRef = React.ComponentRef<typeof MyComponent>;\n```\n* @example\n* ```tsx\ntype DivRef = React.ComponentRef<'div'>;\n```\n     \n    type ComponentRef<T extends ElementType> = ComponentPropsWithRef<T> extends RefAttributes<infer Method> ? Method\n        : never;\n\n    // will show `Memo(${Component.displayName || Component.name})` in devtools by default,\n    // but can be given its own specific name\n    type MemoExoticComponent<T extends ComponentType<any>> = NamedExoticComponent<CustomComponentPropsWithRef<T>> & {\n        readonly type: T;\n    };\nLets you skip re-rendering a component when its props are unchanged.\n* @see {@link https://react.dev/reference/react/memo React Docs}\n* @param Component The component to memoize.\n@param propsAreEqual A function that will be used to determine if the props have changed.\n* @example\n* ```tsx\nimport { memo } from 'react';\n* const SomeComponent = memo(function SomeComponent(props: { foo: string }) {\n// ...\n});\n```\n     \n    function memo<P extends object>(\n        Component: FunctionComponent<P>,\n        propsAreEqual?: (prevProps: Readonly<P>, nextProps: Readonly<P>) => boolean,\n    ): NamedExoticComponent<P>;\n    function memo<T extends ComponentType<any>>(\n        Component: T,\n        propsAreEqual?: (prevProps: Readonly<ComponentProps<T>>, nextProps: Readonly<ComponentProps<T>>) => boolean,\n    ): MemoExoticComponent<T>;\n\n    interface LazyExoticComponent<T extends ComponentType<any>>\n        extends ExoticComponent<CustomComponentPropsWithRef<T>>\n    {\n        readonly _result: T;\n    }\nLets you defer loading a component’s code until it is rendered for the first time.\n* @see {@link https://react.dev/reference/react/lazy React Docs}\n* @param load A function that returns a `Promise` or another thenable (a `Promise`-like object with a\nthen method). React will not call `load` until the first time you attempt to render the returned\ncomponent. After React first calls load, it will wait for it to resolve, and then render the\nresolved value’s `.default` as a React component. Both the returned `Promise` and the `Promise`’s\nresolved value will be cached, so React will not call load more than once. If the `Promise` rejects,\nReact will throw the rejection reason for the nearest Error Boundary to handle.\n* @example\n* ```tsx\nimport { lazy } from 'react';\n* const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));\n```\n     \n    function lazy<T extends ComponentType<any>>(\n        load: () => Promise<{ default: T }>,\n    ): LazyExoticComponent<T>;\n\n    //\n    // React Hooks\n    // ----------------------------------------------------------------------\nThe instruction passed to a {@link Dispatch} function in {@link useState}\nto tell React what the next value of the {@link useState} should be.\n* Often found wrapped in {@link Dispatch}.\n* @template S The type of the state.\n* @example\n* ```tsx\n// This return type correctly represents the type of\n// `setCount` in the example below.\nconst useCustomState = (): Dispatch<SetStateAction<number>> => {\nconst [count, setCount] = useState(0);\n*   return setCount;\n}\n```\n     \n    type SetStateAction<S> = S | ((prevState: S) => S);\nA function that can be used to update the state of a {@link useState}\nor {@link useReducer} hook.\n     \n    type Dispatch<A> = (value: A) => void;\nA {@link Dispatch} function can sometimes be called without any arguments.\n     \n    type DispatchWithoutAction = () => void;\n    // Limit the reducer to accept only 0 or 1 action arguments\n    // eslint-disable-next-line @definitelytyped/no-single-element-tuple-type\n    type AnyActionArg = [] | [any];\n    // Get the dispatch type from the reducer arguments (captures optional action argument correctly)\n    type ActionDispatch<ActionArg extends AnyActionArg> = (...args: ActionArg) => void;\n    // Unlike redux, the actions _can_ be anything\n    type Reducer<S, A> = (prevState: S, action: A) => S;\n    // If useReducer accepts a reducer without action, dispatch may be called without any parameters.\n    type ReducerWithoutAction<S> = (prevState: S) => S;\n    // types used to try and prevent the compiler from reducing S\n    // to a supertype common with the second argument to useReducer()\n    type ReducerState<R extends Reducer<any, any>> = R extends Reducer<infer S, any> ? S : never;\n    type DependencyList = readonly unknown[];\n\n    // NOTE: callbacks are _only_ allowed to return either void, or a destructor.\n    type EffectCallback = () => void | Destructor;\n@deprecated Use `RefObject` instead.\n     \n    interface MutableRefObject<T> {\n        current: T;\n    }\n\n    // This will technically work if you give a Consumer<T> or Provider<T> but it's deprecated and warns\nAccepts a context object (the value returned from `React.createContext`) and returns the current\ncontext value, as given by the nearest context provider for the given context.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useContext}\n     \n    function useContext<T>(context: Context<T> /*, (not public API) observedBits?: number|boolean ): T;\nReturns a stateful value, and a function to update it.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useState}\n     \n    function useState<S>(initialState: S | (() => S)): [S, Dispatch<SetStateAction<S>>];\n    // convenience overload when first argument is omitted\nReturns a stateful value, and a function to update it.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useState}\n     \n    function useState<S = undefined>(): [S | undefined, Dispatch<SetStateAction<S | undefined>>];\nAn alternative to `useState`.\n* `useReducer` is usually preferable to `useState` when you have complex state logic that involves\nmultiple sub-values. It also lets you optimize performance for components that trigger deep\nupdates because you can pass `dispatch` down instead of callbacks.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useReducer}\n     \n    function useReducer<S, A extends AnyActionArg>(\n        reducer: (prevState: S, ...args: A) => S,\n        initialState: S,\n    ): [S, ActionDispatch<A>];\nAn alternative to `useState`.\n* `useReducer` is usually preferable to `useState` when you have complex state logic that involves\nmultiple sub-values. It also lets you optimize performance for components that trigger deep\nupdates because you can pass `dispatch` down instead of callbacks.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useReducer}\n     \n    function useReducer<S, A extends AnyActionArg>(\n        reducer: (prevState: S, ...args: A) => S,\n        initialState: S,\n    ): [S, ActionDispatch<A>];\nAn alternative to `useState`.\n* `useReducer` is usually preferable to `useState` when you have complex state logic that involves\nmultiple sub-values. It also lets you optimize performance for components that trigger deep\nupdates because you can pass `dispatch` down instead of callbacks.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useReducer}\n     \n    function useReducer<S, I, A extends AnyActionArg>(\n        reducer: (prevState: S, ...args: A) => S,\n        initialArg: I,\n        init: (i: I) => S,\n    ): [S, ActionDispatch<A>];\n`useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument\n(`initialValue`). The returned object will persist for the full lifetime of the component.\n* Note that `useRef()` is useful for more than the `ref` attribute. It’s handy for keeping any mutable\nvalue around similar to how you’d use instance fields in classes.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useRef}\n     \n    function useRef<T>(initialValue: T): RefObject<T>;\n    // convenience overload for refs given as a ref prop as they typically start with a null value\n`useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument\n(`initialValue`). The returned object will persist for the full lifetime of the component.\n* Note that `useRef()` is useful for more than the `ref` attribute. It’s handy for keeping any mutable\nvalue around similar to how you’d use instance fields in classes.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useRef}\n     \n    function useRef<T>(initialValue: T | null): RefObject<T | null>;\n    // convenience overload for undefined initialValue\n`useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument\n(`initialValue`). The returned object will persist for the full lifetime of the component.\n* Note that `useRef()` is useful for more than the `ref` attribute. It’s handy for keeping any mutable\nvalue around similar to how you’d use instance fields in classes.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useRef}\n     \n    function useRef<T>(initialValue: T | undefined): RefObject<T | undefined>;\nThe signature is identical to `useEffect`, but it fires synchronously after all DOM mutations.\nUse this to read layout from the DOM and synchronously re-render. Updates scheduled inside\n`useLayoutEffect` will be flushed synchronously, before the browser has a chance to paint.\n* Prefer the standard `useEffect` when possible to avoid blocking visual updates.\n* If you’re migrating code from a class component, `useLayoutEffect` fires in the same phase as\n`componentDidMount` and `componentDidUpdate`.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useLayoutEffect}\n     \n    function useLayoutEffect(effect: EffectCallback, deps?: DependencyList): void;\nAccepts a function that contains imperative, possibly effectful code.\n* @param effect Imperative function that can return a cleanup function\n@param deps If present, effect will only activate if the values in the list change.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useEffect}\n     \n    function useEffect(effect: EffectCallback, deps?: DependencyList): void;\n    // NOTE: this does not accept strings, but this will have to be fixed by removing strings from type Ref<T>\n`useImperativeHandle` customizes the instance value that is exposed to parent components when using\n`ref`. As always, imperative code using refs should be avoided in most cases.\n* `useImperativeHandle` should be used with `React.forwardRef`.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useImperativeHandle}\n     \n    function useImperativeHandle<T, R extends T>(ref: Ref<T> | undefined, init: () => R, deps?: DependencyList): void;\n    // I made 'inputs' required here and in useMemo as there's no point to memoizing without the memoization key\n    // useCallback(X) is identical to just using X, useMemo(() => Y) is identical to just using Y.\n`useCallback` will return a memoized version of the callback that only changes if one of the `inputs`\nhas changed.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useCallback}\n     \n    // A specific function type would not trigger implicit any.\n    // See https://github.com/DefinitelyTyped/DefinitelyTyped/issues/52873#issuecomment-845806435 for a comparison between `Function` and more specific types.\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n    function useCallback<T extends Function>(callback: T, deps: DependencyList): T;\n`useMemo` will only recompute the memoized value when one of the `deps` has changed.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useMemo}\n     \n    // allow undefined, but don't make it optional as that is very likely a mistake\n    function useMemo<T>(factory: () => T, deps: DependencyList): T;\n`useDebugValue` can be used to display a label for custom hooks in React DevTools.\n* NOTE: We don’t recommend adding debug values to every custom hook.\nIt’s most valuable for custom hooks that are part of shared libraries.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useDebugValue}\n     \n    // the name of the custom hook is itself derived from the function name at runtime:\n    // it's just the function name without the \"use\" prefix.\n    function useDebugValue<T>(value: T, format?: (value: T) => any): void;\n\n    export type TransitionFunction = () => VoidOrUndefinedOnly | Promise<VoidOrUndefinedOnly>;\n    // strange definition to allow vscode to show documentation on the invocation\n    export interface TransitionStartFunction {\nState updates caused inside the callback are allowed to be deferred.\n* **If some state update causes a component to suspend, that state update should be wrapped in a transition.**\n* @param callback A function which causes state updates that can be deferred.\n         \n        (callback: TransitionFunction): void;\n    }\nReturns a deferred version of the value that may “lag behind” it.\n* This is commonly used to keep the interface responsive when you have something that renders immediately\nbased on user input and something that needs to wait for a data fetch.\n* A good example of this is a text input.\n* @param value The value that is going to be deferred\n@param initialValue A value to use during the initial render of a component. If this option is omitted, `useDeferredValue` will not defer during the initial render, because there’s no previous version of `value` that it can render instead.\n* @see {@link https://react.dev/reference/react/useDeferredValue}\n\nNew source code:\n\n```typescript\nfunction useDeferredValue\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Used to represent DOM API's where users can either pass\ntrue or false as a boolean or as its equivalent strings.\n \ntype Booleanish = boolean | \"true\" | \"false\";\n@see {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/crossorigin MDN}\n \ntype CrossOrigin = \"anonymous\" | \"use-credentials\" | \"\" | undefined;\n\ndeclare const UNDEFINED_VOID_ONLY: unique symbol;\n@internal Use `Awaited<ReactNode>` instead\n \n// Helper type to enable `Awaited<ReactNode>`.\n// Must be a copy of the non-thenables of `ReactNode`.\ntype AwaitedReactNode =\n    | React.ReactElement\n    | string\n    | number\n    | bigint\n    | Iterable<React.ReactNode>\n    | React.ReactPortal\n    | boolean\n    | null\n    | undefined\n    | React.DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES[\n        keyof React.DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES\n    ];\nThe function returned from an effect passed to {@link React.useEffect useEffect},\nwhich can be used to clean up the effect when the component unmounts.\n* @see {@link https://react.dev/reference/react/useEffect React Docs}\n \ntype Destructor = () => void | { [UNDEFINED_VOID_ONLY]: never };\ntype VoidOrUndefinedOnly = void | { [UNDEFINED_VOID_ONLY]: never };\n\n// eslint-disable-next-line @definitelytyped/export-just-namespace\nexport = React;\nexport as namespace React;\n\ndeclare namespace React {\n    //\n    // React Elements\n    // ----------------------------------------------------------------------\nUsed to retrieve the possible components which accept a given set of props.\n* Can be passed no type parameters to get a union of all possible components\nand tags.\n* Is a superset of {@link ComponentType}.\n* @template P The props to match against. If not passed, defaults to any.\n@template Tag An optional tag to match against. If not passed, attempts to match against all possible tags.\n* @example\n* ```tsx\n// All components and tags (img, embed etc.)\n// which accept `src`\ntype SrcComponents = ElementType<{ src: any }>;\n```\n* @example\n* ```tsx\n// All components\ntype AllComponents = ElementType;\n```\n* @example\n* ```tsx\n// All custom components which match `src`, and tags which\n// match `src`, narrowed down to just `audio` and `embed`\ntype SrcComponents = ElementType<{ src: any }, 'audio' | 'embed'>;\n```\n     \n    type ElementType<P = any, Tag extends keyof JSX.IntrinsicElements = keyof JSX.IntrinsicElements> =\n        | { [K in Tag]: P extends JSX.IntrinsicElements[K] ? K : never }[Tag]\n        | ComponentType<P>;\nRepresents any user-defined component, either as a function or a class.\n* Similar to {@link JSXElementConstructor}, but with extra properties like\n{@link FunctionComponent.defaultProps defaultProps }.\n* @template P The props the component accepts.\n* @see {@link ComponentClass}\n@see {@link FunctionComponent}\n     \n    type ComponentType<P = {}> = ComponentClass<P> | FunctionComponent<P>;\nRepresents any user-defined component, either as a function or a class.\n* Similar to {@link ComponentType}, but without extra properties like\n{@link FunctionComponent.defaultProps defaultProps }.\n* @template P The props the component accepts.\n     \n    type JSXElementConstructor<P> =\n        | ((\n            props: P,\n        ) => ReactNode | Promise<ReactNode>)\n        // constructor signature must match React.Component\n        | (new(props: P) => Component<any, any>);\nCreated by {@link createRef}, or {@link useRef} when passed `null`.\n* @template T The type of the ref's value.\n* @example\n* ```tsx\nconst ref = createRef<HTMLDivElement>();\n* ref.current = document.createElement('div'); // Error\n```\n     \n    interface RefObject<T> {\nThe current value of the ref.\n         \n        current: T;\n    }\n\n    interface DO_NOT_USE_OR_YOU_WILL_BE_FIRED_CALLBACK_REF_RETURN_VALUES {\n    }\nA callback fired whenever the ref's value changes.\n* @template T The type of the ref's value.\n* @see {@link https://react.dev/reference/react-dom/components/common#ref-callback React Docs}\n* @example\n* ```tsx\n<div ref={(node) => console.log(node)} />\n```\n     \n    type RefCallback<T> = {\n        bivarianceHack(\n            instance: T | null,\n        ):\n            | void\n            | (() => VoidOrUndefinedOnly)\n            | DO_NOT_USE_OR_YOU_WILL_BE_FIRED_CALLBACK_REF_RETURN_VALUES[\n                keyof DO_NOT_USE_OR_YOU_WILL_BE_FIRED_CALLBACK_REF_RETURN_VALUES\n            ];\n    }[\"bivarianceHack\"];\nA union type of all possible shapes for React refs.\n* @see {@link RefCallback}\n@see {@link RefObject}\n     \n\n    type Ref<T> = RefCallback<T> | RefObject<T | null> | null;\n@deprecated Use `Ref` instead. String refs are no longer supported.\nIf you're typing a library with support for React versions with string refs, use `RefAttributes<T>['ref']` instead.\n     \n    type LegacyRef<T> = Ref<T>;\n@deprecated Use `ComponentRef<T>` instead\n* Retrieves the type of the 'ref' prop for a given component type or tag name.\n* @template C The component type.\n* @example\n* ```tsx\ntype MyComponentRef = React.ElementRef<typeof MyComponent>;\n```\n* @example\n* ```tsx\ntype DivRef = React.ElementRef<'div'>;\n```\n     \n    type ElementRef<\n        C extends\n            | ForwardRefExoticComponent<any>\n            | { new(props: any): Component<any> }\n            | ((props: any) => ReactNode)\n            | keyof JSX.IntrinsicElements,\n    > = ComponentRef<C>;\n\n    type ComponentState = any;\nA value which uniquely identifies a node among items in an array.\n* @see {@link https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key React Docs}\n     \n    type Key = string | number | bigint;\n@internal The props any component can receive.\nYou don't have to add this type. All components automatically accept these props.\n```tsx\nconst Component = () => <div />;\n<Component key=\"one\" />\n```\n* WARNING: The implementation of a component will never have access to these attributes.\nThe following example would be incorrect usage because {@link Component} would never have access to `key`:\n```tsx\nconst Component = (props: React.Attributes) => props.key;\n```\n     \n    interface Attributes {\n        key?: Key | null | undefined;\n    }\nThe props any component accepting refs can receive.\nClass components, built-in browser components (e.g. `div`) and forwardRef components can receive refs and automatically accept these props.\n```tsx\nconst Component = forwardRef(() => <div />);\n<Component ref={(current) => console.log(current)} />\n```\n* You only need this type if you manually author the types of props that need to be compatible with legacy refs.\n```tsx\ninterface Props extends React.RefAttributes<HTMLDivElement> {}\ndeclare const Component: React.FunctionComponent<Props>;\n```\n* Otherwise it's simpler to directly use {@link Ref} since you can safely use the\nprops type to describe to props that a consumer can pass to the component\nas well as describing the props the implementation of a component \"sees\".\n{@link RefAttributes} is generally not safe to describe both consumer and seen props.\n* ```tsx\ninterface Props extends {\nref?: React.Ref<HTMLDivElement> | undefined;\n}\ndeclare const Component: React.FunctionComponent<Props>;\n```\n* WARNING: The implementation of a component will not have access to the same type in versions of React supporting string refs.\nThe following example would be incorrect usage because {@link Component} would never have access to a `ref` with type `string`\n```tsx\nconst Component = (props: React.RefAttributes) => props.ref;\n```\n     \n    interface RefAttributes<T> extends Attributes {\nAllows getting a ref to the component instance.\nOnce the component unmounts, React will set `ref.current` to `null`\n(or call the ref with `null` if you passed a callback ref).\n* @see {@link https://react.dev/learn/referencing-values-with-refs#refs-and-the-dom React Docs}\n         \n        ref?: Ref<T> | undefined;\n    }\nRepresents the built-in attributes available to class components.\n     \n    interface ClassAttributes<T> extends RefAttributes<T> {\n    }\nRepresents a JSX element.\n* Where {@link ReactNode} represents everything that can be rendered, `ReactElement`\nonly represents JSX.\n* @template P The type of the props object\n@template T The type of the component or tag\n* @example\n* ```tsx\nconst element: ReactElement = <div />;\n```\n     \n    interface ReactElement<\n        P = unknown,\n        T extends string | JSXElementConstructor<any> = string | JSXElementConstructor<any>,\n    > {\n        type: T;\n        props: P;\n        key: string | null;\n    }\n@deprecated\n     \n    interface ReactComponentElement<\n        T extends keyof JSX.IntrinsicElements | JSXElementConstructor<any>,\n        P = Pick<ComponentProps<T>, Exclude<keyof ComponentProps<T>, \"key\" | \"ref\">>,\n    > extends ReactElement<P, Exclude<T, number>> {}\n@deprecated Use `ReactElement<P, React.FunctionComponent<P>>`\n     \n    interface FunctionComponentElement<P> extends ReactElement<P, FunctionComponent<P>> {\n@deprecated Use `element.props.ref` instead.\n         \n        ref?: (\"ref\" extends keyof P ? P extends { ref?: infer R | undefined } ? R : never : never) | undefined;\n    }\n@deprecated Use `ReactElement<P, React.ComponentClass<P>>`\n     \n    type CElement<P, T extends Component<P, ComponentState>> = ComponentElement<P, T>;\n@deprecated Use `ReactElement<P, React.ComponentClass<P>>`\n     \n    interface ComponentElement<P, T extends Component<P, ComponentState>> extends ReactElement<P, ComponentClass<P>> {\n@deprecated Use `element.props.ref` instead.\n         \n        ref?: Ref<T> | undefined;\n    }\n@deprecated Use {@link ComponentElement} instead.\n     \n    type ClassicElement<P> = CElement<P, ClassicComponent<P, ComponentState>>;\n\n    // string fallback for custom web-components\n@deprecated Use `ReactElement<P, string>`\n     \n    interface DOMElement<P extends HTMLAttributes<T> | SVGAttributes<T>, T extends Element>\n        extends ReactElement<P, string>\n    {\n@deprecated Use `element.props.ref` instead.\n         \n        ref: Ref<T>;\n    }\n\n    // ReactHTML for ReactHTMLElement\n    interface ReactHTMLElement<T extends HTMLElement> extends DetailedReactHTMLElement<AllHTMLAttributes<T>, T> {}\n\n    interface DetailedReactHTMLElement<P extends HTMLAttributes<T>, T extends HTMLElement> extends DOMElement<P, T> {\n        type: HTMLElementType;\n    }\n\n    // ReactSVG for ReactSVGElement\n    interface ReactSVGElement extends DOMElement<SVGAttributes<SVGElement>, SVGElement> {\n        type: SVGElementType;\n    }\n\n    interface ReactPortal extends ReactElement {\n        children: ReactNode;\n    }\nDifferent release channels declare additional types of ReactNode this particular release channel accepts.\nApp or library types should never augment this interface.\n     \n    interface DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES {}\nRepresents all of the things React can render.\n* Where {@link ReactElement} only represents JSX, `ReactNode` represents everything that can be rendered.\n* @see {@link https://react-typescript-cheatsheet.netlify.app/docs/react-types/reactnode/ React TypeScript Cheatsheet}\n* @example\n* ```tsx\n// Typing children\ntype Props = { children: ReactNode }\n* const Component = ({ children }: Props) => <div>{children}</div>\n* <Component>hello</Component>\n```\n* @example\n* ```tsx\n// Typing a custom element\ntype Props = { customElement: ReactNode }\n* const Component = ({ customElement }: Props) => <div>{customElement}</div>\n* <Component customElement={<div>hello</div>} />\n```\n     \n    // non-thenables need to be kept in sync with AwaitedReactNode\n    type ReactNode =\n        | ReactElement\n        | string\n        | number\n        | bigint\n        | Iterable<ReactNode>\n        | ReactPortal\n        | boolean\n        | null\n        | undefined\n        | DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES[\n            keyof DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES\n        ]\n        | Promise<AwaitedReactNode>;\n\n    //\n    // Top Level API\n    // ----------------------------------------------------------------------\n\n    // DOM Elements\n    // TODO: generalize this to everything in `keyof ReactHTML`, not just \"input\"\n    function createElement(\n        type: \"input\",\n        props?: InputHTMLAttributes<HTMLInputElement> & ClassAttributes<HTMLInputElement> | null,\n        ...children: ReactNode[]\n    ): DetailedReactHTMLElement<InputHTMLAttributes<HTMLInputElement>, HTMLInputElement>;\n    function createElement<P extends HTMLAttributes<T>, T extends HTMLElement>(\n        type: HTMLElementType,\n        props?: ClassAttributes<T> & P | null,\n        ...children: ReactNode[]\n    ): DetailedReactHTMLElement<P, T>;\n    function createElement<P extends SVGAttributes<T>, T extends SVGElement>(\n        type: SVGElementType,\n        props?: ClassAttributes<T> & P | null,\n        ...children: ReactNode[]\n    ): ReactSVGElement;\n    function createElement<P extends DOMAttributes<T>, T extends Element>(\n        type: string,\n        props?: ClassAttributes<T> & P | null,\n        ...children: ReactNode[]\n    ): DOMElement<P, T>;\n\n    // Custom components\n\n    function createElement<P extends {}>(\n        type: FunctionComponent<P>,\n        props?: Attributes & P | null,\n        ...children: ReactNode[]\n    ): FunctionComponentElement<P>;\n    function createElement<P extends {}, T extends Component<P, ComponentState>, C extends ComponentClass<P>>(\n        type: ClassType<P, T, C>,\n        props?: ClassAttributes<T> & P | null,\n        ...children: ReactNode[]\n    ): CElement<P, T>;\n    function createElement<P extends {}>(\n        type: FunctionComponent<P> | ComponentClass<P> | string,\n        props?: Attributes & P | null,\n        ...children: ReactNode[]\n    ): ReactElement<P>;\n\n    // DOM Elements\n    // ReactHTMLElement\n    function cloneElement<P extends HTMLAttributes<T>, T extends HTMLElement>(\n        element: DetailedReactHTMLElement<P, T>,\n        props?: P,\n        ...children: ReactNode[]\n    ): DetailedReactHTMLElement<P, T>;\n    // ReactHTMLElement, less specific\n    function cloneElement<P extends HTMLAttributes<T>, T extends HTMLElement>(\n        element: ReactHTMLElement<T>,\n        props?: P,\n        ...children: ReactNode[]\n    ): ReactHTMLElement<T>;\n    // SVGElement\n    function cloneElement<P extends SVGAttributes<T>, T extends SVGElement>(\n        element: ReactSVGElement,\n        props?: P,\n        ...children: ReactNode[]\n    ): ReactSVGElement;\n    // DOM Element (has to be the last, because type checking stops at first overload that fits)\n    function cloneElement<P extends DOMAttributes<T>, T extends Element>(\n        element: DOMElement<P, T>,\n        props?: DOMAttributes<T> & P,\n        ...children: ReactNode[]\n    ): DOMElement<P, T>;\n\n    // Custom components\n    function cloneElement<P>(\n        element: FunctionComponentElement<P>,\n        props?: Partial<P> & Attributes,\n        ...children: ReactNode[]\n    ): FunctionComponentElement<P>;\n    function cloneElement<P, T extends Component<P, ComponentState>>(\n        element: CElement<P, T>,\n        props?: Partial<P> & ClassAttributes<T>,\n        ...children: ReactNode[]\n    ): CElement<P, T>;\n    function cloneElement<P>(\n        element: ReactElement<P>,\n        props?: Partial<P> & Attributes,\n        ...children: ReactNode[]\n    ): ReactElement<P>;\nDescribes the props accepted by a Context {@link Provider}.\n* @template T The type of the value the context provides.\n     \n    interface ProviderProps<T> {\n        value: T;\n        children?: ReactNode | undefined;\n    }\nDescribes the props accepted by a Context {@link Consumer}.\n* @template T The type of the value the context provides.\n     \n    interface ConsumerProps<T> {\n        children: (value: T) => ReactNode;\n    }\nAn object masquerading as a component. These are created by functions\nlike {@link forwardRef}, {@link memo}, and {@link createContext}.\n* In order to make TypeScript work, we pretend that they are normal\ncomponents.\n* But they are, in fact, not callable - instead, they are objects which\nare treated specially by the renderer.\n* @template P The props the component accepts.\n     \n    interface ExoticComponent<P = {}> {\n        (props: P): ReactNode;\n        readonly $$typeof: symbol;\n    }\nAn {@link ExoticComponent} with a `displayName` property applied to it.\n* @template P The props the component accepts.\n     \n    interface NamedExoticComponent<P = {}> extends ExoticComponent<P> {\nUsed in debugging messages. You might want to set it\nexplicitly if you want to display a different name for\ndebugging purposes.\n* @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs}\n         \n        displayName?: string | undefined;\n    }\nAn {@link ExoticComponent} with a `propTypes` property applied to it.\n* @template P The props the component accepts.\n     \n    interface ProviderExoticComponent<P> extends ExoticComponent<P> {\n    }\nUsed to retrieve the type of a context object from a {@link Context}.\n* @template C The context object.\n* @example\n* ```tsx\nimport { createContext } from 'react';\n* const MyContext = createContext({ foo: 'bar' });\n* type ContextType = ContextType<typeof MyContext>;\n// ContextType = { foo: string }\n```\n     \n    type ContextType<C extends Context<any>> = C extends Context<infer T> ? T : never;\nWraps your components to specify the value of this context for all components inside.\n* @see {@link https://react.dev/reference/react/createContext#provider React Docs}\n* @example\n* ```tsx\nimport { createContext } from 'react';\n* const ThemeContext = createContext('light');\n* function App() {\nreturn (\n<ThemeContext.Provider value=\"dark\">\n<Toolbar />\n</ThemeContext.Provider>\n);\n}\n```\n     \n    type Provider<T> = ProviderExoticComponent<ProviderProps<T>>;\nThe old way to read context, before {@link useContext} existed.\n* @see {@link https://react.dev/reference/react/createContext#consumer React Docs}\n* @example\n* ```tsx\nimport { UserContext } from './user-context';\n* function Avatar() {\nreturn (\n<UserContext.Consumer>\n{user => <img src={user.profileImage} alt={user.name} />}\n</UserContext.Consumer>\n);\n}\n```\n     \n    type Consumer<T> = ExoticComponent<ConsumerProps<T>>;\nContext lets components pass information deep down without explicitly\npassing props.\n* Created from {@link createContext}\n* @see {@link https://react.dev/learn/passing-data-deeply-with-context React Docs}\n@see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/context/ React TypeScript Cheatsheet}\n* @example\n* ```tsx\nimport { createContext } from 'react';\n* const ThemeContext = createContext('light');\n```\n     \n    interface Context<T> extends Provider<T> {\n        Provider: Provider<T>;\n        Consumer: Consumer<T>;\nUsed in debugging messages. You might want to set it\nexplicitly if you want to display a different name for\ndebugging purposes.\n* @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs}\n         \n        displayName?: string | undefined;\n    }\nLets you create a {@link Context} that components can provide or read.\n* @param defaultValue The value you want the context to have when there is no matching\n{@link Provider} in the tree above the component reading the context. This is meant\nas a \"last resort\" fallback.\n* @see {@link https://react.dev/reference/react/createContext#reference React Docs}\n@see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/context/ React TypeScript Cheatsheet}\n* @example\n* ```tsx\nimport { createContext } from 'react';\n* const ThemeContext = createContext('light');\nfunction App() {\nreturn (\n<ThemeContext value=\"dark\">\n<Toolbar />\n</ThemeContext>\n);\n}\n```\n     \n    function createContext<T>(\n        // If you thought this should be optional, see\n        // https://github.com/DefinitelyTyped/DefinitelyTyped/pull/24509#issuecomment-382213106\n        defaultValue: T,\n    ): Context<T>;\n\n    function isValidElement<P>(object: {} | null | undefined): object is ReactElement<P>;\n\n    const Children: {\n        map<T, C>(\n            children: C | readonly C[],\n            fn: (child: C, index: number) => T,\n        ): C extends null | undefined ? C : Array<Exclude<T, boolean | null | undefined>>;\n        forEach<C>(children: C | readonly C[], fn: (child: C, index: number) => void): void;\n        count(children: any): number;\n        only<C>(children: C): C extends any[] ? never : C;\n        toArray(children: ReactNode | ReactNode[]): Array<Exclude<ReactNode, boolean | null | undefined>>;\n    };\n\n    export interface FragmentProps {\n        children?: React.ReactNode;\n    }\nLets you group elements without a wrapper node.\n* @see {@link https://react.dev/reference/react/Fragment React Docs}\n* @example\n* ```tsx\nimport { Fragment } from 'react';\n* <Fragment>\n<td>Hello</td>\n<td>World</td>\n</Fragment>\n```\n* @example\n* ```tsx\n// Using the <></> shorthand syntax:\n* <>\n<td>Hello</td>\n<td>World</td>\n</>\n```\n     \n    const Fragment: ExoticComponent<FragmentProps>;\nLets you find common bugs in your components early during development.\n* @see {@link https://react.dev/reference/react/StrictMode React Docs}\n* @example\n* ```tsx\nimport { StrictMode } from 'react';\n* <StrictMode>\n<App />\n</StrictMode>\n```\n     \n    const StrictMode: ExoticComponent<{ children?: ReactNode | undefined }>;\nThe props accepted by {@link Suspense}.\n* @see {@link https://react.dev/reference/react/Suspense React Docs}\n     \n    interface SuspenseProps {\n        children?: ReactNode | undefined;\n\n         A fallback react tree to show when a Suspense child (like React.lazy) suspends \n        fallback?: ReactNode;\nA name for this Suspense boundary for instrumentation purposes.\nThe name will help identify this boundary in React DevTools.\n         \n        name?: string | undefined;\n    }\nLets you display a fallback until its children have finished loading.\n* @see {@link https://react.dev/reference/react/Suspense React Docs}\n* @example\n* ```tsx\nimport { Suspense } from 'react';\n* <Suspense fallback={<Loading />}>\n<ProfileDetails />\n</Suspense>\n```\n     \n    const Suspense: ExoticComponent<SuspenseProps>;\n    const version: string;\nThe callback passed to {@link ProfilerProps.onRender}.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n     \n    type ProfilerOnRenderCallback = (\nThe string id prop of the {@link Profiler} tree that has just committed. This lets\nyou identify which part of the tree was committed if you are using multiple\nprofilers.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n         \n        id: string,\nThis lets you know whether the tree has just been mounted for the first time\nor re-rendered due to a change in props, state, or hooks.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n         \n        phase: \"mount\" | \"update\" | \"nested-update\",\nThe number of milliseconds spent rendering the {@link Profiler} and its descendants\nfor the current update. This indicates how well the subtree makes use of\nmemoization (e.g. {@link memo} and {@link useMemo}). Ideally this value should decrease\nsignificantly after the initial mount as many of the descendants will only need to\nre-render if their specific props change.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n         \n        actualDuration: number,\nThe number of milliseconds estimating how much time it would take to re-render the entire\n{@link Profiler} subtree without any optimizations. It is calculated by summing up the most\nrecent render durations of each component in the tree. This value estimates a worst-case\ncost of rendering (e.g. the initial mount or a tree with no memoization). Compare\n{@link actualDuration} against it to see if memoization is working.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n         \n        baseDuration: number,\nA numeric timestamp for when React began rendering the current update.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n         \n        startTime: number,\nA numeric timestamp for when React committed the current update. This value is shared\nbetween all profilers in a commit, enabling them to be grouped if desirable.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n         \n        commitTime: number,\n    ) => void;\nThe props accepted by {@link Profiler}.\n* @see {@link https://react.dev/reference/react/Profiler React Docs}\n     \n    interface ProfilerProps {\n        children?: ReactNode | undefined;\n        id: string;\n        onRender: ProfilerOnRenderCallback;\n    }\nLets you measure rendering performance of a React tree programmatically.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n* @example\n* ```tsx\n<Profiler id=\"App\" onRender={onRender}>\n<App />\n</Profiler>\n```\n     \n    const Profiler: ExoticComponent<ProfilerProps>;\n\n    //\n    // Component API\n    // ----------------------------------------------------------------------\n\n    type ReactInstance = Component<any> | Element;\n\n    // Base component for plain JS classes\n    interface Component<P = {}, S = {}, SS = any> extends ComponentLifecycle<P, S, SS> {}\n    class Component<P, S> {\nIf set, `this.context` will be set at runtime to the current value of the given Context.\n* @example\n* ```ts\ntype MyContext = number\nconst Ctx = React.createContext<MyContext>(0)\n* class Foo extends React.Component {\nstatic contextType = Ctx\ncontext!: React.ContextType<typeof Ctx>\nrender () {\nreturn <>My context's value: {this.context}</>;\n}\n}\n```\n* @see {@link https://react.dev/reference/react/Component#static-contexttype}\n         \n        static contextType?: Context<any> | undefined;\nIgnored by React.\n@deprecated Only kept in types for backwards compatibility. Will be removed in a future major release.\n         \n        static propTypes?: any;\nIf using the new style context, re-declare this in your class to be the\n`React.ContextType` of your `static contextType`.\nShould be used with type annotation or static contextType.\n* @example\n```ts\nstatic contextType = MyContext\n// For TS pre-3.7:\ncontext!: React.ContextType<typeof MyContext>\n// For TS 3.7 and above:\ndeclare context: React.ContextType<typeof MyContext>\n```\n* @see {@link https://react.dev/reference/react/Component#context React Docs}\n         \n        context: unknown;\n\n        // Keep in sync with constructor signature of JSXElementConstructor and ComponentClass.\n        constructor(props: P);\n\n        // We MUST keep setState() as a unified signature because it allows proper checking of the method return type.\n        // See: https://github.com/DefinitelyTyped/DefinitelyTyped/issues/18365#issuecomment-351013257\n        // Also, the ` | S` allows intellisense to not be dumbisense\n        setState<K extends keyof S>(\n            state: ((prevState: Readonly<S>, props: Readonly<P>) => Pick<S, K> | S | null) | (Pick<S, K> | S | null),\n            callback?: () => void,\n        ): void;\n\n        forceUpdate(callback?: () => void): void;\n        render(): ReactNode;\n\n        readonly props: Readonly<P>;\n        state: Readonly<S>;\n    }\n\n    class PureComponent<P = {}, S = {}, SS = any> extends Component<P, S, SS> {}\n@deprecated Use `ClassicComponent` from `create-react-class`\n* @see {@link https://legacy.reactjs.org/docs/react-without-es6.html Legacy React Docs}\n@see {@link https://www.npmjs.com/package/create-react-class `create-react-class` on npm}\n     \n    interface ClassicComponent<P = {}, S = {}> extends Component<P, S> {\n        replaceState(nextState: S, callback?: () => void): void;\n        isMounted(): boolean;\n        getInitialState?(): S;\n    }\n\n    //\n    // Class Interfaces\n    // ----------------------------------------------------------------------\nRepresents the type of a function component. Can optionally\nreceive a type argument that represents the props the component\nreceives.\n* @template P The props the component accepts.\n@see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/function_components React TypeScript Cheatsheet}\n@alias for {@link FunctionComponent}\n* @example\n* ```tsx\n// With props:\ntype Props = { name: string }\n* const MyComponent: FC<Props> = (props) => {\nreturn <div>{props.name}</div>\n}\n```\n* @example\n* ```tsx\n// Without props:\nconst MyComponentWithoutProps: FC = () => {\nreturn <div>MyComponentWithoutProps</div>\n}\n```\n     \n    type FC<P = {}> = FunctionComponent<P>;\nRepresents the type of a function component. Can optionally\nreceive a type argument that represents the props the component\naccepts.\n* @template P The props the component accepts.\n@see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/function_components React TypeScript Cheatsheet}\n* @example\n* ```tsx\n// With props:\ntype Props = { name: string }\n* const MyComponent: FunctionComponent<Props> = (props) => {\nreturn <div>{props.name}</div>\n}\n```\n* @example\n* ```tsx\n// Without props:\nconst MyComponentWithoutProps: FunctionComponent = () => {\nreturn <div>MyComponentWithoutProps</div>\n}\n```\n     \n    interface FunctionComponent<P = {}> {\n        (props: P): ReactNode | Promise<ReactNode>;\nIgnored by React.\n@deprecated Only kept in types for backwards compatibility. Will be removed in a future major release.\n         \n        propTypes?: any;\nUsed in debugging messages. You might want to set it\nexplicitly if you want to display a different name for\ndebugging purposes.\n* @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs}\n* @example\n* ```tsx\n* const MyComponent: FC = () => {\nreturn <div>Hello!</div>\n}\n* MyComponent.displayName = 'MyAwesomeComponent'\n```\n         \n        displayName?: string | undefined;\n    }\nThe type of the ref received by a {@link ForwardRefRenderFunction}.\n* @see {@link ForwardRefRenderFunction}\n     \n    // Making T nullable is assuming the refs will be managed by React or the component impl will write it somewhere else.\n    // But this isn't necessarily true. We haven't heard complains about it yet and hopefully `forwardRef` is removed from React before we do.\n    type ForwardedRef<T> = ((instance: T | null) => void) | RefObject<T | null> | null;\nThe type of the function passed to {@link forwardRef}. This is considered different\nto a normal {@link FunctionComponent} because it receives an additional argument,\n* @param props Props passed to the component, if any.\n@param ref A ref forwarded to the component of type {@link ForwardedRef}.\n* @template T The type of the forwarded ref.\n@template P The type of the props the component accepts.\n* @see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/forward_and_create_ref/ React TypeScript Cheatsheet}\n@see {@link forwardRef}\n     \n    interface ForwardRefRenderFunction<T, P = {}> {\n        (props: P, ref: ForwardedRef<T>): ReactNode;\nUsed in debugging messages. You might want to set it\nexplicitly if you want to display a different name for\ndebugging purposes.\n* Will show `ForwardRef(${Component.displayName || Component.name})`\nin devtools by default, but can be given its own specific name.\n* @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs}\n         \n        displayName?: string | undefined;\nIgnored by React.\n@deprecated Only kept in types for backwards compatibility. Will be removed in a future major release.\n         \n        propTypes?: any;\n    }\nRepresents a component class in React.\n* @template P The props the component accepts.\n@template S The internal state of the component.\n     \n    interface ComponentClass<P = {}, S = ComponentState> extends StaticLifecycle<P, S> {\n        // constructor signature must match React.Component\n        new(props: P): Component<P, S>;\nIgnored by React.\n@deprecated Only kept in types for backwards compatibility. Will be removed in a future major release.\n         \n        propTypes?: any;\n        contextType?: Context<any> | undefined;\n        defaultProps?: Partial<P> | undefined;\nUsed in debugging messages. You might want to set it\nexplicitly if you want to display a different name for\ndebugging purposes.\n* @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs}\n         \n        displayName?: string | undefined;\n    }\n@deprecated Use `ClassicComponentClass` from `create-react-class`\n* @see {@link https://legacy.reactjs.org/docs/react-without-es6.html Legacy React Docs}\n@see {@link https://www.npmjs.com/package/create-react-class `create-react-class` on npm}\n     \n    interface ClassicComponentClass<P = {}> extends ComponentClass<P> {\n        new(props: P): ClassicComponent<P, ComponentState>;\n        getDefaultProps?(): P;\n    }\nUsed in {@link createElement} and {@link createFactory} to represent\na class.\n* An intersection type is used to infer multiple type parameters from\na single argument, which is useful for many top-level API defs.\nSee {@link https://github.com/Microsoft/TypeScript/issues/7234 this GitHub issue}\nfor more info.\n     \n    type ClassType<P, T extends Component<P, ComponentState>, C extends ComponentClass<P>> =\n        & C\n        & (new(props: P) => T);\n\n    //\n    // Component Specs and Lifecycle\n    // ----------------------------------------------------------------------\n\n    // This should actually be something like `Lifecycle<P, S> | DeprecatedLifecycle<P, S>`,\n    // as React will _not_ call the deprecated lifecycle methods if any of the new lifecycle\n    // methods are present.\n    interface ComponentLifecycle<P, S, SS = any> extends NewLifecycle<P, S, SS>, DeprecatedLifecycle<P, S> {\nCalled immediately after a component is mounted. Setting state here will trigger re-rendering.\n         \n        componentDidMount?(): void;\nCalled to determine whether the change in props and state should trigger a re-render.\n* `Component` always returns true.\n`PureComponent` implements a shallow comparison on props and state and returns true if any\nprops or states have changed.\n* If false is returned, {@link Component.render}, `componentWillUpdate`\nand `componentDidUpdate` will not be called.\n         \n        shouldComponentUpdate?(nextProps: Readonly<P>, nextState: Readonly<S>, nextContext: any): boolean;\nCalled immediately before a component is destroyed. Perform any necessary cleanup in this method, such as\ncancelled network requests, or cleaning up any DOM elements created in `componentDidMount`.\n         \n        componentWillUnmount?(): void;\nCatches exceptions generated in descendant components. Unhandled exceptions will cause\nthe entire component tree to unmount.\n         \n        componentDidCatch?(error: Error, errorInfo: ErrorInfo): void;\n    }\n\n    // Unfortunately, we have no way of declaring that the component constructor must implement this\n    interface StaticLifecycle<P, S> {\n        getDerivedStateFromProps?: GetDerivedStateFromProps<P, S> | undefined;\n        getDerivedStateFromError?: GetDerivedStateFromError<P, S> | undefined;\n    }\n\n    type GetDerivedStateFromProps<P, S> =\nReturns an update to a component's state based on its new props and old state.\n* Note: its presence prevents any of the deprecated lifecycle methods from being invoked\n         \n        (nextProps: Readonly<P>, prevState: S) => Partial<S> | null;\n\n    type GetDerivedStateFromError<P, S> =\nThis lifecycle is invoked after an error has been thrown by a descendant component.\nIt receives the error that was thrown as a parameter and should return a value to update state.\n* Note: its presence prevents any of the deprecated lifecycle methods from being invoked\n         \n        (error: any) => Partial<S> | null;\n\n    // This should be \"infer SS\" but can't use it yet\n    interface NewLifecycle<P, S, SS> {\nRuns before React applies the result of {@link Component.render render} to the document, and\nreturns an object to be given to {@link componentDidUpdate}. Useful for saving\nthings such as scroll position before {@link Component.render render} causes changes to it.\n* Note: the presence of this method prevents any of the deprecated\nlifecycle events from running.\n         \n        getSnapshotBeforeUpdate?(prevProps: Readonly<P>, prevState: Readonly<S>): SS | null;\nCalled immediately after updating occurs. Not called for the initial render.\n* The snapshot is only present if {@link getSnapshotBeforeUpdate} is present and returns non-null.\n         \n        componentDidUpdate?(prevProps: Readonly<P>, prevState: Readonly<S>, snapshot?: SS): void;\n    }\n\n    interface DeprecatedLifecycle<P, S> {\nCalled immediately before mounting occurs, and before {@link Component.render}.\nAvoid introducing any side-effects or subscriptions in this method.\n* Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate}\nor {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents\nthis from being invoked.\n* @deprecated 16.3, use {@link ComponentLifecycle.componentDidMount componentDidMount} or the constructor instead; will stop working in React 17\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#initializing-state}\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path}\n         \n        componentWillMount?(): void;\nCalled immediately before mounting occurs, and before {@link Component.render}.\nAvoid introducing any side-effects or subscriptions in this method.\n* This method will not stop working in React 17.\n* Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate}\nor {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents\nthis from being invoked.\n* @deprecated 16.3, use {@link ComponentLifecycle.componentDidMount componentDidMount} or the constructor instead\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#initializing-state}\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path}\n         \n        UNSAFE_componentWillMount?(): void;\nCalled when the component may be receiving new props.\nReact may call this even if props have not changed, so be sure to compare new and existing\nprops if you only want to handle changes.\n* Calling {@link Component.setState} generally does not trigger this method.\n* Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate}\nor {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents\nthis from being invoked.\n* @deprecated 16.3, use static {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} instead; will stop working in React 17\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#updating-state-based-on-props}\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path}\n         \n        componentWillReceiveProps?(nextProps: Readonly<P>, nextContext: any): void;\nCalled when the component may be receiving new props.\nReact may call this even if props have not changed, so be sure to compare new and existing\nprops if you only want to handle changes.\n* Calling {@link Component.setState} generally does not trigger this method.\n* This method will not stop working in React 17.\n* Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate}\nor {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents\nthis from being invoked.\n* @deprecated 16.3, use static {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} instead\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#updating-state-based-on-props}\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path}\n         \n        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<P>, nextContext: any): void;\nCalled immediately before rendering when new props or state is received. Not called for the initial render.\n* Note: You cannot call {@link Component.setState} here.\n* Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate}\nor {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents\nthis from being invoked.\n* @deprecated 16.3, use getSnapshotBeforeUpdate instead; will stop working in React 17\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#reading-dom-properties-before-an-update}\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path}\n         \n        componentWillUpdate?(nextProps: Readonly<P>, nextState: Readonly<S>, nextContext: any): void;\nCalled immediately before rendering when new props or state is received. Not called for the initial render.\n* Note: You cannot call {@link Component.setState} here.\n* This method will not stop working in React 17.\n* Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate}\nor {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents\nthis from being invoked.\n* @deprecated 16.3, use getSnapshotBeforeUpdate instead\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#reading-dom-properties-before-an-update}\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path}\n         \n        UNSAFE_componentWillUpdate?(nextProps: Readonly<P>, nextState: Readonly<S>, nextContext: any): void;\n    }\n\n    function createRef<T>(): RefObject<T | null>;\nThe type of the component returned from {@link forwardRef}.\n* @template P The props the component accepts, if any.\n* @see {@link ExoticComponent}\n     \n    interface ForwardRefExoticComponent<P> extends NamedExoticComponent<P> {\nIgnored by React.\n@deprecated Only kept in types for backwards compatibility. Will be removed in a future major release.\n         \n        propTypes?: any;\n    }\nLets your component expose a DOM node to a parent component\nusing a ref.\n* @see {@link https://react.dev/reference/react/forwardRef React Docs}\n@see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/forward_and_create_ref/ React TypeScript Cheatsheet}\n* @param render See the {@link ForwardRefRenderFunction}.\n* @template T The type of the DOM node.\n@template P The props the component accepts, if any.\n* @example\n* ```tsx\ninterface Props {\nchildren?: ReactNode;\ntype: \"submit\" | \"button\";\n}\n* export const FancyButton = forwardRef<HTMLButtonElement, Props>((props, ref) => (\n<button ref={ref} className=\"MyClassName\" type={props.type}>\n{props.children}\n</button>\n));\n```\n     \n    function forwardRef<T, P = {}>(\n        render: ForwardRefRenderFunction<T, PropsWithoutRef<P>>,\n    ): ForwardRefExoticComponent<PropsWithoutRef<P> & RefAttributes<T>>;\nOmits the 'ref' attribute from the given props object.\n* @template Props The props object type.\n     \n    type PropsWithoutRef<Props> =\n        // Omit would not be sufficient for this. We'd like to avoid unnecessary mapping and need a distributive conditional to support unions.\n        // see: https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types\n        // https://github.com/Microsoft/TypeScript/issues/28339\n        Props extends any ? (\"ref\" extends keyof Props ? Omit<Props, \"ref\"> : Props) : Props;\nEnsures that the props do not include string ref, which cannot be forwarded\n@deprecated Use `Props` directly. `PropsWithRef<Props>` is just an alias for `Props`\n     \n    type PropsWithRef<Props> = Props;\n\n    type PropsWithChildren<P = unknown> = P & { children?: ReactNode | undefined };\nUsed to retrieve the props a component accepts. Can either be passed a string,\nindicating a DOM element (e.g. 'div', 'span', etc.) or the type of a React\ncomponent.\n* It's usually better to use {@link ComponentPropsWithRef} or {@link ComponentPropsWithoutRef}\ninstead of this type, as they let you be explicit about whether or not to include\nthe `ref` prop.\n* @see {@link https://react-typescript-cheatsheet.netlify.app/docs/react-types/componentprops/ React TypeScript Cheatsheet}\n* @example\n* ```tsx\n// Retrieves the props an 'input' element accepts\ntype InputProps = React.ComponentProps<'input'>;\n```\n* @example\n* ```tsx\nconst MyComponent = (props: { foo: number, bar: string }) => <div />;\n* // Retrieves the props 'MyComponent' accepts\ntype MyComponentProps = React.ComponentProps<typeof MyComponent>;\n```\n     \n    type ComponentProps<T extends keyof JSX.IntrinsicElements | JSXElementConstructor<any>> = T extends\n        JSXElementConstructor<infer Props> ? Props\n        : T extends keyof JSX.IntrinsicElements ? JSX.IntrinsicElements[T]\n        : {};\nUsed to retrieve the props a component accepts with its ref. Can either be\npassed a string, indicating a DOM element (e.g. 'div', 'span', etc.) or the\ntype of a React component.\n* @see {@link https://react-typescript-cheatsheet.netlify.app/docs/react-types/componentprops/ React TypeScript Cheatsheet}\n* @example\n* ```tsx\n// Retrieves the props an 'input' element accepts\ntype InputProps = React.ComponentPropsWithRef<'input'>;\n```\n* @example\n* ```tsx\nconst MyComponent = (props: { foo: number, bar: string }) => <div />;\n* // Retrieves the props 'MyComponent' accepts\ntype MyComponentPropsWithRef = React.ComponentPropsWithRef<typeof MyComponent>;\n```\n     \n    type ComponentPropsWithRef<T extends ElementType> = T extends JSXElementConstructor<infer Props>\n        // If it's a class i.e. newable we're dealing with a class component\n        ? T extends abstract new(args: any) => any ? PropsWithoutRef<Props> & RefAttributes<InstanceType<T>>\n        : Props\n        : ComponentProps<T>;\nUsed to retrieve the props a custom component accepts with its ref.\n* Unlike {@link ComponentPropsWithRef}, this only works with custom\ncomponents, i.e. components you define yourself. This is to improve\ntype-checking performance.\n* @example\n* ```tsx\nconst MyComponent = (props: { foo: number, bar: string }) => <div />;\n* // Retrieves the props 'MyComponent' accepts\ntype MyComponentPropsWithRef = React.CustomComponentPropsWithRef<typeof MyComponent>;\n```\n     \n    type CustomComponentPropsWithRef<T extends ComponentType> = T extends JSXElementConstructor<infer Props>\n        // If it's a class i.e. newable we're dealing with a class component\n        ? T extends abstract new(args: any) => any ? PropsWithoutRef<Props> & RefAttributes<InstanceType<T>>\n        : Props\n        : never;\nUsed to retrieve the props a component accepts without its ref. Can either be\npassed a string, indicating a DOM element (e.g. 'div', 'span', etc.) or the\ntype of a React component.\n* @see {@link https://react-typescript-cheatsheet.netlify.app/docs/react-types/componentprops/ React TypeScript Cheatsheet}\n* @example\n* ```tsx\n// Retrieves the props an 'input' element accepts\ntype InputProps = React.ComponentPropsWithoutRef<'input'>;\n```\n* @example\n* ```tsx\nconst MyComponent = (props: { foo: number, bar: string }) => <div />;\n* // Retrieves the props 'MyComponent' accepts\ntype MyComponentPropsWithoutRef = React.ComponentPropsWithoutRef<typeof MyComponent>;\n```\n     \n    type ComponentPropsWithoutRef<T extends ElementType> = PropsWithoutRef<ComponentProps<T>>;\nRetrieves the type of the 'ref' prop for a given component type or tag name.\n* @template C The component type.\n* @example\n* ```tsx\ntype MyComponentRef = React.ComponentRef<typeof MyComponent>;\n```\n* @example\n* ```tsx\ntype DivRef = React.ComponentRef<'div'>;\n```\n     \n    type ComponentRef<T extends ElementType> = ComponentPropsWithRef<T> extends RefAttributes<infer Method> ? Method\n        : never;\n\n    // will show `Memo(${Component.displayName || Component.name})` in devtools by default,\n    // but can be given its own specific name\n    type MemoExoticComponent<T extends ComponentType<any>> = NamedExoticComponent<CustomComponentPropsWithRef<T>> & {\n        readonly type: T;\n    };\nLets you skip re-rendering a component when its props are unchanged.\n* @see {@link https://react.dev/reference/react/memo React Docs}\n* @param Component The component to memoize.\n@param propsAreEqual A function that will be used to determine if the props have changed.\n* @example\n* ```tsx\nimport { memo } from 'react';\n* const SomeComponent = memo(function SomeComponent(props: { foo: string }) {\n// ...\n});\n```\n     \n    function memo<P extends object>(\n        Component: FunctionComponent<P>,\n        propsAreEqual?: (prevProps: Readonly<P>, nextProps: Readonly<P>) => boolean,\n    ): NamedExoticComponent<P>;\n    function memo<T extends ComponentType<any>>(\n        Component: T,\n        propsAreEqual?: (prevProps: Readonly<ComponentProps<T>>, nextProps: Readonly<ComponentProps<T>>) => boolean,\n    ): MemoExoticComponent<T>;\n\n    interface LazyExoticComponent<T extends ComponentType<any>>\n        extends ExoticComponent<CustomComponentPropsWithRef<T>>\n    {\n        readonly _result: T;\n    }\nLets you defer loading a component’s code until it is rendered for the first time.\n* @see {@link https://react.dev/reference/react/lazy React Docs}\n* @param load A function that returns a `Promise` or another thenable (a `Promise`-like object with a\nthen method). React will not call `load` until the first time you attempt to render the returned\ncomponent. After React first calls load, it will wait for it to resolve, and then render the\nresolved value’s `.default` as a React component. Both the returned `Promise` and the `Promise`’s\nresolved value will be cached, so React will not call load more than once. If the `Promise` rejects,\nReact will throw the rejection reason for the nearest Error Boundary to handle.\n* @example\n* ```tsx\nimport { lazy } from 'react';\n* const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));\n```\n     \n    function lazy<T extends ComponentType<any>>(\n        load: () => Promise<{ default: T }>,\n    ): LazyExoticComponent<T>;\n\n    //\n    // React Hooks\n    // ----------------------------------------------------------------------\nThe instruction passed to a {@link Dispatch} function in {@link useState}\nto tell React what the next value of the {@link useState} should be.\n* Often found wrapped in {@link Dispatch}.\n* @template S The type of the state.\n* @example\n* ```tsx\n// This return type correctly represents the type of\n// `setCount` in the example below.\nconst useCustomState = (): Dispatch<SetStateAction<number>> => {\nconst [count, setCount] = useState(0);\n*   return setCount;\n}\n```\n     \n    type SetStateAction<S> = S | ((prevState: S) => S);\nA function that can be used to update the state of a {@link useState}\nor {@link useReducer} hook.\n     \n    type Dispatch<A> = (value: A) => void;\nA {@link Dispatch} function can sometimes be called without any arguments.\n     \n    type DispatchWithoutAction = () => void;\n    // Limit the reducer to accept only 0 or 1 action arguments\n    // eslint-disable-next-line @definitelytyped/no-single-element-tuple-type\n    type AnyActionArg = [] | [any];\n    // Get the dispatch type from the reducer arguments (captures optional action argument correctly)\n    type ActionDispatch<ActionArg extends AnyActionArg> = (...args: ActionArg) => void;\n    // Unlike redux, the actions _can_ be anything\n    type Reducer<S, A> = (prevState: S, action: A) => S;\n    // If useReducer accepts a reducer without action, dispatch may be called without any parameters.\n    type ReducerWithoutAction<S> = (prevState: S) => S;\n    // types used to try and prevent the compiler from reducing S\n    // to a supertype common with the second argument to useReducer()\n    type ReducerState<R extends Reducer<any, any>> = R extends Reducer<infer S, any> ? S : never;\n    type DependencyList = readonly unknown[];\n\n    // NOTE: callbacks are _only_ allowed to return either void, or a destructor.\n    type EffectCallback = () => void | Destructor;\n@deprecated Use `RefObject` instead.\n     \n    interface MutableRefObject<T> {\n        current: T;\n    }\n\n    // This will technically work if you give a Consumer<T> or Provider<T> but it's deprecated and warns\nAccepts a context object (the value returned from `React.createContext`) and returns the current\ncontext value, as given by the nearest context provider for the given context.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useContext}\n     \n    function useContext<T>(context: Context<T> /*, (not public API) observedBits?: number|boolean ): T;\nReturns a stateful value, and a function to update it.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useState}\n     \n    function useState<S>(initialState: S | (() => S)): [S, Dispatch<SetStateAction<S>>];\n    // convenience overload when first argument is omitted\nReturns a stateful value, and a function to update it.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useState}\n     \n    function useState<S = undefined>(): [S | undefined, Dispatch<SetStateAction<S | undefined>>];\nAn alternative to `useState`.\n* `useReducer` is usually preferable to `useState` when you have complex state logic that involves\nmultiple sub-values. It also lets you optimize performance for components that trigger deep\nupdates because you can pass `dispatch` down instead of callbacks.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useReducer}\n     \n    function useReducer<S, A extends AnyActionArg>(\n        reducer: (prevState: S, ...args: A) => S,\n        initialState: S,\n    ): [S, ActionDispatch<A>];\nAn alternative to `useState`.\n* `useReducer` is usually preferable to `useState` when you have complex state logic that involves\nmultiple sub-values. It also lets you optimize performance for components that trigger deep\nupdates because you can pass `dispatch` down instead of callbacks.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useReducer}\n     \n    function useReducer<S, A extends AnyActionArg>(\n        reducer: (prevState: S, ...args: A) => S,\n        initialState: S,\n    ): [S, ActionDispatch<A>];\nAn alternative to `useState`.\n* `useReducer` is usually preferable to `useState` when you have complex state logic that involves\nmultiple sub-values. It also lets you optimize performance for components that trigger deep\nupdates because you can pass `dispatch` down instead of callbacks.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useReducer}\n     \n    function useReducer<S, I, A extends AnyActionArg>(\n        reducer: (prevState: S, ...args: A) => S,\n        initialArg: I,\n        init: (i: I) => S,\n    ): [S, ActionDispatch<A>];\n`useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument\n(`initialValue`). The returned object will persist for the full lifetime of the component.\n* Note that `useRef()` is useful for more than the `ref` attribute. It’s handy for keeping any mutable\nvalue around similar to how you’d use instance fields in classes.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useRef}\n     \n    function useRef<T>(initialValue: T): RefObject<T>;\n    // convenience overload for refs given as a ref prop as they typically start with a null value\n`useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument\n(`initialValue`). The returned object will persist for the full lifetime of the component.\n* Note that `useRef()` is useful for more than the `ref` attribute. It’s handy for keeping any mutable\nvalue around similar to how you’d use instance fields in classes.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useRef}\n     \n    function useRef<T>(initialValue: T | null): RefObject<T | null>;\n    // convenience overload for undefined initialValue\n`useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument\n(`initialValue`). The returned object will persist for the full lifetime of the component.\n* Note that `useRef()` is useful for more than the `ref` attribute. It’s handy for keeping any mutable\nvalue around similar to how you’d use instance fields in classes.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useRef}\n     \n    function useRef<T>(initialValue: T | undefined): RefObject<T | undefined>;\nThe signature is identical to `useEffect`, but it fires synchronously after all DOM mutations.\nUse this to read layout from the DOM and synchronously re-render. Updates scheduled inside\n`useLayoutEffect` will be flushed synchronously, before the browser has a chance to paint.\n* Prefer the standard `useEffect` when possible to avoid blocking visual updates.\n* If you’re migrating code from a class component, `useLayoutEffect` fires in the same phase as\n`componentDidMount` and `componentDidUpdate`.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useLayoutEffect}\n     \n    function useLayoutEffect(effect: EffectCallback, deps?: DependencyList): void;\nAccepts a function that contains imperative, possibly effectful code.\n* @param effect Imperative function that can return a cleanup function\n@param deps If present, effect will only activate if the values in the list change.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useEffect}\n     \n    function useEffect(effect: EffectCallback, deps?: DependencyList): void;\n    // NOTE: this does not accept strings, but this will have to be fixed by removing strings from type Ref<T>\n`useImperativeHandle` customizes the instance value that is exposed to parent components when using\n`ref`. As always, imperative code using refs should be avoided in most cases.\n* `useImperativeHandle` should be used with `React.forwardRef`.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useImperativeHandle}\n     \n    function useImperativeHandle<T, R extends T>(ref: Ref<T> | undefined, init: () => R, deps?: DependencyList): void;\n    // I made 'inputs' required here and in useMemo as there's no point to memoizing without the memoization key\n    // useCallback(X) is identical to just using X, useMemo(() => Y) is identical to just using Y.\n`useCallback` will return a memoized version of the callback that only changes if one of the `inputs`\nhas changed.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useCallback}\n     \n    // A specific function type would not trigger implicit any.\n    // See https://github.com/DefinitelyTyped/DefinitelyTyped/issues/52873#issuecomment-845806435 for a comparison between `Function` and more specific types.\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n    function useCallback<T extends Function>(callback: T, deps: DependencyList): T;\n`useMemo` will only recompute the memoized value when one of the `deps` has changed.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useMemo}\n     \n    // allow undefined, but don't make it optional as that is very likely a mistake\n    function useMemo<T>(factory: () => T, deps: DependencyList): T;\n`useDebugValue` can be used to display a label for custom hooks in React DevTools.\n* NOTE: We don’t recommend adding debug values to every custom hook.\nIt’s most valuable for custom hooks that are part of shared libraries.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useDebugValue}\n     \n    // the name of the custom hook is itself derived from the function name at runtime:\n    // it's just the function name without the \"use\" prefix.\n    function useDebugValue<T>(value: T, format?: (value: T) => any): void;\n\n    export type TransitionFunction = () => VoidOrUndefinedOnly | Promise<VoidOrUndefinedOnly>;\n    // strange definition to allow vscode to show documentation on the invocation\n    export interface TransitionStartFunction {\nState updates caused inside the callback are allowed to be deferred.\n* **If some state update causes a component to suspend, that state update should be wrapped in a transition.**\n* @param callback A function which causes state updates that can be deferred.\n         \n        (callback: TransitionFunction): void;\n    }\nReturns a deferred version of the value that may “lag behind” it.\n* This is commonly used to keep the interface responsive when you have something that renders immediately\nbased on user input and something that needs to wait for a data fetch.\n* A good example of this is a text input.\n* @param value The value that is going to be deferred\n@param initialValue A value to use during the initial render of a component. If this option is omitted, `useDeferredValue` will not defer during the initial render, because there’s no previous version of `value` that it can render instead.\n* @see {@link https://react.dev/reference/react/useDeferredValue}",
    "packageType": "javascript"
  },
  {
    "objectName": "useDeferredValue",
    "signature": "useDeferredValue: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/useDeferredValue",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "useDeferredValue: any",
    "documentation": "Exported variable useDeferredValue",
    "description": "Added new variable useDeferredValue",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable useDeferredValue\n\nNew source code:\n\n```typescript\nuseDeferredValue: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable useDeferredValue",
    "packageType": "javascript"
  },
  {
    "objectName": "useDeferredValue",
    "signature": "property useDeferredValue",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/useDeferredValue",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property useDeferredValue",
    "documentation": "Property useDeferredValue",
    "description": "Added new property useDeferredValue",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty useDeferredValue\n\nNew source code:\n\n```typescript\nproperty useDeferredValue\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property useDeferredValue",
    "packageType": "javascript"
  },
  {
    "objectName": "useEffect",
    "signature": "function useEffect",
    "objectType": "function",
    "objectIdentifier": "react/cjs/react/development/useEffect",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function useEffect",
    "documentation": "Module: cjs/react.development",
    "description": "Added new function useEffect",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nModule: cjs/react.development\n\nNew source code:\n\n```typescript\nfunction useEffect\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Module: cjs/react.development",
    "packageType": "javascript"
  },
  {
    "objectName": "useEffect",
    "signature": "useEffect: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/useEffect",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "useEffect: any",
    "documentation": "Exported variable useEffect",
    "description": "Added new variable useEffect",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable useEffect\n\nNew source code:\n\n```typescript\nuseEffect: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable useEffect",
    "packageType": "javascript"
  },
  {
    "objectName": "useEffect",
    "signature": "property useEffect",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/useEffect",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property useEffect",
    "documentation": "Property useEffect",
    "description": "Added new property useEffect",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty useEffect\n\nNew source code:\n\n```typescript\nproperty useEffect\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property useEffect",
    "packageType": "javascript"
  },
  {
    "objectName": "useId",
    "signature": "function useId",
    "objectType": "function",
    "objectIdentifier": "react/functions/useId",
    "packagePath": "react",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function useId",
    "documentation": "",
    "description": "Added new function useId",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nFunction useId from react.\n\nSignature: function useId\n\nNew source code:\n\n```typescript\nfunction useId\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Function useId from react.\n\nSignature: function useId",
    "packageType": "javascript"
  },
  {
    "objectName": "useId",
    "signature": "useId: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/useId",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "useId: any",
    "documentation": "Exported variable useId",
    "description": "Added new variable useId",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable useId\n\nNew source code:\n\n```typescript\nuseId: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable useId",
    "packageType": "javascript"
  },
  {
    "objectName": "useId",
    "signature": "property useId",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/useId",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property useId",
    "documentation": "Property useId",
    "description": "Added new property useId",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty useId\n\nNew source code:\n\n```typescript\nproperty useId\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property useId",
    "packageType": "javascript"
  },
  {
    "objectName": "useImperativeHandle",
    "signature": "function useImperativeHandle",
    "objectType": "function",
    "objectIdentifier": "react/cjs/react/development/useImperativeHandle",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function useImperativeHandle",
    "documentation": "Module: cjs/react.development",
    "description": "Added new function useImperativeHandle",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nModule: cjs/react.development\n\nNew source code:\n\n```typescript\nfunction useImperativeHandle\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Module: cjs/react.development",
    "packageType": "javascript"
  },
  {
    "objectName": "useImperativeHandle",
    "signature": "useImperativeHandle: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/useImperativeHandle",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "useImperativeHandle: any",
    "documentation": "Exported variable useImperativeHandle",
    "description": "Added new variable useImperativeHandle",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable useImperativeHandle\n\nNew source code:\n\n```typescript\nuseImperativeHandle: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable useImperativeHandle",
    "packageType": "javascript"
  },
  {
    "objectName": "useImperativeHandle",
    "signature": "property useImperativeHandle",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/useImperativeHandle",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property useImperativeHandle",
    "documentation": "Property useImperativeHandle",
    "description": "Added new property useImperativeHandle",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty useImperativeHandle\n\nNew source code:\n\n```typescript\nproperty useImperativeHandle\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property useImperativeHandle",
    "packageType": "javascript"
  },
  {
    "objectName": "useInsertionEffect",
    "signature": "function useInsertionEffect",
    "objectType": "function",
    "objectIdentifier": "react/functions/useInsertionEffect",
    "packagePath": "react",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function useInsertionEffect",
    "documentation": "Used to represent DOM API's where users can either pass true or false as a boolean or as its equivalent strings. type Booleanish = boolean | \"true\" | \"false\"; @see {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/crossorigin MDN} type CrossOrigin = \"anonymous\" | \"use-credentials\" | \"\" | undefined; declare const UNDEFINED_VOID_ONLY: unique symbol; @internal Use `Awaited<ReactNode>` instead // Helper type to enable `Awaited<ReactNode>`. // Must be a copy of the non-thenables of `ReactNode`. type AwaitedReactNode = | React.ReactElement | string | number | bigint | Iterable<React.ReactNode> | React.ReactPortal | boolean | null | undefined | React.DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES[ keyof React.DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES ]; The function returned from an effect passed to {@link React.useEffect useEffect}, which can be used to clean up the effect when the component unmounts. * @see {@link https://react.dev/reference/react/useEffect React Docs} type Destructor = () => void | { [UNDEFINED_VOID_ONLY]: never }; type VoidOrUndefinedOnly = void | { [UNDEFINED_VOID_ONLY]: never }; // eslint-disable-next-line @definitelytyped/export-just-namespace export = React; export as namespace React; declare namespace React { // // React Elements // ---------------------------------------------------------------------- Used to retrieve the possible components which accept a given set of props. * Can be passed no type parameters to get a union of all possible components and tags. * Is a superset of {@link ComponentType}. * @template P The props to match against. If not passed, defaults to any. @template Tag An optional tag to match against. If not passed, attempts to match against all possible tags. * @example * ```tsx // All components and tags (img, embed etc.) // which accept `src` type SrcComponents = ElementType<{ src: any }>; ``` * @example * ```tsx // All components type AllComponents = ElementType; ``` * @example * ```tsx // All custom components which match `src`, and tags which // match `src`, narrowed down to just `audio` and `embed` type SrcComponents = ElementType<{ src: any }, 'audio' | 'embed'>; ``` type ElementType<P = any, Tag extends keyof JSX.IntrinsicElements = keyof JSX.IntrinsicElements> = | { [K in Tag]: P extends JSX.IntrinsicElements[K] ? K : never }[Tag] | ComponentType<P>; Represents any user-defined component, either as a function or a class. * Similar to {@link JSXElementConstructor}, but with extra properties like {@link FunctionComponent.defaultProps defaultProps }. * @template P The props the component accepts. * @see {@link ComponentClass} @see {@link FunctionComponent} type ComponentType<P = {}> = ComponentClass<P> | FunctionComponent<P>; Represents any user-defined component, either as a function or a class. * Similar to {@link ComponentType}, but without extra properties like {@link FunctionComponent.defaultProps defaultProps }. * @template P The props the component accepts. type JSXElementConstructor<P> = | (( props: P, ) => ReactNode | Promise<ReactNode>) // constructor signature must match React.Component | (new(props: P) => Component<any, any>); Created by {@link createRef}, or {@link useRef} when passed `null`. * @template T The type of the ref's value. * @example * ```tsx const ref = createRef<HTMLDivElement>(); * ref.current = document.createElement('div'); // Error ``` interface RefObject<T> { The current value of the ref. current: T; } interface DO_NOT_USE_OR_YOU_WILL_BE_FIRED_CALLBACK_REF_RETURN_VALUES { } A callback fired whenever the ref's value changes. * @template T The type of the ref's value. * @see {@link https://react.dev/reference/react-dom/components/common#ref-callback React Docs} * @example * ```tsx <div ref={(node) => console.log(node)} /> ``` type RefCallback<T> = { bivarianceHack( instance: T | null, ): | void | (() => VoidOrUndefinedOnly) | DO_NOT_USE_OR_YOU_WILL_BE_FIRED_CALLBACK_REF_RETURN_VALUES[ keyof DO_NOT_USE_OR_YOU_WILL_BE_FIRED_CALLBACK_REF_RETURN_VALUES ]; }[\"bivarianceHack\"]; A union type of all possible shapes for React refs. * @see {@link RefCallback} @see {@link RefObject} type Ref<T> = RefCallback<T> | RefObject<T | null> | null; @deprecated Use `Ref` instead. String refs are no longer supported. If you're typing a library with support for React versions with string refs, use `RefAttributes<T>['ref']` instead. type LegacyRef<T> = Ref<T>; @deprecated Use `ComponentRef<T>` instead * Retrieves the type of the 'ref' prop for a given component type or tag name. * @template C The component type. * @example * ```tsx type MyComponentRef = React.ElementRef<typeof MyComponent>; ``` * @example * ```tsx type DivRef = React.ElementRef<'div'>; ``` type ElementRef< C extends | ForwardRefExoticComponent<any> | { new(props: any): Component<any> } | ((props: any) => ReactNode) | keyof JSX.IntrinsicElements, > = ComponentRef<C>; type ComponentState = any; A value which uniquely identifies a node among items in an array. * @see {@link https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key React Docs} type Key = string | number | bigint; @internal The props any component can receive. You don't have to add this type. All components automatically accept these props. ```tsx const Component = () => <div />; <Component key=\"one\" /> ``` * WARNING: The implementation of a component will never have access to these attributes. The following example would be incorrect usage because {@link Component} would never have access to `key`: ```tsx const Component = (props: React.Attributes) => props.key; ``` interface Attributes { key?: Key | null | undefined; } The props any component accepting refs can receive. Class components, built-in browser components (e.g. `div`) and forwardRef components can receive refs and automatically accept these props. ```tsx const Component = forwardRef(() => <div />); <Component ref={(current) => console.log(current)} /> ``` * You only need this type if you manually author the types of props that need to be compatible with legacy refs. ```tsx interface Props extends React.RefAttributes<HTMLDivElement> {} declare const Component: React.FunctionComponent<Props>; ``` * Otherwise it's simpler to directly use {@link Ref} since you can safely use the props type to describe to props that a consumer can pass to the component as well as describing the props the implementation of a component \"sees\". {@link RefAttributes} is generally not safe to describe both consumer and seen props. * ```tsx interface Props extends { ref?: React.Ref<HTMLDivElement> | undefined; } declare const Component: React.FunctionComponent<Props>; ``` * WARNING: The implementation of a component will not have access to the same type in versions of React supporting string refs. The following example would be incorrect usage because {@link Component} would never have access to a `ref` with type `string` ```tsx const Component = (props: React.RefAttributes) => props.ref; ``` interface RefAttributes<T> extends Attributes { Allows getting a ref to the component instance. Once the component unmounts, React will set `ref.current` to `null` (or call the ref with `null` if you passed a callback ref). * @see {@link https://react.dev/learn/referencing-values-with-refs#refs-and-the-dom React Docs} ref?: Ref<T> | undefined; } Represents the built-in attributes available to class components. interface ClassAttributes<T> extends RefAttributes<T> { } Represents a JSX element. * Where {@link ReactNode} represents everything that can be rendered, `ReactElement` only represents JSX. * @template P The type of the props object @template T The type of the component or tag * @example * ```tsx const element: ReactElement = <div />; ``` interface ReactElement< P = unknown, T extends string | JSXElementConstructor<any> = string | JSXElementConstructor<any>, > { type: T; props: P; key: string | null; } @deprecated interface ReactComponentElement< T extends keyof JSX.IntrinsicElements | JSXElementConstructor<any>, P = Pick<ComponentProps<T>, Exclude<keyof ComponentProps<T>, \"key\" | \"ref\">>, > extends ReactElement<P, Exclude<T, number>> {} @deprecated Use `ReactElement<P, React.FunctionComponent<P>>` interface FunctionComponentElement<P> extends ReactElement<P, FunctionComponent<P>> { @deprecated Use `element.props.ref` instead. ref?: (\"ref\" extends keyof P ? P extends { ref?: infer R | undefined } ? R : never : never) | undefined; } @deprecated Use `ReactElement<P, React.ComponentClass<P>>` type CElement<P, T extends Component<P, ComponentState>> = ComponentElement<P, T>; @deprecated Use `ReactElement<P, React.ComponentClass<P>>` interface ComponentElement<P, T extends Component<P, ComponentState>> extends ReactElement<P, ComponentClass<P>> { @deprecated Use `element.props.ref` instead. ref?: Ref<T> | undefined; } @deprecated Use {@link ComponentElement} instead. type ClassicElement<P> = CElement<P, ClassicComponent<P, ComponentState>>; // string fallback for custom web-components @deprecated Use `ReactElement<P, string>` interface DOMElement<P extends HTMLAttributes<T> | SVGAttributes<T>, T extends Element> extends ReactElement<P, string> { @deprecated Use `element.props.ref` instead. ref: Ref<T>; } // ReactHTML for ReactHTMLElement interface ReactHTMLElement<T extends HTMLElement> extends DetailedReactHTMLElement<AllHTMLAttributes<T>, T> {} interface DetailedReactHTMLElement<P extends HTMLAttributes<T>, T extends HTMLElement> extends DOMElement<P, T> { type: HTMLElementType; } // ReactSVG for ReactSVGElement interface ReactSVGElement extends DOMElement<SVGAttributes<SVGElement>, SVGElement> { type: SVGElementType; } interface ReactPortal extends ReactElement { children: ReactNode; } Different release channels declare additional types of ReactNode this particular release channel accepts. App or library types should never augment this interface. interface DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES {} Represents all of the things React can render. * Where {@link ReactElement} only represents JSX, `ReactNode` represents everything that can be rendered. * @see {@link https://react-typescript-cheatsheet.netlify.app/docs/react-types/reactnode/ React TypeScript Cheatsheet} * @example * ```tsx // Typing children type Props = { children: ReactNode } * const Component = ({ children }: Props) => <div>{children}</div> * <Component>hello</Component> ``` * @example * ```tsx // Typing a custom element type Props = { customElement: ReactNode } * const Component = ({ customElement }: Props) => <div>{customElement}</div> * <Component customElement={<div>hello</div>} /> ``` // non-thenables need to be kept in sync with AwaitedReactNode type ReactNode = | ReactElement | string | number | bigint | Iterable<ReactNode> | ReactPortal | boolean | null | undefined | DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES[ keyof DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES ] | Promise<AwaitedReactNode>; // // Top Level API // ---------------------------------------------------------------------- // DOM Elements // TODO: generalize this to everything in `keyof ReactHTML`, not just \"input\" function createElement( type: \"input\", props?: InputHTMLAttributes<HTMLInputElement> & ClassAttributes<HTMLInputElement> | null, ...children: ReactNode[] ): DetailedReactHTMLElement<InputHTMLAttributes<HTMLInputElement>, HTMLInputElement>; function createElement<P extends HTMLAttributes<T>, T extends HTMLElement>( type: HTMLElementType, props?: ClassAttributes<T> & P | null, ...children: ReactNode[] ): DetailedReactHTMLElement<P, T>; function createElement<P extends SVGAttributes<T>, T extends SVGElement>( type: SVGElementType, props?: ClassAttributes<T> & P | null, ...children: ReactNode[] ): ReactSVGElement; function createElement<P extends DOMAttributes<T>, T extends Element>( type: string, props?: ClassAttributes<T> & P | null, ...children: ReactNode[] ): DOMElement<P, T>; // Custom components function createElement<P extends {}>( type: FunctionComponent<P>, props?: Attributes & P | null, ...children: ReactNode[] ): FunctionComponentElement<P>; function createElement<P extends {}, T extends Component<P, ComponentState>, C extends ComponentClass<P>>( type: ClassType<P, T, C>, props?: ClassAttributes<T> & P | null, ...children: ReactNode[] ): CElement<P, T>; function createElement<P extends {}>( type: FunctionComponent<P> | ComponentClass<P> | string, props?: Attributes & P | null, ...children: ReactNode[] ): ReactElement<P>; // DOM Elements // ReactHTMLElement function cloneElement<P extends HTMLAttributes<T>, T extends HTMLElement>( element: DetailedReactHTMLElement<P, T>, props?: P, ...children: ReactNode[] ): DetailedReactHTMLElement<P, T>; // ReactHTMLElement, less specific function cloneElement<P extends HTMLAttributes<T>, T extends HTMLElement>( element: ReactHTMLElement<T>, props?: P, ...children: ReactNode[] ): ReactHTMLElement<T>; // SVGElement function cloneElement<P extends SVGAttributes<T>, T extends SVGElement>( element: ReactSVGElement, props?: P, ...children: ReactNode[] ): ReactSVGElement; // DOM Element (has to be the last, because type checking stops at first overload that fits) function cloneElement<P extends DOMAttributes<T>, T extends Element>( element: DOMElement<P, T>, props?: DOMAttributes<T> & P, ...children: ReactNode[] ): DOMElement<P, T>; // Custom components function cloneElement<P>( element: FunctionComponentElement<P>, props?: Partial<P> & Attributes, ...children: ReactNode[] ): FunctionComponentElement<P>; function cloneElement<P, T extends Component<P, ComponentState>>( element: CElement<P, T>, props?: Partial<P> & ClassAttributes<T>, ...children: ReactNode[] ): CElement<P, T>; function cloneElement<P>( element: ReactElement<P>, props?: Partial<P> & Attributes, ...children: ReactNode[] ): ReactElement<P>; Describes the props accepted by a Context {@link Provider}. * @template T The type of the value the context provides. interface ProviderProps<T> { value: T; children?: ReactNode | undefined; } Describes the props accepted by a Context {@link Consumer}. * @template T The type of the value the context provides. interface ConsumerProps<T> { children: (value: T) => ReactNode; } An object masquerading as a component. These are created by functions like {@link forwardRef}, {@link memo}, and {@link createContext}. * In order to make TypeScript work, we pretend that they are normal components. * But they are, in fact, not callable - instead, they are objects which are treated specially by the renderer. * @template P The props the component accepts. interface ExoticComponent<P = {}> { (props: P): ReactNode; readonly $$typeof: symbol; } An {@link ExoticComponent} with a `displayName` property applied to it. * @template P The props the component accepts. interface NamedExoticComponent<P = {}> extends ExoticComponent<P> { Used in debugging messages. You might want to set it explicitly if you want to display a different name for debugging purposes. * @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs} displayName?: string | undefined; } An {@link ExoticComponent} with a `propTypes` property applied to it. * @template P The props the component accepts. interface ProviderExoticComponent<P> extends ExoticComponent<P> { } Used to retrieve the type of a context object from a {@link Context}. * @template C The context object. * @example * ```tsx import { createContext } from 'react'; * const MyContext = createContext({ foo: 'bar' }); * type ContextType = ContextType<typeof MyContext>; // ContextType = { foo: string } ``` type ContextType<C extends Context<any>> = C extends Context<infer T> ? T : never; Wraps your components to specify the value of this context for all components inside. * @see {@link https://react.dev/reference/react/createContext#provider React Docs} * @example * ```tsx import { createContext } from 'react'; * const ThemeContext = createContext('light'); * function App() { return ( <ThemeContext.Provider value=\"dark\"> <Toolbar /> </ThemeContext.Provider> ); } ``` type Provider<T> = ProviderExoticComponent<ProviderProps<T>>; The old way to read context, before {@link useContext} existed. * @see {@link https://react.dev/reference/react/createContext#consumer React Docs} * @example * ```tsx import { UserContext } from './user-context'; * function Avatar() { return ( <UserContext.Consumer> {user => <img src={user.profileImage} alt={user.name} />} </UserContext.Consumer> ); } ``` type Consumer<T> = ExoticComponent<ConsumerProps<T>>; Context lets components pass information deep down without explicitly passing props. * Created from {@link createContext} * @see {@link https://react.dev/learn/passing-data-deeply-with-context React Docs} @see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/context/ React TypeScript Cheatsheet} * @example * ```tsx import { createContext } from 'react'; * const ThemeContext = createContext('light'); ``` interface Context<T> extends Provider<T> { Provider: Provider<T>; Consumer: Consumer<T>; Used in debugging messages. You might want to set it explicitly if you want to display a different name for debugging purposes. * @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs} displayName?: string | undefined; } Lets you create a {@link Context} that components can provide or read. * @param defaultValue The value you want the context to have when there is no matching {@link Provider} in the tree above the component reading the context. This is meant as a \"last resort\" fallback. * @see {@link https://react.dev/reference/react/createContext#reference React Docs} @see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/context/ React TypeScript Cheatsheet} * @example * ```tsx import { createContext } from 'react'; * const ThemeContext = createContext('light'); function App() { return ( <ThemeContext value=\"dark\"> <Toolbar /> </ThemeContext> ); } ``` function createContext<T>( // If you thought this should be optional, see // https://github.com/DefinitelyTyped/DefinitelyTyped/pull/24509#issuecomment-382213106 defaultValue: T, ): Context<T>; function isValidElement<P>(object: {} | null | undefined): object is ReactElement<P>; const Children: { map<T, C>( children: C | readonly C[], fn: (child: C, index: number) => T, ): C extends null | undefined ? C : Array<Exclude<T, boolean | null | undefined>>; forEach<C>(children: C | readonly C[], fn: (child: C, index: number) => void): void; count(children: any): number; only<C>(children: C): C extends any[] ? never : C; toArray(children: ReactNode | ReactNode[]): Array<Exclude<ReactNode, boolean | null | undefined>>; }; export interface FragmentProps { children?: React.ReactNode; } Lets you group elements without a wrapper node. * @see {@link https://react.dev/reference/react/Fragment React Docs} * @example * ```tsx import { Fragment } from 'react'; * <Fragment> <td>Hello</td> <td>World</td> </Fragment> ``` * @example * ```tsx // Using the <></> shorthand syntax: * <> <td>Hello</td> <td>World</td> </> ``` const Fragment: ExoticComponent<FragmentProps>; Lets you find common bugs in your components early during development. * @see {@link https://react.dev/reference/react/StrictMode React Docs} * @example * ```tsx import { StrictMode } from 'react'; * <StrictMode> <App /> </StrictMode> ``` const StrictMode: ExoticComponent<{ children?: ReactNode | undefined }>; The props accepted by {@link Suspense}. * @see {@link https://react.dev/reference/react/Suspense React Docs} interface SuspenseProps { children?: ReactNode | undefined; A fallback react tree to show when a Suspense child (like React.lazy) suspends fallback?: ReactNode; A name for this Suspense boundary for instrumentation purposes. The name will help identify this boundary in React DevTools. name?: string | undefined; } Lets you display a fallback until its children have finished loading. * @see {@link https://react.dev/reference/react/Suspense React Docs} * @example * ```tsx import { Suspense } from 'react'; * <Suspense fallback={<Loading />}> <ProfileDetails /> </Suspense> ``` const Suspense: ExoticComponent<SuspenseProps>; const version: string; The callback passed to {@link ProfilerProps.onRender}. * @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs} type ProfilerOnRenderCallback = ( The string id prop of the {@link Profiler} tree that has just committed. This lets you identify which part of the tree was committed if you are using multiple profilers. * @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs} id: string, This lets you know whether the tree has just been mounted for the first time or re-rendered due to a change in props, state, or hooks. * @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs} phase: \"mount\" | \"update\" | \"nested-update\", The number of milliseconds spent rendering the {@link Profiler} and its descendants for the current update. This indicates how well the subtree makes use of memoization (e.g. {@link memo} and {@link useMemo}). Ideally this value should decrease significantly after the initial mount as many of the descendants will only need to re-render if their specific props change. * @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs} actualDuration: number, The number of milliseconds estimating how much time it would take to re-render the entire {@link Profiler} subtree without any optimizations. It is calculated by summing up the most recent render durations of each component in the tree. This value estimates a worst-case cost of rendering (e.g. the initial mount or a tree with no memoization). Compare {@link actualDuration} against it to see if memoization is working. * @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs} baseDuration: number, A numeric timestamp for when React began rendering the current update. * @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs} startTime: number, A numeric timestamp for when React committed the current update. This value is shared between all profilers in a commit, enabling them to be grouped if desirable. * @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs} commitTime: number, ) => void; The props accepted by {@link Profiler}. * @see {@link https://react.dev/reference/react/Profiler React Docs} interface ProfilerProps { children?: ReactNode | undefined; id: string; onRender: ProfilerOnRenderCallback; } Lets you measure rendering performance of a React tree programmatically. * @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs} * @example * ```tsx <Profiler id=\"App\" onRender={onRender}> <App /> </Profiler> ``` const Profiler: ExoticComponent<ProfilerProps>; // // Component API // ---------------------------------------------------------------------- type ReactInstance = Component<any> | Element; // Base component for plain JS classes interface Component<P = {}, S = {}, SS = any> extends ComponentLifecycle<P, S, SS> {} class Component<P, S> { If set, `this.context` will be set at runtime to the current value of the given Context. * @example * ```ts type MyContext = number const Ctx = React.createContext<MyContext>(0) * class Foo extends React.Component { static contextType = Ctx context!: React.ContextType<typeof Ctx> render () { return <>My context's value: {this.context}</>; } } ``` * @see {@link https://react.dev/reference/react/Component#static-contexttype} static contextType?: Context<any> | undefined; Ignored by React. @deprecated Only kept in types for backwards compatibility. Will be removed in a future major release. static propTypes?: any; If using the new style context, re-declare this in your class to be the `React.ContextType` of your `static contextType`. Should be used with type annotation or static contextType. * @example ```ts static contextType = MyContext // For TS pre-3.7: context!: React.ContextType<typeof MyContext> // For TS 3.7 and above: declare context: React.ContextType<typeof MyContext> ``` * @see {@link https://react.dev/reference/react/Component#context React Docs} context: unknown; // Keep in sync with constructor signature of JSXElementConstructor and ComponentClass. constructor(props: P); // We MUST keep setState() as a unified signature because it allows proper checking of the method return type. // See: https://github.com/DefinitelyTyped/DefinitelyTyped/issues/18365#issuecomment-351013257 // Also, the ` | S` allows intellisense to not be dumbisense setState<K extends keyof S>( state: ((prevState: Readonly<S>, props: Readonly<P>) => Pick<S, K> | S | null) | (Pick<S, K> | S | null), callback?: () => void, ): void; forceUpdate(callback?: () => void): void; render(): ReactNode; readonly props: Readonly<P>; state: Readonly<S>; } class PureComponent<P = {}, S = {}, SS = any> extends Component<P, S, SS> {} @deprecated Use `ClassicComponent` from `create-react-class` * @see {@link https://legacy.reactjs.org/docs/react-without-es6.html Legacy React Docs} @see {@link https://www.npmjs.com/package/create-react-class `create-react-class` on npm} interface ClassicComponent<P = {}, S = {}> extends Component<P, S> { replaceState(nextState: S, callback?: () => void): void; isMounted(): boolean; getInitialState?(): S; } // // Class Interfaces // ---------------------------------------------------------------------- Represents the type of a function component. Can optionally receive a type argument that represents the props the component receives. * @template P The props the component accepts. @see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/function_components React TypeScript Cheatsheet} @alias for {@link FunctionComponent} * @example * ```tsx // With props: type Props = { name: string } * const MyComponent: FC<Props> = (props) => { return <div>{props.name}</div> } ``` * @example * ```tsx // Without props: const MyComponentWithoutProps: FC = () => { return <div>MyComponentWithoutProps</div> } ``` type FC<P = {}> = FunctionComponent<P>; Represents the type of a function component. Can optionally receive a type argument that represents the props the component accepts. * @template P The props the component accepts. @see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/function_components React TypeScript Cheatsheet} * @example * ```tsx // With props: type Props = { name: string } * const MyComponent: FunctionComponent<Props> = (props) => { return <div>{props.name}</div> } ``` * @example * ```tsx // Without props: const MyComponentWithoutProps: FunctionComponent = () => { return <div>MyComponentWithoutProps</div> } ``` interface FunctionComponent<P = {}> { (props: P): ReactNode | Promise<ReactNode>; Ignored by React. @deprecated Only kept in types for backwards compatibility. Will be removed in a future major release. propTypes?: any; Used in debugging messages. You might want to set it explicitly if you want to display a different name for debugging purposes. * @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs} * @example * ```tsx * const MyComponent: FC = () => { return <div>Hello!</div> } * MyComponent.displayName = 'MyAwesomeComponent' ``` displayName?: string | undefined; } The type of the ref received by a {@link ForwardRefRenderFunction}. * @see {@link ForwardRefRenderFunction} // Making T nullable is assuming the refs will be managed by React or the component impl will write it somewhere else. // But this isn't necessarily true. We haven't heard complains about it yet and hopefully `forwardRef` is removed from React before we do. type ForwardedRef<T> = ((instance: T | null) => void) | RefObject<T | null> | null; The type of the function passed to {@link forwardRef}. This is considered different to a normal {@link FunctionComponent} because it receives an additional argument, * @param props Props passed to the component, if any. @param ref A ref forwarded to the component of type {@link ForwardedRef}. * @template T The type of the forwarded ref. @template P The type of the props the component accepts. * @see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/forward_and_create_ref/ React TypeScript Cheatsheet} @see {@link forwardRef} interface ForwardRefRenderFunction<T, P = {}> { (props: P, ref: ForwardedRef<T>): ReactNode; Used in debugging messages. You might want to set it explicitly if you want to display a different name for debugging purposes. * Will show `ForwardRef(${Component.displayName || Component.name})` in devtools by default, but can be given its own specific name. * @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs} displayName?: string | undefined; Ignored by React. @deprecated Only kept in types for backwards compatibility. Will be removed in a future major release. propTypes?: any; } Represents a component class in React. * @template P The props the component accepts. @template S The internal state of the component. interface ComponentClass<P = {}, S = ComponentState> extends StaticLifecycle<P, S> { // constructor signature must match React.Component new(props: P): Component<P, S>; Ignored by React. @deprecated Only kept in types for backwards compatibility. Will be removed in a future major release. propTypes?: any; contextType?: Context<any> | undefined; defaultProps?: Partial<P> | undefined; Used in debugging messages. You might want to set it explicitly if you want to display a different name for debugging purposes. * @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs} displayName?: string | undefined; } @deprecated Use `ClassicComponentClass` from `create-react-class` * @see {@link https://legacy.reactjs.org/docs/react-without-es6.html Legacy React Docs} @see {@link https://www.npmjs.com/package/create-react-class `create-react-class` on npm} interface ClassicComponentClass<P = {}> extends ComponentClass<P> { new(props: P): ClassicComponent<P, ComponentState>; getDefaultProps?(): P; } Used in {@link createElement} and {@link createFactory} to represent a class. * An intersection type is used to infer multiple type parameters from a single argument, which is useful for many top-level API defs. See {@link https://github.com/Microsoft/TypeScript/issues/7234 this GitHub issue} for more info. type ClassType<P, T extends Component<P, ComponentState>, C extends ComponentClass<P>> = & C & (new(props: P) => T); // // Component Specs and Lifecycle // ---------------------------------------------------------------------- // This should actually be something like `Lifecycle<P, S> | DeprecatedLifecycle<P, S>`, // as React will _not_ call the deprecated lifecycle methods if any of the new lifecycle // methods are present. interface ComponentLifecycle<P, S, SS = any> extends NewLifecycle<P, S, SS>, DeprecatedLifecycle<P, S> { Called immediately after a component is mounted. Setting state here will trigger re-rendering. componentDidMount?(): void; Called to determine whether the change in props and state should trigger a re-render. * `Component` always returns true. `PureComponent` implements a shallow comparison on props and state and returns true if any props or states have changed. * If false is returned, {@link Component.render}, `componentWillUpdate` and `componentDidUpdate` will not be called. shouldComponentUpdate?(nextProps: Readonly<P>, nextState: Readonly<S>, nextContext: any): boolean; Called immediately before a component is destroyed. Perform any necessary cleanup in this method, such as cancelled network requests, or cleaning up any DOM elements created in `componentDidMount`. componentWillUnmount?(): void; Catches exceptions generated in descendant components. Unhandled exceptions will cause the entire component tree to unmount. componentDidCatch?(error: Error, errorInfo: ErrorInfo): void; } // Unfortunately, we have no way of declaring that the component constructor must implement this interface StaticLifecycle<P, S> { getDerivedStateFromProps?: GetDerivedStateFromProps<P, S> | undefined; getDerivedStateFromError?: GetDerivedStateFromError<P, S> | undefined; } type GetDerivedStateFromProps<P, S> = Returns an update to a component's state based on its new props and old state. * Note: its presence prevents any of the deprecated lifecycle methods from being invoked (nextProps: Readonly<P>, prevState: S) => Partial<S> | null; type GetDerivedStateFromError<P, S> = This lifecycle is invoked after an error has been thrown by a descendant component. It receives the error that was thrown as a parameter and should return a value to update state. * Note: its presence prevents any of the deprecated lifecycle methods from being invoked (error: any) => Partial<S> | null; // This should be \"infer SS\" but can't use it yet interface NewLifecycle<P, S, SS> { Runs before React applies the result of {@link Component.render render} to the document, and returns an object to be given to {@link componentDidUpdate}. Useful for saving things such as scroll position before {@link Component.render render} causes changes to it. * Note: the presence of this method prevents any of the deprecated lifecycle events from running. getSnapshotBeforeUpdate?(prevProps: Readonly<P>, prevState: Readonly<S>): SS | null; Called immediately after updating occurs. Not called for the initial render. * The snapshot is only present if {@link getSnapshotBeforeUpdate} is present and returns non-null. componentDidUpdate?(prevProps: Readonly<P>, prevState: Readonly<S>, snapshot?: SS): void; } interface DeprecatedLifecycle<P, S> { Called immediately before mounting occurs, and before {@link Component.render}. Avoid introducing any side-effects or subscriptions in this method. * Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate} or {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents this from being invoked. * @deprecated 16.3, use {@link ComponentLifecycle.componentDidMount componentDidMount} or the constructor instead; will stop working in React 17 @see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#initializing-state} @see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path} componentWillMount?(): void; Called immediately before mounting occurs, and before {@link Component.render}. Avoid introducing any side-effects or subscriptions in this method. * This method will not stop working in React 17. * Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate} or {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents this from being invoked. * @deprecated 16.3, use {@link ComponentLifecycle.componentDidMount componentDidMount} or the constructor instead @see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#initializing-state} @see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path} UNSAFE_componentWillMount?(): void; Called when the component may be receiving new props. React may call this even if props have not changed, so be sure to compare new and existing props if you only want to handle changes. * Calling {@link Component.setState} generally does not trigger this method. * Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate} or {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents this from being invoked. * @deprecated 16.3, use static {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} instead; will stop working in React 17 @see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#updating-state-based-on-props} @see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path} componentWillReceiveProps?(nextProps: Readonly<P>, nextContext: any): void; Called when the component may be receiving new props. React may call this even if props have not changed, so be sure to compare new and existing props if you only want to handle changes. * Calling {@link Component.setState} generally does not trigger this method. * This method will not stop working in React 17. * Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate} or {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents this from being invoked. * @deprecated 16.3, use static {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} instead @see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#updating-state-based-on-props} @see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path} UNSAFE_componentWillReceiveProps?(nextProps: Readonly<P>, nextContext: any): void; Called immediately before rendering when new props or state is received. Not called for the initial render. * Note: You cannot call {@link Component.setState} here. * Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate} or {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents this from being invoked. * @deprecated 16.3, use getSnapshotBeforeUpdate instead; will stop working in React 17 @see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#reading-dom-properties-before-an-update} @see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path} componentWillUpdate?(nextProps: Readonly<P>, nextState: Readonly<S>, nextContext: any): void; Called immediately before rendering when new props or state is received. Not called for the initial render. * Note: You cannot call {@link Component.setState} here. * This method will not stop working in React 17. * Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate} or {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents this from being invoked. * @deprecated 16.3, use getSnapshotBeforeUpdate instead @see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#reading-dom-properties-before-an-update} @see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path} UNSAFE_componentWillUpdate?(nextProps: Readonly<P>, nextState: Readonly<S>, nextContext: any): void; } function createRef<T>(): RefObject<T | null>; The type of the component returned from {@link forwardRef}. * @template P The props the component accepts, if any. * @see {@link ExoticComponent} interface ForwardRefExoticComponent<P> extends NamedExoticComponent<P> { Ignored by React. @deprecated Only kept in types for backwards compatibility. Will be removed in a future major release. propTypes?: any; } Lets your component expose a DOM node to a parent component using a ref. * @see {@link https://react.dev/reference/react/forwardRef React Docs} @see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/forward_and_create_ref/ React TypeScript Cheatsheet} * @param render See the {@link ForwardRefRenderFunction}. * @template T The type of the DOM node. @template P The props the component accepts, if any. * @example * ```tsx interface Props { children?: ReactNode; type: \"submit\" | \"button\"; } * export const FancyButton = forwardRef<HTMLButtonElement, Props>((props, ref) => ( <button ref={ref} className=\"MyClassName\" type={props.type}> {props.children} </button> )); ``` function forwardRef<T, P = {}>( render: ForwardRefRenderFunction<T, PropsWithoutRef<P>>, ): ForwardRefExoticComponent<PropsWithoutRef<P> & RefAttributes<T>>; Omits the 'ref' attribute from the given props object. * @template Props The props object type. type PropsWithoutRef<Props> = // Omit would not be sufficient for this. We'd like to avoid unnecessary mapping and need a distributive conditional to support unions. // see: https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types // https://github.com/Microsoft/TypeScript/issues/28339 Props extends any ? (\"ref\" extends keyof Props ? Omit<Props, \"ref\"> : Props) : Props; Ensures that the props do not include string ref, which cannot be forwarded @deprecated Use `Props` directly. `PropsWithRef<Props>` is just an alias for `Props` type PropsWithRef<Props> = Props; type PropsWithChildren<P = unknown> = P & { children?: ReactNode | undefined }; Used to retrieve the props a component accepts. Can either be passed a string, indicating a DOM element (e.g. 'div', 'span', etc.) or the type of a React component. * It's usually better to use {@link ComponentPropsWithRef} or {@link ComponentPropsWithoutRef} instead of this type, as they let you be explicit about whether or not to include the `ref` prop. * @see {@link https://react-typescript-cheatsheet.netlify.app/docs/react-types/componentprops/ React TypeScript Cheatsheet} * @example * ```tsx // Retrieves the props an 'input' element accepts type InputProps = React.ComponentProps<'input'>; ``` * @example * ```tsx const MyComponent = (props: { foo: number, bar: string }) => <div />; * // Retrieves the props 'MyComponent' accepts type MyComponentProps = React.ComponentProps<typeof MyComponent>; ``` type ComponentProps<T extends keyof JSX.IntrinsicElements | JSXElementConstructor<any>> = T extends JSXElementConstructor<infer Props> ? Props : T extends keyof JSX.IntrinsicElements ? JSX.IntrinsicElements[T] : {}; Used to retrieve the props a component accepts with its ref. Can either be passed a string, indicating a DOM element (e.g. 'div', 'span', etc.) or the type of a React component. * @see {@link https://react-typescript-cheatsheet.netlify.app/docs/react-types/componentprops/ React TypeScript Cheatsheet} * @example * ```tsx // Retrieves the props an 'input' element accepts type InputProps = React.ComponentPropsWithRef<'input'>; ``` * @example * ```tsx const MyComponent = (props: { foo: number, bar: string }) => <div />; * // Retrieves the props 'MyComponent' accepts type MyComponentPropsWithRef = React.ComponentPropsWithRef<typeof MyComponent>; ``` type ComponentPropsWithRef<T extends ElementType> = T extends JSXElementConstructor<infer Props> // If it's a class i.e. newable we're dealing with a class component ? T extends abstract new(args: any) => any ? PropsWithoutRef<Props> & RefAttributes<InstanceType<T>> : Props : ComponentProps<T>; Used to retrieve the props a custom component accepts with its ref. * Unlike {@link ComponentPropsWithRef}, this only works with custom components, i.e. components you define yourself. This is to improve type-checking performance. * @example * ```tsx const MyComponent = (props: { foo: number, bar: string }) => <div />; * // Retrieves the props 'MyComponent' accepts type MyComponentPropsWithRef = React.CustomComponentPropsWithRef<typeof MyComponent>; ``` type CustomComponentPropsWithRef<T extends ComponentType> = T extends JSXElementConstructor<infer Props> // If it's a class i.e. newable we're dealing with a class component ? T extends abstract new(args: any) => any ? PropsWithoutRef<Props> & RefAttributes<InstanceType<T>> : Props : never; Used to retrieve the props a component accepts without its ref. Can either be passed a string, indicating a DOM element (e.g. 'div', 'span', etc.) or the type of a React component. * @see {@link https://react-typescript-cheatsheet.netlify.app/docs/react-types/componentprops/ React TypeScript Cheatsheet} * @example * ```tsx // Retrieves the props an 'input' element accepts type InputProps = React.ComponentPropsWithoutRef<'input'>; ``` * @example * ```tsx const MyComponent = (props: { foo: number, bar: string }) => <div />; * // Retrieves the props 'MyComponent' accepts type MyComponentPropsWithoutRef = React.ComponentPropsWithoutRef<typeof MyComponent>; ``` type ComponentPropsWithoutRef<T extends ElementType> = PropsWithoutRef<ComponentProps<T>>; Retrieves the type of the 'ref' prop for a given component type or tag name. * @template C The component type. * @example * ```tsx type MyComponentRef = React.ComponentRef<typeof MyComponent>; ``` * @example * ```tsx type DivRef = React.ComponentRef<'div'>; ``` type ComponentRef<T extends ElementType> = ComponentPropsWithRef<T> extends RefAttributes<infer Method> ? Method : never; // will show `Memo(${Component.displayName || Component.name})` in devtools by default, // but can be given its own specific name type MemoExoticComponent<T extends ComponentType<any>> = NamedExoticComponent<CustomComponentPropsWithRef<T>> & { readonly type: T; }; Lets you skip re-rendering a component when its props are unchanged. * @see {@link https://react.dev/reference/react/memo React Docs} * @param Component The component to memoize. @param propsAreEqual A function that will be used to determine if the props have changed. * @example * ```tsx import { memo } from 'react'; * const SomeComponent = memo(function SomeComponent(props: { foo: string }) { // ... }); ``` function memo<P extends object>( Component: FunctionComponent<P>, propsAreEqual?: (prevProps: Readonly<P>, nextProps: Readonly<P>) => boolean, ): NamedExoticComponent<P>; function memo<T extends ComponentType<any>>( Component: T, propsAreEqual?: (prevProps: Readonly<ComponentProps<T>>, nextProps: Readonly<ComponentProps<T>>) => boolean, ): MemoExoticComponent<T>; interface LazyExoticComponent<T extends ComponentType<any>> extends ExoticComponent<CustomComponentPropsWithRef<T>> { readonly _result: T; } Lets you defer loading a component’s code until it is rendered for the first time. * @see {@link https://react.dev/reference/react/lazy React Docs} * @param load A function that returns a `Promise` or another thenable (a `Promise`-like object with a then method). React will not call `load` until the first time you attempt to render the returned component. After React first calls load, it will wait for it to resolve, and then render the resolved value’s `.default` as a React component. Both the returned `Promise` and the `Promise`’s resolved value will be cached, so React will not call load more than once. If the `Promise` rejects, React will throw the rejection reason for the nearest Error Boundary to handle. * @example * ```tsx import { lazy } from 'react'; * const MarkdownPreview = lazy(() => import('./MarkdownPreview.js')); ``` function lazy<T extends ComponentType<any>>( load: () => Promise<{ default: T }>, ): LazyExoticComponent<T>; // // React Hooks // ---------------------------------------------------------------------- The instruction passed to a {@link Dispatch} function in {@link useState} to tell React what the next value of the {@link useState} should be. * Often found wrapped in {@link Dispatch}. * @template S The type of the state. * @example * ```tsx // This return type correctly represents the type of // `setCount` in the example below. const useCustomState = (): Dispatch<SetStateAction<number>> => { const [count, setCount] = useState(0); * return setCount; } ``` type SetStateAction<S> = S | ((prevState: S) => S); A function that can be used to update the state of a {@link useState} or {@link useReducer} hook. type Dispatch<A> = (value: A) => void; A {@link Dispatch} function can sometimes be called without any arguments. type DispatchWithoutAction = () => void; // Limit the reducer to accept only 0 or 1 action arguments // eslint-disable-next-line @definitelytyped/no-single-element-tuple-type type AnyActionArg = [] | [any]; // Get the dispatch type from the reducer arguments (captures optional action argument correctly) type ActionDispatch<ActionArg extends AnyActionArg> = (...args: ActionArg) => void; // Unlike redux, the actions _can_ be anything type Reducer<S, A> = (prevState: S, action: A) => S; // If useReducer accepts a reducer without action, dispatch may be called without any parameters. type ReducerWithoutAction<S> = (prevState: S) => S; // types used to try and prevent the compiler from reducing S // to a supertype common with the second argument to useReducer() type ReducerState<R extends Reducer<any, any>> = R extends Reducer<infer S, any> ? S : never; type DependencyList = readonly unknown[]; // NOTE: callbacks are _only_ allowed to return either void, or a destructor. type EffectCallback = () => void | Destructor; @deprecated Use `RefObject` instead. interface MutableRefObject<T> { current: T; } // This will technically work if you give a Consumer<T> or Provider<T> but it's deprecated and warns Accepts a context object (the value returned from `React.createContext`) and returns the current context value, as given by the nearest context provider for the given context. * @version 16.8.0 @see {@link https://react.dev/reference/react/useContext} function useContext<T>(context: Context<T> /*, (not public API) observedBits?: number|boolean ): T; Returns a stateful value, and a function to update it. * @version 16.8.0 @see {@link https://react.dev/reference/react/useState} function useState<S>(initialState: S | (() => S)): [S, Dispatch<SetStateAction<S>>]; // convenience overload when first argument is omitted Returns a stateful value, and a function to update it. * @version 16.8.0 @see {@link https://react.dev/reference/react/useState} function useState<S = undefined>(): [S | undefined, Dispatch<SetStateAction<S | undefined>>]; An alternative to `useState`. * `useReducer` is usually preferable to `useState` when you have complex state logic that involves multiple sub-values. It also lets you optimize performance for components that trigger deep updates because you can pass `dispatch` down instead of callbacks. * @version 16.8.0 @see {@link https://react.dev/reference/react/useReducer} function useReducer<S, A extends AnyActionArg>( reducer: (prevState: S, ...args: A) => S, initialState: S, ): [S, ActionDispatch<A>]; An alternative to `useState`. * `useReducer` is usually preferable to `useState` when you have complex state logic that involves multiple sub-values. It also lets you optimize performance for components that trigger deep updates because you can pass `dispatch` down instead of callbacks. * @version 16.8.0 @see {@link https://react.dev/reference/react/useReducer} function useReducer<S, A extends AnyActionArg>( reducer: (prevState: S, ...args: A) => S, initialState: S, ): [S, ActionDispatch<A>]; An alternative to `useState`. * `useReducer` is usually preferable to `useState` when you have complex state logic that involves multiple sub-values. It also lets you optimize performance for components that trigger deep updates because you can pass `dispatch` down instead of callbacks. * @version 16.8.0 @see {@link https://react.dev/reference/react/useReducer} function useReducer<S, I, A extends AnyActionArg>( reducer: (prevState: S, ...args: A) => S, initialArg: I, init: (i: I) => S, ): [S, ActionDispatch<A>]; `useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument (`initialValue`). The returned object will persist for the full lifetime of the component. * Note that `useRef()` is useful for more than the `ref` attribute. It’s handy for keeping any mutable value around similar to how you’d use instance fields in classes. * @version 16.8.0 @see {@link https://react.dev/reference/react/useRef} function useRef<T>(initialValue: T): RefObject<T>; // convenience overload for refs given as a ref prop as they typically start with a null value `useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument (`initialValue`). The returned object will persist for the full lifetime of the component. * Note that `useRef()` is useful for more than the `ref` attribute. It’s handy for keeping any mutable value around similar to how you’d use instance fields in classes. * @version 16.8.0 @see {@link https://react.dev/reference/react/useRef} function useRef<T>(initialValue: T | null): RefObject<T | null>; // convenience overload for undefined initialValue `useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument (`initialValue`). The returned object will persist for the full lifetime of the component. * Note that `useRef()` is useful for more than the `ref` attribute. It’s handy for keeping any mutable value around similar to how you’d use instance fields in classes. * @version 16.8.0 @see {@link https://react.dev/reference/react/useRef} function useRef<T>(initialValue: T | undefined): RefObject<T | undefined>; The signature is identical to `useEffect`, but it fires synchronously after all DOM mutations. Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside `useLayoutEffect` will be flushed synchronously, before the browser has a chance to paint. * Prefer the standard `useEffect` when possible to avoid blocking visual updates. * If you’re migrating code from a class component, `useLayoutEffect` fires in the same phase as `componentDidMount` and `componentDidUpdate`. * @version 16.8.0 @see {@link https://react.dev/reference/react/useLayoutEffect} function useLayoutEffect(effect: EffectCallback, deps?: DependencyList): void; Accepts a function that contains imperative, possibly effectful code. * @param effect Imperative function that can return a cleanup function @param deps If present, effect will only activate if the values in the list change. * @version 16.8.0 @see {@link https://react.dev/reference/react/useEffect} function useEffect(effect: EffectCallback, deps?: DependencyList): void; // NOTE: this does not accept strings, but this will have to be fixed by removing strings from type Ref<T> `useImperativeHandle` customizes the instance value that is exposed to parent components when using `ref`. As always, imperative code using refs should be avoided in most cases. * `useImperativeHandle` should be used with `React.forwardRef`. * @version 16.8.0 @see {@link https://react.dev/reference/react/useImperativeHandle} function useImperativeHandle<T, R extends T>(ref: Ref<T> | undefined, init: () => R, deps?: DependencyList): void; // I made 'inputs' required here and in useMemo as there's no point to memoizing without the memoization key // useCallback(X) is identical to just using X, useMemo(() => Y) is identical to just using Y. `useCallback` will return a memoized version of the callback that only changes if one of the `inputs` has changed. * @version 16.8.0 @see {@link https://react.dev/reference/react/useCallback} // A specific function type would not trigger implicit any. // See https://github.com/DefinitelyTyped/DefinitelyTyped/issues/52873#issuecomment-845806435 for a comparison between `Function` and more specific types. // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type function useCallback<T extends Function>(callback: T, deps: DependencyList): T; `useMemo` will only recompute the memoized value when one of the `deps` has changed. * @version 16.8.0 @see {@link https://react.dev/reference/react/useMemo} // allow undefined, but don't make it optional as that is very likely a mistake function useMemo<T>(factory: () => T, deps: DependencyList): T; `useDebugValue` can be used to display a label for custom hooks in React DevTools. * NOTE: We don’t recommend adding debug values to every custom hook. It’s most valuable for custom hooks that are part of shared libraries. * @version 16.8.0 @see {@link https://react.dev/reference/react/useDebugValue} // the name of the custom hook is itself derived from the function name at runtime: // it's just the function name without the \"use\" prefix. function useDebugValue<T>(value: T, format?: (value: T) => any): void; export type TransitionFunction = () => VoidOrUndefinedOnly | Promise<VoidOrUndefinedOnly>; // strange definition to allow vscode to show documentation on the invocation export interface TransitionStartFunction { State updates caused inside the callback are allowed to be deferred. * **If some state update causes a component to suspend, that state update should be wrapped in a transition.** * @param callback A function which causes state updates that can be deferred. (callback: TransitionFunction): void; } Returns a deferred version of the value that may “lag behind” it. * This is commonly used to keep the interface responsive when you have something that renders immediately based on user input and something that needs to wait for a data fetch. * A good example of this is a text input. * @param value The value that is going to be deferred @param initialValue A value to use during the initial render of a component. If this option is omitted, `useDeferredValue` will not defer during the initial render, because there’s no previous version of `value` that it can render instead. * @see {@link https://react.dev/reference/react/useDeferredValue} export function useDeferredValue<T>(value: T, initialValue?: T): T; Allows components to avoid undesirable loading states by waiting for content to load before transitioning to the next screen. It also allows components to defer slower, data fetching updates until subsequent renders so that more crucial updates can be rendered immediately. * The `useTransition` hook returns two values in an array. * The first is a boolean, React’s way of informing us whether we’re waiting for the transition to finish. The second is a function that takes a callback. We can use it to tell React which state we want to defer. * **If some state update causes a component to suspend, that state update should be wrapped in a transition.** * @see {@link https://react.dev/reference/react/useTransition} export function useTransition(): [boolean, TransitionStartFunction]; Similar to `useTransition` but allows uses where hooks are not available. * @param callback A function which causes state updates that can be deferred. export function startTransition(scope: TransitionFunction): void; Wrap any code rendering and triggering updates to your components into `act()` calls. * Ensures that the behavior in your tests matches what happens in the browser more closely by executing pending `useEffect`s before returning. This also reduces the amount of re-renders done. * @param callback A synchronous, void callback that will execute as a single, complete React commit. * @see https://reactjs.org/blog/2019/02/06/react-v16.8.0.html#testing-hooks // NOTES // - the order of these signatures matters - typescript will check the signatures in source order. // If the `() => VoidOrUndefinedOnly` signature is first, it'll erroneously match a Promise returning function for users with // `strictNullChecks: false`. // - VoidOrUndefinedOnly is there to forbid any non-void return values for users with `strictNullChecks: true` // While act does always return Thenable, if a void function is passed, we pretend the return value is also void to not trigger dangling Promise lint rules. export function act(callback: () => VoidOrUndefinedOnly): void; export function act<T>(callback: () => T | Promise<T>): Promise<T>; export function useId(): string; @param effect Imperative function that can return a cleanup function @param deps If present, effect will only activate if the values in the list change. * @see {@link https://github.com/facebook/react/pull/21913}",
    "description": "Added new function useInsertionEffect",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nUsed to represent DOM API's where users can either pass\ntrue or false as a boolean or as its equivalent strings.\n \ntype Booleanish = boolean | \"true\" | \"false\";\n@see {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/crossorigin MDN}\n \ntype CrossOrigin = \"anonymous\" | \"use-credentials\" | \"\" | undefined;\n\ndeclare const UNDEFINED_VOID_ONLY: unique symbol;\n@internal Use `Awaited<ReactNode>` instead\n \n// Helper type to enable `Awaited<ReactNode>`.\n// Must be a copy of the non-thenables of `ReactNode`.\ntype AwaitedReactNode =\n    | React.ReactElement\n    | string\n    | number\n    | bigint\n    | Iterable<React.ReactNode>\n    | React.ReactPortal\n    | boolean\n    | null\n    | undefined\n    | React.DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES[\n        keyof React.DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES\n    ];\nThe function returned from an effect passed to {@link React.useEffect useEffect},\nwhich can be used to clean up the effect when the component unmounts.\n* @see {@link https://react.dev/reference/react/useEffect React Docs}\n \ntype Destructor = () => void | { [UNDEFINED_VOID_ONLY]: never };\ntype VoidOrUndefinedOnly = void | { [UNDEFINED_VOID_ONLY]: never };\n\n// eslint-disable-next-line @definitelytyped/export-just-namespace\nexport = React;\nexport as namespace React;\n\ndeclare namespace React {\n    //\n    // React Elements\n    // ----------------------------------------------------------------------\nUsed to retrieve the possible components which accept a given set of props.\n* Can be passed no type parameters to get a union of all possible components\nand tags.\n* Is a superset of {@link ComponentType}.\n* @template P The props to match against. If not passed, defaults to any.\n@template Tag An optional tag to match against. If not passed, attempts to match against all possible tags.\n* @example\n* ```tsx\n// All components and tags (img, embed etc.)\n// which accept `src`\ntype SrcComponents = ElementType<{ src: any }>;\n```\n* @example\n* ```tsx\n// All components\ntype AllComponents = ElementType;\n```\n* @example\n* ```tsx\n// All custom components which match `src`, and tags which\n// match `src`, narrowed down to just `audio` and `embed`\ntype SrcComponents = ElementType<{ src: any }, 'audio' | 'embed'>;\n```\n     \n    type ElementType<P = any, Tag extends keyof JSX.IntrinsicElements = keyof JSX.IntrinsicElements> =\n        | { [K in Tag]: P extends JSX.IntrinsicElements[K] ? K : never }[Tag]\n        | ComponentType<P>;\nRepresents any user-defined component, either as a function or a class.\n* Similar to {@link JSXElementConstructor}, but with extra properties like\n{@link FunctionComponent.defaultProps defaultProps }.\n* @template P The props the component accepts.\n* @see {@link ComponentClass}\n@see {@link FunctionComponent}\n     \n    type ComponentType<P = {}> = ComponentClass<P> | FunctionComponent<P>;\nRepresents any user-defined component, either as a function or a class.\n* Similar to {@link ComponentType}, but without extra properties like\n{@link FunctionComponent.defaultProps defaultProps }.\n* @template P The props the component accepts.\n     \n    type JSXElementConstructor<P> =\n        | ((\n            props: P,\n        ) => ReactNode | Promise<ReactNode>)\n        // constructor signature must match React.Component\n        | (new(props: P) => Component<any, any>);\nCreated by {@link createRef}, or {@link useRef} when passed `null`.\n* @template T The type of the ref's value.\n* @example\n* ```tsx\nconst ref = createRef<HTMLDivElement>();\n* ref.current = document.createElement('div'); // Error\n```\n     \n    interface RefObject<T> {\nThe current value of the ref.\n         \n        current: T;\n    }\n\n    interface DO_NOT_USE_OR_YOU_WILL_BE_FIRED_CALLBACK_REF_RETURN_VALUES {\n    }\nA callback fired whenever the ref's value changes.\n* @template T The type of the ref's value.\n* @see {@link https://react.dev/reference/react-dom/components/common#ref-callback React Docs}\n* @example\n* ```tsx\n<div ref={(node) => console.log(node)} />\n```\n     \n    type RefCallback<T> = {\n        bivarianceHack(\n            instance: T | null,\n        ):\n            | void\n            | (() => VoidOrUndefinedOnly)\n            | DO_NOT_USE_OR_YOU_WILL_BE_FIRED_CALLBACK_REF_RETURN_VALUES[\n                keyof DO_NOT_USE_OR_YOU_WILL_BE_FIRED_CALLBACK_REF_RETURN_VALUES\n            ];\n    }[\"bivarianceHack\"];\nA union type of all possible shapes for React refs.\n* @see {@link RefCallback}\n@see {@link RefObject}\n     \n\n    type Ref<T> = RefCallback<T> | RefObject<T | null> | null;\n@deprecated Use `Ref` instead. String refs are no longer supported.\nIf you're typing a library with support for React versions with string refs, use `RefAttributes<T>['ref']` instead.\n     \n    type LegacyRef<T> = Ref<T>;\n@deprecated Use `ComponentRef<T>` instead\n* Retrieves the type of the 'ref' prop for a given component type or tag name.\n* @template C The component type.\n* @example\n* ```tsx\ntype MyComponentRef = React.ElementRef<typeof MyComponent>;\n```\n* @example\n* ```tsx\ntype DivRef = React.ElementRef<'div'>;\n```\n     \n    type ElementRef<\n        C extends\n            | ForwardRefExoticComponent<any>\n            | { new(props: any): Component<any> }\n            | ((props: any) => ReactNode)\n            | keyof JSX.IntrinsicElements,\n    > = ComponentRef<C>;\n\n    type ComponentState = any;\nA value which uniquely identifies a node among items in an array.\n* @see {@link https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key React Docs}\n     \n    type Key = string | number | bigint;\n@internal The props any component can receive.\nYou don't have to add this type. All components automatically accept these props.\n```tsx\nconst Component = () => <div />;\n<Component key=\"one\" />\n```\n* WARNING: The implementation of a component will never have access to these attributes.\nThe following example would be incorrect usage because {@link Component} would never have access to `key`:\n```tsx\nconst Component = (props: React.Attributes) => props.key;\n```\n     \n    interface Attributes {\n        key?: Key | null | undefined;\n    }\nThe props any component accepting refs can receive.\nClass components, built-in browser components (e.g. `div`) and forwardRef components can receive refs and automatically accept these props.\n```tsx\nconst Component = forwardRef(() => <div />);\n<Component ref={(current) => console.log(current)} />\n```\n* You only need this type if you manually author the types of props that need to be compatible with legacy refs.\n```tsx\ninterface Props extends React.RefAttributes<HTMLDivElement> {}\ndeclare const Component: React.FunctionComponent<Props>;\n```\n* Otherwise it's simpler to directly use {@link Ref} since you can safely use the\nprops type to describe to props that a consumer can pass to the component\nas well as describing the props the implementation of a component \"sees\".\n{@link RefAttributes} is generally not safe to describe both consumer and seen props.\n* ```tsx\ninterface Props extends {\nref?: React.Ref<HTMLDivElement> | undefined;\n}\ndeclare const Component: React.FunctionComponent<Props>;\n```\n* WARNING: The implementation of a component will not have access to the same type in versions of React supporting string refs.\nThe following example would be incorrect usage because {@link Component} would never have access to a `ref` with type `string`\n```tsx\nconst Component = (props: React.RefAttributes) => props.ref;\n```\n     \n    interface RefAttributes<T> extends Attributes {\nAllows getting a ref to the component instance.\nOnce the component unmounts, React will set `ref.current` to `null`\n(or call the ref with `null` if you passed a callback ref).\n* @see {@link https://react.dev/learn/referencing-values-with-refs#refs-and-the-dom React Docs}\n         \n        ref?: Ref<T> | undefined;\n    }\nRepresents the built-in attributes available to class components.\n     \n    interface ClassAttributes<T> extends RefAttributes<T> {\n    }\nRepresents a JSX element.\n* Where {@link ReactNode} represents everything that can be rendered, `ReactElement`\nonly represents JSX.\n* @template P The type of the props object\n@template T The type of the component or tag\n* @example\n* ```tsx\nconst element: ReactElement = <div />;\n```\n     \n    interface ReactElement<\n        P = unknown,\n        T extends string | JSXElementConstructor<any> = string | JSXElementConstructor<any>,\n    > {\n        type: T;\n        props: P;\n        key: string | null;\n    }\n@deprecated\n     \n    interface ReactComponentElement<\n        T extends keyof JSX.IntrinsicElements | JSXElementConstructor<any>,\n        P = Pick<ComponentProps<T>, Exclude<keyof ComponentProps<T>, \"key\" | \"ref\">>,\n    > extends ReactElement<P, Exclude<T, number>> {}\n@deprecated Use `ReactElement<P, React.FunctionComponent<P>>`\n     \n    interface FunctionComponentElement<P> extends ReactElement<P, FunctionComponent<P>> {\n@deprecated Use `element.props.ref` instead.\n         \n        ref?: (\"ref\" extends keyof P ? P extends { ref?: infer R | undefined } ? R : never : never) | undefined;\n    }\n@deprecated Use `ReactElement<P, React.ComponentClass<P>>`\n     \n    type CElement<P, T extends Component<P, ComponentState>> = ComponentElement<P, T>;\n@deprecated Use `ReactElement<P, React.ComponentClass<P>>`\n     \n    interface ComponentElement<P, T extends Component<P, ComponentState>> extends ReactElement<P, ComponentClass<P>> {\n@deprecated Use `element.props.ref` instead.\n         \n        ref?: Ref<T> | undefined;\n    }\n@deprecated Use {@link ComponentElement} instead.\n     \n    type ClassicElement<P> = CElement<P, ClassicComponent<P, ComponentState>>;\n\n    // string fallback for custom web-components\n@deprecated Use `ReactElement<P, string>`\n     \n    interface DOMElement<P extends HTMLAttributes<T> | SVGAttributes<T>, T extends Element>\n        extends ReactElement<P, string>\n    {\n@deprecated Use `element.props.ref` instead.\n         \n        ref: Ref<T>;\n    }\n\n    // ReactHTML for ReactHTMLElement\n    interface ReactHTMLElement<T extends HTMLElement> extends DetailedReactHTMLElement<AllHTMLAttributes<T>, T> {}\n\n    interface DetailedReactHTMLElement<P extends HTMLAttributes<T>, T extends HTMLElement> extends DOMElement<P, T> {\n        type: HTMLElementType;\n    }\n\n    // ReactSVG for ReactSVGElement\n    interface ReactSVGElement extends DOMElement<SVGAttributes<SVGElement>, SVGElement> {\n        type: SVGElementType;\n    }\n\n    interface ReactPortal extends ReactElement {\n        children: ReactNode;\n    }\nDifferent release channels declare additional types of ReactNode this particular release channel accepts.\nApp or library types should never augment this interface.\n     \n    interface DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES {}\nRepresents all of the things React can render.\n* Where {@link ReactElement} only represents JSX, `ReactNode` represents everything that can be rendered.\n* @see {@link https://react-typescript-cheatsheet.netlify.app/docs/react-types/reactnode/ React TypeScript Cheatsheet}\n* @example\n* ```tsx\n// Typing children\ntype Props = { children: ReactNode }\n* const Component = ({ children }: Props) => <div>{children}</div>\n* <Component>hello</Component>\n```\n* @example\n* ```tsx\n// Typing a custom element\ntype Props = { customElement: ReactNode }\n* const Component = ({ customElement }: Props) => <div>{customElement}</div>\n* <Component customElement={<div>hello</div>} />\n```\n     \n    // non-thenables need to be kept in sync with AwaitedReactNode\n    type ReactNode =\n        | ReactElement\n        | string\n        | number\n        | bigint\n        | Iterable<ReactNode>\n        | ReactPortal\n        | boolean\n        | null\n        | undefined\n        | DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES[\n            keyof DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES\n        ]\n        | Promise<AwaitedReactNode>;\n\n    //\n    // Top Level API\n    // ----------------------------------------------------------------------\n\n    // DOM Elements\n    // TODO: generalize this to everything in `keyof ReactHTML`, not just \"input\"\n    function createElement(\n        type: \"input\",\n        props?: InputHTMLAttributes<HTMLInputElement> & ClassAttributes<HTMLInputElement> | null,\n        ...children: ReactNode[]\n    ): DetailedReactHTMLElement<InputHTMLAttributes<HTMLInputElement>, HTMLInputElement>;\n    function createElement<P extends HTMLAttributes<T>, T extends HTMLElement>(\n        type: HTMLElementType,\n        props?: ClassAttributes<T> & P | null,\n        ...children: ReactNode[]\n    ): DetailedReactHTMLElement<P, T>;\n    function createElement<P extends SVGAttributes<T>, T extends SVGElement>(\n        type: SVGElementType,\n        props?: ClassAttributes<T> & P | null,\n        ...children: ReactNode[]\n    ): ReactSVGElement;\n    function createElement<P extends DOMAttributes<T>, T extends Element>(\n        type: string,\n        props?: ClassAttributes<T> & P | null,\n        ...children: ReactNode[]\n    ): DOMElement<P, T>;\n\n    // Custom components\n\n    function createElement<P extends {}>(\n        type: FunctionComponent<P>,\n        props?: Attributes & P | null,\n        ...children: ReactNode[]\n    ): FunctionComponentElement<P>;\n    function createElement<P extends {}, T extends Component<P, ComponentState>, C extends ComponentClass<P>>(\n        type: ClassType<P, T, C>,\n        props?: ClassAttributes<T> & P | null,\n        ...children: ReactNode[]\n    ): CElement<P, T>;\n    function createElement<P extends {}>(\n        type: FunctionComponent<P> | ComponentClass<P> | string,\n        props?: Attributes & P | null,\n        ...children: ReactNode[]\n    ): ReactElement<P>;\n\n    // DOM Elements\n    // ReactHTMLElement\n    function cloneElement<P extends HTMLAttributes<T>, T extends HTMLElement>(\n        element: DetailedReactHTMLElement<P, T>,\n        props?: P,\n        ...children: ReactNode[]\n    ): DetailedReactHTMLElement<P, T>;\n    // ReactHTMLElement, less specific\n    function cloneElement<P extends HTMLAttributes<T>, T extends HTMLElement>(\n        element: ReactHTMLElement<T>,\n        props?: P,\n        ...children: ReactNode[]\n    ): ReactHTMLElement<T>;\n    // SVGElement\n    function cloneElement<P extends SVGAttributes<T>, T extends SVGElement>(\n        element: ReactSVGElement,\n        props?: P,\n        ...children: ReactNode[]\n    ): ReactSVGElement;\n    // DOM Element (has to be the last, because type checking stops at first overload that fits)\n    function cloneElement<P extends DOMAttributes<T>, T extends Element>(\n        element: DOMElement<P, T>,\n        props?: DOMAttributes<T> & P,\n        ...children: ReactNode[]\n    ): DOMElement<P, T>;\n\n    // Custom components\n    function cloneElement<P>(\n        element: FunctionComponentElement<P>,\n        props?: Partial<P> & Attributes,\n        ...children: ReactNode[]\n    ): FunctionComponentElement<P>;\n    function cloneElement<P, T extends Component<P, ComponentState>>(\n        element: CElement<P, T>,\n        props?: Partial<P> & ClassAttributes<T>,\n        ...children: ReactNode[]\n    ): CElement<P, T>;\n    function cloneElement<P>(\n        element: ReactElement<P>,\n        props?: Partial<P> & Attributes,\n        ...children: ReactNode[]\n    ): ReactElement<P>;\nDescribes the props accepted by a Context {@link Provider}.\n* @template T The type of the value the context provides.\n     \n    interface ProviderProps<T> {\n        value: T;\n        children?: ReactNode | undefined;\n    }\nDescribes the props accepted by a Context {@link Consumer}.\n* @template T The type of the value the context provides.\n     \n    interface ConsumerProps<T> {\n        children: (value: T) => ReactNode;\n    }\nAn object masquerading as a component. These are created by functions\nlike {@link forwardRef}, {@link memo}, and {@link createContext}.\n* In order to make TypeScript work, we pretend that they are normal\ncomponents.\n* But they are, in fact, not callable - instead, they are objects which\nare treated specially by the renderer.\n* @template P The props the component accepts.\n     \n    interface ExoticComponent<P = {}> {\n        (props: P): ReactNode;\n        readonly $$typeof: symbol;\n    }\nAn {@link ExoticComponent} with a `displayName` property applied to it.\n* @template P The props the component accepts.\n     \n    interface NamedExoticComponent<P = {}> extends ExoticComponent<P> {\nUsed in debugging messages. You might want to set it\nexplicitly if you want to display a different name for\ndebugging purposes.\n* @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs}\n         \n        displayName?: string | undefined;\n    }\nAn {@link ExoticComponent} with a `propTypes` property applied to it.\n* @template P The props the component accepts.\n     \n    interface ProviderExoticComponent<P> extends ExoticComponent<P> {\n    }\nUsed to retrieve the type of a context object from a {@link Context}.\n* @template C The context object.\n* @example\n* ```tsx\nimport { createContext } from 'react';\n* const MyContext = createContext({ foo: 'bar' });\n* type ContextType = ContextType<typeof MyContext>;\n// ContextType = { foo: string }\n```\n     \n    type ContextType<C extends Context<any>> = C extends Context<infer T> ? T : never;\nWraps your components to specify the value of this context for all components inside.\n* @see {@link https://react.dev/reference/react/createContext#provider React Docs}\n* @example\n* ```tsx\nimport { createContext } from 'react';\n* const ThemeContext = createContext('light');\n* function App() {\nreturn (\n<ThemeContext.Provider value=\"dark\">\n<Toolbar />\n</ThemeContext.Provider>\n);\n}\n```\n     \n    type Provider<T> = ProviderExoticComponent<ProviderProps<T>>;\nThe old way to read context, before {@link useContext} existed.\n* @see {@link https://react.dev/reference/react/createContext#consumer React Docs}\n* @example\n* ```tsx\nimport { UserContext } from './user-context';\n* function Avatar() {\nreturn (\n<UserContext.Consumer>\n{user => <img src={user.profileImage} alt={user.name} />}\n</UserContext.Consumer>\n);\n}\n```\n     \n    type Consumer<T> = ExoticComponent<ConsumerProps<T>>;\nContext lets components pass information deep down without explicitly\npassing props.\n* Created from {@link createContext}\n* @see {@link https://react.dev/learn/passing-data-deeply-with-context React Docs}\n@see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/context/ React TypeScript Cheatsheet}\n* @example\n* ```tsx\nimport { createContext } from 'react';\n* const ThemeContext = createContext('light');\n```\n     \n    interface Context<T> extends Provider<T> {\n        Provider: Provider<T>;\n        Consumer: Consumer<T>;\nUsed in debugging messages. You might want to set it\nexplicitly if you want to display a different name for\ndebugging purposes.\n* @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs}\n         \n        displayName?: string | undefined;\n    }\nLets you create a {@link Context} that components can provide or read.\n* @param defaultValue The value you want the context to have when there is no matching\n{@link Provider} in the tree above the component reading the context. This is meant\nas a \"last resort\" fallback.\n* @see {@link https://react.dev/reference/react/createContext#reference React Docs}\n@see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/context/ React TypeScript Cheatsheet}\n* @example\n* ```tsx\nimport { createContext } from 'react';\n* const ThemeContext = createContext('light');\nfunction App() {\nreturn (\n<ThemeContext value=\"dark\">\n<Toolbar />\n</ThemeContext>\n);\n}\n```\n     \n    function createContext<T>(\n        // If you thought this should be optional, see\n        // https://github.com/DefinitelyTyped/DefinitelyTyped/pull/24509#issuecomment-382213106\n        defaultValue: T,\n    ): Context<T>;\n\n    function isValidElement<P>(object: {} | null | undefined): object is ReactElement<P>;\n\n    const Children: {\n        map<T, C>(\n            children: C | readonly C[],\n            fn: (child: C, index: number) => T,\n        ): C extends null | undefined ? C : Array<Exclude<T, boolean | null | undefined>>;\n        forEach<C>(children: C | readonly C[], fn: (child: C, index: number) => void): void;\n        count(children: any): number;\n        only<C>(children: C): C extends any[] ? never : C;\n        toArray(children: ReactNode | ReactNode[]): Array<Exclude<ReactNode, boolean | null | undefined>>;\n    };\n\n    export interface FragmentProps {\n        children?: React.ReactNode;\n    }\nLets you group elements without a wrapper node.\n* @see {@link https://react.dev/reference/react/Fragment React Docs}\n* @example\n* ```tsx\nimport { Fragment } from 'react';\n* <Fragment>\n<td>Hello</td>\n<td>World</td>\n</Fragment>\n```\n* @example\n* ```tsx\n// Using the <></> shorthand syntax:\n* <>\n<td>Hello</td>\n<td>World</td>\n</>\n```\n     \n    const Fragment: ExoticComponent<FragmentProps>;\nLets you find common bugs in your components early during development.\n* @see {@link https://react.dev/reference/react/StrictMode React Docs}\n* @example\n* ```tsx\nimport { StrictMode } from 'react';\n* <StrictMode>\n<App />\n</StrictMode>\n```\n     \n    const StrictMode: ExoticComponent<{ children?: ReactNode | undefined }>;\nThe props accepted by {@link Suspense}.\n* @see {@link https://react.dev/reference/react/Suspense React Docs}\n     \n    interface SuspenseProps {\n        children?: ReactNode | undefined;\n\n         A fallback react tree to show when a Suspense child (like React.lazy) suspends \n        fallback?: ReactNode;\nA name for this Suspense boundary for instrumentation purposes.\nThe name will help identify this boundary in React DevTools.\n         \n        name?: string | undefined;\n    }\nLets you display a fallback until its children have finished loading.\n* @see {@link https://react.dev/reference/react/Suspense React Docs}\n* @example\n* ```tsx\nimport { Suspense } from 'react';\n* <Suspense fallback={<Loading />}>\n<ProfileDetails />\n</Suspense>\n```\n     \n    const Suspense: ExoticComponent<SuspenseProps>;\n    const version: string;\nThe callback passed to {@link ProfilerProps.onRender}.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n     \n    type ProfilerOnRenderCallback = (\nThe string id prop of the {@link Profiler} tree that has just committed. This lets\nyou identify which part of the tree was committed if you are using multiple\nprofilers.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n         \n        id: string,\nThis lets you know whether the tree has just been mounted for the first time\nor re-rendered due to a change in props, state, or hooks.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n         \n        phase: \"mount\" | \"update\" | \"nested-update\",\nThe number of milliseconds spent rendering the {@link Profiler} and its descendants\nfor the current update. This indicates how well the subtree makes use of\nmemoization (e.g. {@link memo} and {@link useMemo}). Ideally this value should decrease\nsignificantly after the initial mount as many of the descendants will only need to\nre-render if their specific props change.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n         \n        actualDuration: number,\nThe number of milliseconds estimating how much time it would take to re-render the entire\n{@link Profiler} subtree without any optimizations. It is calculated by summing up the most\nrecent render durations of each component in the tree. This value estimates a worst-case\ncost of rendering (e.g. the initial mount or a tree with no memoization). Compare\n{@link actualDuration} against it to see if memoization is working.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n         \n        baseDuration: number,\nA numeric timestamp for when React began rendering the current update.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n         \n        startTime: number,\nA numeric timestamp for when React committed the current update. This value is shared\nbetween all profilers in a commit, enabling them to be grouped if desirable.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n         \n        commitTime: number,\n    ) => void;\nThe props accepted by {@link Profiler}.\n* @see {@link https://react.dev/reference/react/Profiler React Docs}\n     \n    interface ProfilerProps {\n        children?: ReactNode | undefined;\n        id: string;\n        onRender: ProfilerOnRenderCallback;\n    }\nLets you measure rendering performance of a React tree programmatically.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n* @example\n* ```tsx\n<Profiler id=\"App\" onRender={onRender}>\n<App />\n</Profiler>\n```\n     \n    const Profiler: ExoticComponent<ProfilerProps>;\n\n    //\n    // Component API\n    // ----------------------------------------------------------------------\n\n    type ReactInstance = Component<any> | Element;\n\n    // Base component for plain JS classes\n    interface Component<P = {}, S = {}, SS = any> extends ComponentLifecycle<P, S, SS> {}\n    class Component<P, S> {\nIf set, `this.context` will be set at runtime to the current value of the given Context.\n* @example\n* ```ts\ntype MyContext = number\nconst Ctx = React.createContext<MyContext>(0)\n* class Foo extends React.Component {\nstatic contextType = Ctx\ncontext!: React.ContextType<typeof Ctx>\nrender () {\nreturn <>My context's value: {this.context}</>;\n}\n}\n```\n* @see {@link https://react.dev/reference/react/Component#static-contexttype}\n         \n        static contextType?: Context<any> | undefined;\nIgnored by React.\n@deprecated Only kept in types for backwards compatibility. Will be removed in a future major release.\n         \n        static propTypes?: any;\nIf using the new style context, re-declare this in your class to be the\n`React.ContextType` of your `static contextType`.\nShould be used with type annotation or static contextType.\n* @example\n```ts\nstatic contextType = MyContext\n// For TS pre-3.7:\ncontext!: React.ContextType<typeof MyContext>\n// For TS 3.7 and above:\ndeclare context: React.ContextType<typeof MyContext>\n```\n* @see {@link https://react.dev/reference/react/Component#context React Docs}\n         \n        context: unknown;\n\n        // Keep in sync with constructor signature of JSXElementConstructor and ComponentClass.\n        constructor(props: P);\n\n        // We MUST keep setState() as a unified signature because it allows proper checking of the method return type.\n        // See: https://github.com/DefinitelyTyped/DefinitelyTyped/issues/18365#issuecomment-351013257\n        // Also, the ` | S` allows intellisense to not be dumbisense\n        setState<K extends keyof S>(\n            state: ((prevState: Readonly<S>, props: Readonly<P>) => Pick<S, K> | S | null) | (Pick<S, K> | S | null),\n            callback?: () => void,\n        ): void;\n\n        forceUpdate(callback?: () => void): void;\n        render(): ReactNode;\n\n        readonly props: Readonly<P>;\n        state: Readonly<S>;\n    }\n\n    class PureComponent<P = {}, S = {}, SS = any> extends Component<P, S, SS> {}\n@deprecated Use `ClassicComponent` from `create-react-class`\n* @see {@link https://legacy.reactjs.org/docs/react-without-es6.html Legacy React Docs}\n@see {@link https://www.npmjs.com/package/create-react-class `create-react-class` on npm}\n     \n    interface ClassicComponent<P = {}, S = {}> extends Component<P, S> {\n        replaceState(nextState: S, callback?: () => void): void;\n        isMounted(): boolean;\n        getInitialState?(): S;\n    }\n\n    //\n    // Class Interfaces\n    // ----------------------------------------------------------------------\nRepresents the type of a function component. Can optionally\nreceive a type argument that represents the props the component\nreceives.\n* @template P The props the component accepts.\n@see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/function_components React TypeScript Cheatsheet}\n@alias for {@link FunctionComponent}\n* @example\n* ```tsx\n// With props:\ntype Props = { name: string }\n* const MyComponent: FC<Props> = (props) => {\nreturn <div>{props.name}</div>\n}\n```\n* @example\n* ```tsx\n// Without props:\nconst MyComponentWithoutProps: FC = () => {\nreturn <div>MyComponentWithoutProps</div>\n}\n```\n     \n    type FC<P = {}> = FunctionComponent<P>;\nRepresents the type of a function component. Can optionally\nreceive a type argument that represents the props the component\naccepts.\n* @template P The props the component accepts.\n@see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/function_components React TypeScript Cheatsheet}\n* @example\n* ```tsx\n// With props:\ntype Props = { name: string }\n* const MyComponent: FunctionComponent<Props> = (props) => {\nreturn <div>{props.name}</div>\n}\n```\n* @example\n* ```tsx\n// Without props:\nconst MyComponentWithoutProps: FunctionComponent = () => {\nreturn <div>MyComponentWithoutProps</div>\n}\n```\n     \n    interface FunctionComponent<P = {}> {\n        (props: P): ReactNode | Promise<ReactNode>;\nIgnored by React.\n@deprecated Only kept in types for backwards compatibility. Will be removed in a future major release.\n         \n        propTypes?: any;\nUsed in debugging messages. You might want to set it\nexplicitly if you want to display a different name for\ndebugging purposes.\n* @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs}\n* @example\n* ```tsx\n* const MyComponent: FC = () => {\nreturn <div>Hello!</div>\n}\n* MyComponent.displayName = 'MyAwesomeComponent'\n```\n         \n        displayName?: string | undefined;\n    }\nThe type of the ref received by a {@link ForwardRefRenderFunction}.\n* @see {@link ForwardRefRenderFunction}\n     \n    // Making T nullable is assuming the refs will be managed by React or the component impl will write it somewhere else.\n    // But this isn't necessarily true. We haven't heard complains about it yet and hopefully `forwardRef` is removed from React before we do.\n    type ForwardedRef<T> = ((instance: T | null) => void) | RefObject<T | null> | null;\nThe type of the function passed to {@link forwardRef}. This is considered different\nto a normal {@link FunctionComponent} because it receives an additional argument,\n* @param props Props passed to the component, if any.\n@param ref A ref forwarded to the component of type {@link ForwardedRef}.\n* @template T The type of the forwarded ref.\n@template P The type of the props the component accepts.\n* @see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/forward_and_create_ref/ React TypeScript Cheatsheet}\n@see {@link forwardRef}\n     \n    interface ForwardRefRenderFunction<T, P = {}> {\n        (props: P, ref: ForwardedRef<T>): ReactNode;\nUsed in debugging messages. You might want to set it\nexplicitly if you want to display a different name for\ndebugging purposes.\n* Will show `ForwardRef(${Component.displayName || Component.name})`\nin devtools by default, but can be given its own specific name.\n* @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs}\n         \n        displayName?: string | undefined;\nIgnored by React.\n@deprecated Only kept in types for backwards compatibility. Will be removed in a future major release.\n         \n        propTypes?: any;\n    }\nRepresents a component class in React.\n* @template P The props the component accepts.\n@template S The internal state of the component.\n     \n    interface ComponentClass<P = {}, S = ComponentState> extends StaticLifecycle<P, S> {\n        // constructor signature must match React.Component\n        new(props: P): Component<P, S>;\nIgnored by React.\n@deprecated Only kept in types for backwards compatibility. Will be removed in a future major release.\n         \n        propTypes?: any;\n        contextType?: Context<any> | undefined;\n        defaultProps?: Partial<P> | undefined;\nUsed in debugging messages. You might want to set it\nexplicitly if you want to display a different name for\ndebugging purposes.\n* @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs}\n         \n        displayName?: string | undefined;\n    }\n@deprecated Use `ClassicComponentClass` from `create-react-class`\n* @see {@link https://legacy.reactjs.org/docs/react-without-es6.html Legacy React Docs}\n@see {@link https://www.npmjs.com/package/create-react-class `create-react-class` on npm}\n     \n    interface ClassicComponentClass<P = {}> extends ComponentClass<P> {\n        new(props: P): ClassicComponent<P, ComponentState>;\n        getDefaultProps?(): P;\n    }\nUsed in {@link createElement} and {@link createFactory} to represent\na class.\n* An intersection type is used to infer multiple type parameters from\na single argument, which is useful for many top-level API defs.\nSee {@link https://github.com/Microsoft/TypeScript/issues/7234 this GitHub issue}\nfor more info.\n     \n    type ClassType<P, T extends Component<P, ComponentState>, C extends ComponentClass<P>> =\n        & C\n        & (new(props: P) => T);\n\n    //\n    // Component Specs and Lifecycle\n    // ----------------------------------------------------------------------\n\n    // This should actually be something like `Lifecycle<P, S> | DeprecatedLifecycle<P, S>`,\n    // as React will _not_ call the deprecated lifecycle methods if any of the new lifecycle\n    // methods are present.\n    interface ComponentLifecycle<P, S, SS = any> extends NewLifecycle<P, S, SS>, DeprecatedLifecycle<P, S> {\nCalled immediately after a component is mounted. Setting state here will trigger re-rendering.\n         \n        componentDidMount?(): void;\nCalled to determine whether the change in props and state should trigger a re-render.\n* `Component` always returns true.\n`PureComponent` implements a shallow comparison on props and state and returns true if any\nprops or states have changed.\n* If false is returned, {@link Component.render}, `componentWillUpdate`\nand `componentDidUpdate` will not be called.\n         \n        shouldComponentUpdate?(nextProps: Readonly<P>, nextState: Readonly<S>, nextContext: any): boolean;\nCalled immediately before a component is destroyed. Perform any necessary cleanup in this method, such as\ncancelled network requests, or cleaning up any DOM elements created in `componentDidMount`.\n         \n        componentWillUnmount?(): void;\nCatches exceptions generated in descendant components. Unhandled exceptions will cause\nthe entire component tree to unmount.\n         \n        componentDidCatch?(error: Error, errorInfo: ErrorInfo): void;\n    }\n\n    // Unfortunately, we have no way of declaring that the component constructor must implement this\n    interface StaticLifecycle<P, S> {\n        getDerivedStateFromProps?: GetDerivedStateFromProps<P, S> | undefined;\n        getDerivedStateFromError?: GetDerivedStateFromError<P, S> | undefined;\n    }\n\n    type GetDerivedStateFromProps<P, S> =\nReturns an update to a component's state based on its new props and old state.\n* Note: its presence prevents any of the deprecated lifecycle methods from being invoked\n         \n        (nextProps: Readonly<P>, prevState: S) => Partial<S> | null;\n\n    type GetDerivedStateFromError<P, S> =\nThis lifecycle is invoked after an error has been thrown by a descendant component.\nIt receives the error that was thrown as a parameter and should return a value to update state.\n* Note: its presence prevents any of the deprecated lifecycle methods from being invoked\n         \n        (error: any) => Partial<S> | null;\n\n    // This should be \"infer SS\" but can't use it yet\n    interface NewLifecycle<P, S, SS> {\nRuns before React applies the result of {@link Component.render render} to the document, and\nreturns an object to be given to {@link componentDidUpdate}. Useful for saving\nthings such as scroll position before {@link Component.render render} causes changes to it.\n* Note: the presence of this method prevents any of the deprecated\nlifecycle events from running.\n         \n        getSnapshotBeforeUpdate?(prevProps: Readonly<P>, prevState: Readonly<S>): SS | null;\nCalled immediately after updating occurs. Not called for the initial render.\n* The snapshot is only present if {@link getSnapshotBeforeUpdate} is present and returns non-null.\n         \n        componentDidUpdate?(prevProps: Readonly<P>, prevState: Readonly<S>, snapshot?: SS): void;\n    }\n\n    interface DeprecatedLifecycle<P, S> {\nCalled immediately before mounting occurs, and before {@link Component.render}.\nAvoid introducing any side-effects or subscriptions in this method.\n* Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate}\nor {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents\nthis from being invoked.\n* @deprecated 16.3, use {@link ComponentLifecycle.componentDidMount componentDidMount} or the constructor instead; will stop working in React 17\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#initializing-state}\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path}\n         \n        componentWillMount?(): void;\nCalled immediately before mounting occurs, and before {@link Component.render}.\nAvoid introducing any side-effects or subscriptions in this method.\n* This method will not stop working in React 17.\n* Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate}\nor {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents\nthis from being invoked.\n* @deprecated 16.3, use {@link ComponentLifecycle.componentDidMount componentDidMount} or the constructor instead\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#initializing-state}\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path}\n         \n        UNSAFE_componentWillMount?(): void;\nCalled when the component may be receiving new props.\nReact may call this even if props have not changed, so be sure to compare new and existing\nprops if you only want to handle changes.\n* Calling {@link Component.setState} generally does not trigger this method.\n* Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate}\nor {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents\nthis from being invoked.\n* @deprecated 16.3, use static {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} instead; will stop working in React 17\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#updating-state-based-on-props}\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path}\n         \n        componentWillReceiveProps?(nextProps: Readonly<P>, nextContext: any): void;\nCalled when the component may be receiving new props.\nReact may call this even if props have not changed, so be sure to compare new and existing\nprops if you only want to handle changes.\n* Calling {@link Component.setState} generally does not trigger this method.\n* This method will not stop working in React 17.\n* Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate}\nor {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents\nthis from being invoked.\n* @deprecated 16.3, use static {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} instead\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#updating-state-based-on-props}\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path}\n         \n        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<P>, nextContext: any): void;\nCalled immediately before rendering when new props or state is received. Not called for the initial render.\n* Note: You cannot call {@link Component.setState} here.\n* Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate}\nor {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents\nthis from being invoked.\n* @deprecated 16.3, use getSnapshotBeforeUpdate instead; will stop working in React 17\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#reading-dom-properties-before-an-update}\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path}\n         \n        componentWillUpdate?(nextProps: Readonly<P>, nextState: Readonly<S>, nextContext: any): void;\nCalled immediately before rendering when new props or state is received. Not called for the initial render.\n* Note: You cannot call {@link Component.setState} here.\n* This method will not stop working in React 17.\n* Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate}\nor {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents\nthis from being invoked.\n* @deprecated 16.3, use getSnapshotBeforeUpdate instead\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#reading-dom-properties-before-an-update}\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path}\n         \n        UNSAFE_componentWillUpdate?(nextProps: Readonly<P>, nextState: Readonly<S>, nextContext: any): void;\n    }\n\n    function createRef<T>(): RefObject<T | null>;\nThe type of the component returned from {@link forwardRef}.\n* @template P The props the component accepts, if any.\n* @see {@link ExoticComponent}\n     \n    interface ForwardRefExoticComponent<P> extends NamedExoticComponent<P> {\nIgnored by React.\n@deprecated Only kept in types for backwards compatibility. Will be removed in a future major release.\n         \n        propTypes?: any;\n    }\nLets your component expose a DOM node to a parent component\nusing a ref.\n* @see {@link https://react.dev/reference/react/forwardRef React Docs}\n@see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/forward_and_create_ref/ React TypeScript Cheatsheet}\n* @param render See the {@link ForwardRefRenderFunction}.\n* @template T The type of the DOM node.\n@template P The props the component accepts, if any.\n* @example\n* ```tsx\ninterface Props {\nchildren?: ReactNode;\ntype: \"submit\" | \"button\";\n}\n* export const FancyButton = forwardRef<HTMLButtonElement, Props>((props, ref) => (\n<button ref={ref} className=\"MyClassName\" type={props.type}>\n{props.children}\n</button>\n));\n```\n     \n    function forwardRef<T, P = {}>(\n        render: ForwardRefRenderFunction<T, PropsWithoutRef<P>>,\n    ): ForwardRefExoticComponent<PropsWithoutRef<P> & RefAttributes<T>>;\nOmits the 'ref' attribute from the given props object.\n* @template Props The props object type.\n     \n    type PropsWithoutRef<Props> =\n        // Omit would not be sufficient for this. We'd like to avoid unnecessary mapping and need a distributive conditional to support unions.\n        // see: https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types\n        // https://github.com/Microsoft/TypeScript/issues/28339\n        Props extends any ? (\"ref\" extends keyof Props ? Omit<Props, \"ref\"> : Props) : Props;\nEnsures that the props do not include string ref, which cannot be forwarded\n@deprecated Use `Props` directly. `PropsWithRef<Props>` is just an alias for `Props`\n     \n    type PropsWithRef<Props> = Props;\n\n    type PropsWithChildren<P = unknown> = P & { children?: ReactNode | undefined };\nUsed to retrieve the props a component accepts. Can either be passed a string,\nindicating a DOM element (e.g. 'div', 'span', etc.) or the type of a React\ncomponent.\n* It's usually better to use {@link ComponentPropsWithRef} or {@link ComponentPropsWithoutRef}\ninstead of this type, as they let you be explicit about whether or not to include\nthe `ref` prop.\n* @see {@link https://react-typescript-cheatsheet.netlify.app/docs/react-types/componentprops/ React TypeScript Cheatsheet}\n* @example\n* ```tsx\n// Retrieves the props an 'input' element accepts\ntype InputProps = React.ComponentProps<'input'>;\n```\n* @example\n* ```tsx\nconst MyComponent = (props: { foo: number, bar: string }) => <div />;\n* // Retrieves the props 'MyComponent' accepts\ntype MyComponentProps = React.ComponentProps<typeof MyComponent>;\n```\n     \n    type ComponentProps<T extends keyof JSX.IntrinsicElements | JSXElementConstructor<any>> = T extends\n        JSXElementConstructor<infer Props> ? Props\n        : T extends keyof JSX.IntrinsicElements ? JSX.IntrinsicElements[T]\n        : {};\nUsed to retrieve the props a component accepts with its ref. Can either be\npassed a string, indicating a DOM element (e.g. 'div', 'span', etc.) or the\ntype of a React component.\n* @see {@link https://react-typescript-cheatsheet.netlify.app/docs/react-types/componentprops/ React TypeScript Cheatsheet}\n* @example\n* ```tsx\n// Retrieves the props an 'input' element accepts\ntype InputProps = React.ComponentPropsWithRef<'input'>;\n```\n* @example\n* ```tsx\nconst MyComponent = (props: { foo: number, bar: string }) => <div />;\n* // Retrieves the props 'MyComponent' accepts\ntype MyComponentPropsWithRef = React.ComponentPropsWithRef<typeof MyComponent>;\n```\n     \n    type ComponentPropsWithRef<T extends ElementType> = T extends JSXElementConstructor<infer Props>\n        // If it's a class i.e. newable we're dealing with a class component\n        ? T extends abstract new(args: any) => any ? PropsWithoutRef<Props> & RefAttributes<InstanceType<T>>\n        : Props\n        : ComponentProps<T>;\nUsed to retrieve the props a custom component accepts with its ref.\n* Unlike {@link ComponentPropsWithRef}, this only works with custom\ncomponents, i.e. components you define yourself. This is to improve\ntype-checking performance.\n* @example\n* ```tsx\nconst MyComponent = (props: { foo: number, bar: string }) => <div />;\n* // Retrieves the props 'MyComponent' accepts\ntype MyComponentPropsWithRef = React.CustomComponentPropsWithRef<typeof MyComponent>;\n```\n     \n    type CustomComponentPropsWithRef<T extends ComponentType> = T extends JSXElementConstructor<infer Props>\n        // If it's a class i.e. newable we're dealing with a class component\n        ? T extends abstract new(args: any) => any ? PropsWithoutRef<Props> & RefAttributes<InstanceType<T>>\n        : Props\n        : never;\nUsed to retrieve the props a component accepts without its ref. Can either be\npassed a string, indicating a DOM element (e.g. 'div', 'span', etc.) or the\ntype of a React component.\n* @see {@link https://react-typescript-cheatsheet.netlify.app/docs/react-types/componentprops/ React TypeScript Cheatsheet}\n* @example\n* ```tsx\n// Retrieves the props an 'input' element accepts\ntype InputProps = React.ComponentPropsWithoutRef<'input'>;\n```\n* @example\n* ```tsx\nconst MyComponent = (props: { foo: number, bar: string }) => <div />;\n* // Retrieves the props 'MyComponent' accepts\ntype MyComponentPropsWithoutRef = React.ComponentPropsWithoutRef<typeof MyComponent>;\n```\n     \n    type ComponentPropsWithoutRef<T extends ElementType> = PropsWithoutRef<ComponentProps<T>>;\nRetrieves the type of the 'ref' prop for a given component type or tag name.\n* @template C The component type.\n* @example\n* ```tsx\ntype MyComponentRef = React.ComponentRef<typeof MyComponent>;\n```\n* @example\n* ```tsx\ntype DivRef = React.ComponentRef<'div'>;\n```\n     \n    type ComponentRef<T extends ElementType> = ComponentPropsWithRef<T> extends RefAttributes<infer Method> ? Method\n        : never;\n\n    // will show `Memo(${Component.displayName || Component.name})` in devtools by default,\n    // but can be given its own specific name\n    type MemoExoticComponent<T extends ComponentType<any>> = NamedExoticComponent<CustomComponentPropsWithRef<T>> & {\n        readonly type: T;\n    };\nLets you skip re-rendering a component when its props are unchanged.\n* @see {@link https://react.dev/reference/react/memo React Docs}\n* @param Component The component to memoize.\n@param propsAreEqual A function that will be used to determine if the props have changed.\n* @example\n* ```tsx\nimport { memo } from 'react';\n* const SomeComponent = memo(function SomeComponent(props: { foo: string }) {\n// ...\n});\n```\n     \n    function memo<P extends object>(\n        Component: FunctionComponent<P>,\n        propsAreEqual?: (prevProps: Readonly<P>, nextProps: Readonly<P>) => boolean,\n    ): NamedExoticComponent<P>;\n    function memo<T extends ComponentType<any>>(\n        Component: T,\n        propsAreEqual?: (prevProps: Readonly<ComponentProps<T>>, nextProps: Readonly<ComponentProps<T>>) => boolean,\n    ): MemoExoticComponent<T>;\n\n    interface LazyExoticComponent<T extends ComponentType<any>>\n        extends ExoticComponent<CustomComponentPropsWithRef<T>>\n    {\n        readonly _result: T;\n    }\nLets you defer loading a component’s code until it is rendered for the first time.\n* @see {@link https://react.dev/reference/react/lazy React Docs}\n* @param load A function that returns a `Promise` or another thenable (a `Promise`-like object with a\nthen method). React will not call `load` until the first time you attempt to render the returned\ncomponent. After React first calls load, it will wait for it to resolve, and then render the\nresolved value’s `.default` as a React component. Both the returned `Promise` and the `Promise`’s\nresolved value will be cached, so React will not call load more than once. If the `Promise` rejects,\nReact will throw the rejection reason for the nearest Error Boundary to handle.\n* @example\n* ```tsx\nimport { lazy } from 'react';\n* const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));\n```\n     \n    function lazy<T extends ComponentType<any>>(\n        load: () => Promise<{ default: T }>,\n    ): LazyExoticComponent<T>;\n\n    //\n    // React Hooks\n    // ----------------------------------------------------------------------\nThe instruction passed to a {@link Dispatch} function in {@link useState}\nto tell React what the next value of the {@link useState} should be.\n* Often found wrapped in {@link Dispatch}.\n* @template S The type of the state.\n* @example\n* ```tsx\n// This return type correctly represents the type of\n// `setCount` in the example below.\nconst useCustomState = (): Dispatch<SetStateAction<number>> => {\nconst [count, setCount] = useState(0);\n*   return setCount;\n}\n```\n     \n    type SetStateAction<S> = S | ((prevState: S) => S);\nA function that can be used to update the state of a {@link useState}\nor {@link useReducer} hook.\n     \n    type Dispatch<A> = (value: A) => void;\nA {@link Dispatch} function can sometimes be called without any arguments.\n     \n    type DispatchWithoutAction = () => void;\n    // Limit the reducer to accept only 0 or 1 action arguments\n    // eslint-disable-next-line @definitelytyped/no-single-element-tuple-type\n    type AnyActionArg = [] | [any];\n    // Get the dispatch type from the reducer arguments (captures optional action argument correctly)\n    type ActionDispatch<ActionArg extends AnyActionArg> = (...args: ActionArg) => void;\n    // Unlike redux, the actions _can_ be anything\n    type Reducer<S, A> = (prevState: S, action: A) => S;\n    // If useReducer accepts a reducer without action, dispatch may be called without any parameters.\n    type ReducerWithoutAction<S> = (prevState: S) => S;\n    // types used to try and prevent the compiler from reducing S\n    // to a supertype common with the second argument to useReducer()\n    type ReducerState<R extends Reducer<any, any>> = R extends Reducer<infer S, any> ? S : never;\n    type DependencyList = readonly unknown[];\n\n    // NOTE: callbacks are _only_ allowed to return either void, or a destructor.\n    type EffectCallback = () => void | Destructor;\n@deprecated Use `RefObject` instead.\n     \n    interface MutableRefObject<T> {\n        current: T;\n    }\n\n    // This will technically work if you give a Consumer<T> or Provider<T> but it's deprecated and warns\nAccepts a context object (the value returned from `React.createContext`) and returns the current\ncontext value, as given by the nearest context provider for the given context.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useContext}\n     \n    function useContext<T>(context: Context<T> /*, (not public API) observedBits?: number|boolean ): T;\nReturns a stateful value, and a function to update it.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useState}\n     \n    function useState<S>(initialState: S | (() => S)): [S, Dispatch<SetStateAction<S>>];\n    // convenience overload when first argument is omitted\nReturns a stateful value, and a function to update it.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useState}\n     \n    function useState<S = undefined>(): [S | undefined, Dispatch<SetStateAction<S | undefined>>];\nAn alternative to `useState`.\n* `useReducer` is usually preferable to `useState` when you have complex state logic that involves\nmultiple sub-values. It also lets you optimize performance for components that trigger deep\nupdates because you can pass `dispatch` down instead of callbacks.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useReducer}\n     \n    function useReducer<S, A extends AnyActionArg>(\n        reducer: (prevState: S, ...args: A) => S,\n        initialState: S,\n    ): [S, ActionDispatch<A>];\nAn alternative to `useState`.\n* `useReducer` is usually preferable to `useState` when you have complex state logic that involves\nmultiple sub-values. It also lets you optimize performance for components that trigger deep\nupdates because you can pass `dispatch` down instead of callbacks.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useReducer}\n     \n    function useReducer<S, A extends AnyActionArg>(\n        reducer: (prevState: S, ...args: A) => S,\n        initialState: S,\n    ): [S, ActionDispatch<A>];\nAn alternative to `useState`.\n* `useReducer` is usually preferable to `useState` when you have complex state logic that involves\nmultiple sub-values. It also lets you optimize performance for components that trigger deep\nupdates because you can pass `dispatch` down instead of callbacks.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useReducer}\n     \n    function useReducer<S, I, A extends AnyActionArg>(\n        reducer: (prevState: S, ...args: A) => S,\n        initialArg: I,\n        init: (i: I) => S,\n    ): [S, ActionDispatch<A>];\n`useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument\n(`initialValue`). The returned object will persist for the full lifetime of the component.\n* Note that `useRef()` is useful for more than the `ref` attribute. It’s handy for keeping any mutable\nvalue around similar to how you’d use instance fields in classes.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useRef}\n     \n    function useRef<T>(initialValue: T): RefObject<T>;\n    // convenience overload for refs given as a ref prop as they typically start with a null value\n`useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument\n(`initialValue`). The returned object will persist for the full lifetime of the component.\n* Note that `useRef()` is useful for more than the `ref` attribute. It’s handy for keeping any mutable\nvalue around similar to how you’d use instance fields in classes.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useRef}\n     \n    function useRef<T>(initialValue: T | null): RefObject<T | null>;\n    // convenience overload for undefined initialValue\n`useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument\n(`initialValue`). The returned object will persist for the full lifetime of the component.\n* Note that `useRef()` is useful for more than the `ref` attribute. It’s handy for keeping any mutable\nvalue around similar to how you’d use instance fields in classes.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useRef}\n     \n    function useRef<T>(initialValue: T | undefined): RefObject<T | undefined>;\nThe signature is identical to `useEffect`, but it fires synchronously after all DOM mutations.\nUse this to read layout from the DOM and synchronously re-render. Updates scheduled inside\n`useLayoutEffect` will be flushed synchronously, before the browser has a chance to paint.\n* Prefer the standard `useEffect` when possible to avoid blocking visual updates.\n* If you’re migrating code from a class component, `useLayoutEffect` fires in the same phase as\n`componentDidMount` and `componentDidUpdate`.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useLayoutEffect}\n     \n    function useLayoutEffect(effect: EffectCallback, deps?: DependencyList): void;\nAccepts a function that contains imperative, possibly effectful code.\n* @param effect Imperative function that can return a cleanup function\n@param deps If present, effect will only activate if the values in the list change.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useEffect}\n     \n    function useEffect(effect: EffectCallback, deps?: DependencyList): void;\n    // NOTE: this does not accept strings, but this will have to be fixed by removing strings from type Ref<T>\n`useImperativeHandle` customizes the instance value that is exposed to parent components when using\n`ref`. As always, imperative code using refs should be avoided in most cases.\n* `useImperativeHandle` should be used with `React.forwardRef`.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useImperativeHandle}\n     \n    function useImperativeHandle<T, R extends T>(ref: Ref<T> | undefined, init: () => R, deps?: DependencyList): void;\n    // I made 'inputs' required here and in useMemo as there's no point to memoizing without the memoization key\n    // useCallback(X) is identical to just using X, useMemo(() => Y) is identical to just using Y.\n`useCallback` will return a memoized version of the callback that only changes if one of the `inputs`\nhas changed.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useCallback}\n     \n    // A specific function type would not trigger implicit any.\n    // See https://github.com/DefinitelyTyped/DefinitelyTyped/issues/52873#issuecomment-845806435 for a comparison between `Function` and more specific types.\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n    function useCallback<T extends Function>(callback: T, deps: DependencyList): T;\n`useMemo` will only recompute the memoized value when one of the `deps` has changed.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useMemo}\n     \n    // allow undefined, but don't make it optional as that is very likely a mistake\n    function useMemo<T>(factory: () => T, deps: DependencyList): T;\n`useDebugValue` can be used to display a label for custom hooks in React DevTools.\n* NOTE: We don’t recommend adding debug values to every custom hook.\nIt’s most valuable for custom hooks that are part of shared libraries.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useDebugValue}\n     \n    // the name of the custom hook is itself derived from the function name at runtime:\n    // it's just the function name without the \"use\" prefix.\n    function useDebugValue<T>(value: T, format?: (value: T) => any): void;\n\n    export type TransitionFunction = () => VoidOrUndefinedOnly | Promise<VoidOrUndefinedOnly>;\n    // strange definition to allow vscode to show documentation on the invocation\n    export interface TransitionStartFunction {\nState updates caused inside the callback are allowed to be deferred.\n* **If some state update causes a component to suspend, that state update should be wrapped in a transition.**\n* @param callback A function which causes state updates that can be deferred.\n         \n        (callback: TransitionFunction): void;\n    }\nReturns a deferred version of the value that may “lag behind” it.\n* This is commonly used to keep the interface responsive when you have something that renders immediately\nbased on user input and something that needs to wait for a data fetch.\n* A good example of this is a text input.\n* @param value The value that is going to be deferred\n@param initialValue A value to use during the initial render of a component. If this option is omitted, `useDeferredValue` will not defer during the initial render, because there’s no previous version of `value` that it can render instead.\n* @see {@link https://react.dev/reference/react/useDeferredValue}\n     \n    export function useDeferredValue<T>(value: T, initialValue?: T): T;\nAllows components to avoid undesirable loading states by waiting for content to load\nbefore transitioning to the next screen. It also allows components to defer slower,\ndata fetching updates until subsequent renders so that more crucial updates can be\nrendered immediately.\n* The `useTransition` hook returns two values in an array.\n* The first is a boolean, React’s way of informing us whether we’re waiting for the transition to finish.\nThe second is a function that takes a callback. We can use it to tell React which state we want to defer.\n* **If some state update causes a component to suspend, that state update should be wrapped in a transition.**\n* @see {@link https://react.dev/reference/react/useTransition}\n     \n    export function useTransition(): [boolean, TransitionStartFunction];\nSimilar to `useTransition` but allows uses where hooks are not available.\n* @param callback A function which causes state updates that can be deferred.\n     \n    export function startTransition(scope: TransitionFunction): void;\nWrap any code rendering and triggering updates to your components into `act()` calls.\n* Ensures that the behavior in your tests matches what happens in the browser\nmore closely by executing pending `useEffect`s before returning. This also\nreduces the amount of re-renders done.\n* @param callback A synchronous, void callback that will execute as a single, complete React commit.\n* @see https://reactjs.org/blog/2019/02/06/react-v16.8.0.html#testing-hooks\n     \n    // NOTES\n    // - the order of these signatures matters - typescript will check the signatures in source order.\n    //   If the `() => VoidOrUndefinedOnly` signature is first, it'll erroneously match a Promise returning function for users with\n    //   `strictNullChecks: false`.\n    // - VoidOrUndefinedOnly is there to forbid any non-void return values for users with `strictNullChecks: true`\n    // While act does always return Thenable, if a void function is passed, we pretend the return value is also void to not trigger dangling Promise lint rules.\n    export function act(callback: () => VoidOrUndefinedOnly): void;\n    export function act<T>(callback: () => T | Promise<T>): Promise<T>;\n\n    export function useId(): string;\n@param effect Imperative function that can return a cleanup function\n@param deps If present, effect will only activate if the values in the list change.\n* @see {@link https://github.com/facebook/react/pull/21913}\n\nNew source code:\n\n```typescript\nfunction useInsertionEffect\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Used to represent DOM API's where users can either pass\ntrue or false as a boolean or as its equivalent strings.\n \ntype Booleanish = boolean | \"true\" | \"false\";\n@see {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/crossorigin MDN}\n \ntype CrossOrigin = \"anonymous\" | \"use-credentials\" | \"\" | undefined;\n\ndeclare const UNDEFINED_VOID_ONLY: unique symbol;\n@internal Use `Awaited<ReactNode>` instead\n \n// Helper type to enable `Awaited<ReactNode>`.\n// Must be a copy of the non-thenables of `ReactNode`.\ntype AwaitedReactNode =\n    | React.ReactElement\n    | string\n    | number\n    | bigint\n    | Iterable<React.ReactNode>\n    | React.ReactPortal\n    | boolean\n    | null\n    | undefined\n    | React.DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES[\n        keyof React.DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES\n    ];\nThe function returned from an effect passed to {@link React.useEffect useEffect},\nwhich can be used to clean up the effect when the component unmounts.\n* @see {@link https://react.dev/reference/react/useEffect React Docs}\n \ntype Destructor = () => void | { [UNDEFINED_VOID_ONLY]: never };\ntype VoidOrUndefinedOnly = void | { [UNDEFINED_VOID_ONLY]: never };\n\n// eslint-disable-next-line @definitelytyped/export-just-namespace\nexport = React;\nexport as namespace React;\n\ndeclare namespace React {\n    //\n    // React Elements\n    // ----------------------------------------------------------------------\nUsed to retrieve the possible components which accept a given set of props.\n* Can be passed no type parameters to get a union of all possible components\nand tags.\n* Is a superset of {@link ComponentType}.\n* @template P The props to match against. If not passed, defaults to any.\n@template Tag An optional tag to match against. If not passed, attempts to match against all possible tags.\n* @example\n* ```tsx\n// All components and tags (img, embed etc.)\n// which accept `src`\ntype SrcComponents = ElementType<{ src: any }>;\n```\n* @example\n* ```tsx\n// All components\ntype AllComponents = ElementType;\n```\n* @example\n* ```tsx\n// All custom components which match `src`, and tags which\n// match `src`, narrowed down to just `audio` and `embed`\ntype SrcComponents = ElementType<{ src: any }, 'audio' | 'embed'>;\n```\n     \n    type ElementType<P = any, Tag extends keyof JSX.IntrinsicElements = keyof JSX.IntrinsicElements> =\n        | { [K in Tag]: P extends JSX.IntrinsicElements[K] ? K : never }[Tag]\n        | ComponentType<P>;\nRepresents any user-defined component, either as a function or a class.\n* Similar to {@link JSXElementConstructor}, but with extra properties like\n{@link FunctionComponent.defaultProps defaultProps }.\n* @template P The props the component accepts.\n* @see {@link ComponentClass}\n@see {@link FunctionComponent}\n     \n    type ComponentType<P = {}> = ComponentClass<P> | FunctionComponent<P>;\nRepresents any user-defined component, either as a function or a class.\n* Similar to {@link ComponentType}, but without extra properties like\n{@link FunctionComponent.defaultProps defaultProps }.\n* @template P The props the component accepts.\n     \n    type JSXElementConstructor<P> =\n        | ((\n            props: P,\n        ) => ReactNode | Promise<ReactNode>)\n        // constructor signature must match React.Component\n        | (new(props: P) => Component<any, any>);\nCreated by {@link createRef}, or {@link useRef} when passed `null`.\n* @template T The type of the ref's value.\n* @example\n* ```tsx\nconst ref = createRef<HTMLDivElement>();\n* ref.current = document.createElement('div'); // Error\n```\n     \n    interface RefObject<T> {\nThe current value of the ref.\n         \n        current: T;\n    }\n\n    interface DO_NOT_USE_OR_YOU_WILL_BE_FIRED_CALLBACK_REF_RETURN_VALUES {\n    }\nA callback fired whenever the ref's value changes.\n* @template T The type of the ref's value.\n* @see {@link https://react.dev/reference/react-dom/components/common#ref-callback React Docs}\n* @example\n* ```tsx\n<div ref={(node) => console.log(node)} />\n```\n     \n    type RefCallback<T> = {\n        bivarianceHack(\n            instance: T | null,\n        ):\n            | void\n            | (() => VoidOrUndefinedOnly)\n            | DO_NOT_USE_OR_YOU_WILL_BE_FIRED_CALLBACK_REF_RETURN_VALUES[\n                keyof DO_NOT_USE_OR_YOU_WILL_BE_FIRED_CALLBACK_REF_RETURN_VALUES\n            ];\n    }[\"bivarianceHack\"];\nA union type of all possible shapes for React refs.\n* @see {@link RefCallback}\n@see {@link RefObject}\n     \n\n    type Ref<T> = RefCallback<T> | RefObject<T | null> | null;\n@deprecated Use `Ref` instead. String refs are no longer supported.\nIf you're typing a library with support for React versions with string refs, use `RefAttributes<T>['ref']` instead.\n     \n    type LegacyRef<T> = Ref<T>;\n@deprecated Use `ComponentRef<T>` instead\n* Retrieves the type of the 'ref' prop for a given component type or tag name.\n* @template C The component type.\n* @example\n* ```tsx\ntype MyComponentRef = React.ElementRef<typeof MyComponent>;\n```\n* @example\n* ```tsx\ntype DivRef = React.ElementRef<'div'>;\n```\n     \n    type ElementRef<\n        C extends\n            | ForwardRefExoticComponent<any>\n            | { new(props: any): Component<any> }\n            | ((props: any) => ReactNode)\n            | keyof JSX.IntrinsicElements,\n    > = ComponentRef<C>;\n\n    type ComponentState = any;\nA value which uniquely identifies a node among items in an array.\n* @see {@link https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key React Docs}\n     \n    type Key = string | number | bigint;\n@internal The props any component can receive.\nYou don't have to add this type. All components automatically accept these props.\n```tsx\nconst Component = () => <div />;\n<Component key=\"one\" />\n```\n* WARNING: The implementation of a component will never have access to these attributes.\nThe following example would be incorrect usage because {@link Component} would never have access to `key`:\n```tsx\nconst Component = (props: React.Attributes) => props.key;\n```\n     \n    interface Attributes {\n        key?: Key | null | undefined;\n    }\nThe props any component accepting refs can receive.\nClass components, built-in browser components (e.g. `div`) and forwardRef components can receive refs and automatically accept these props.\n```tsx\nconst Component = forwardRef(() => <div />);\n<Component ref={(current) => console.log(current)} />\n```\n* You only need this type if you manually author the types of props that need to be compatible with legacy refs.\n```tsx\ninterface Props extends React.RefAttributes<HTMLDivElement> {}\ndeclare const Component: React.FunctionComponent<Props>;\n```\n* Otherwise it's simpler to directly use {@link Ref} since you can safely use the\nprops type to describe to props that a consumer can pass to the component\nas well as describing the props the implementation of a component \"sees\".\n{@link RefAttributes} is generally not safe to describe both consumer and seen props.\n* ```tsx\ninterface Props extends {\nref?: React.Ref<HTMLDivElement> | undefined;\n}\ndeclare const Component: React.FunctionComponent<Props>;\n```\n* WARNING: The implementation of a component will not have access to the same type in versions of React supporting string refs.\nThe following example would be incorrect usage because {@link Component} would never have access to a `ref` with type `string`\n```tsx\nconst Component = (props: React.RefAttributes) => props.ref;\n```\n     \n    interface RefAttributes<T> extends Attributes {\nAllows getting a ref to the component instance.\nOnce the component unmounts, React will set `ref.current` to `null`\n(or call the ref with `null` if you passed a callback ref).\n* @see {@link https://react.dev/learn/referencing-values-with-refs#refs-and-the-dom React Docs}\n         \n        ref?: Ref<T> | undefined;\n    }\nRepresents the built-in attributes available to class components.\n     \n    interface ClassAttributes<T> extends RefAttributes<T> {\n    }\nRepresents a JSX element.\n* Where {@link ReactNode} represents everything that can be rendered, `ReactElement`\nonly represents JSX.\n* @template P The type of the props object\n@template T The type of the component or tag\n* @example\n* ```tsx\nconst element: ReactElement = <div />;\n```\n     \n    interface ReactElement<\n        P = unknown,\n        T extends string | JSXElementConstructor<any> = string | JSXElementConstructor<any>,\n    > {\n        type: T;\n        props: P;\n        key: string | null;\n    }\n@deprecated\n     \n    interface ReactComponentElement<\n        T extends keyof JSX.IntrinsicElements | JSXElementConstructor<any>,\n        P = Pick<ComponentProps<T>, Exclude<keyof ComponentProps<T>, \"key\" | \"ref\">>,\n    > extends ReactElement<P, Exclude<T, number>> {}\n@deprecated Use `ReactElement<P, React.FunctionComponent<P>>`\n     \n    interface FunctionComponentElement<P> extends ReactElement<P, FunctionComponent<P>> {\n@deprecated Use `element.props.ref` instead.\n         \n        ref?: (\"ref\" extends keyof P ? P extends { ref?: infer R | undefined } ? R : never : never) | undefined;\n    }\n@deprecated Use `ReactElement<P, React.ComponentClass<P>>`\n     \n    type CElement<P, T extends Component<P, ComponentState>> = ComponentElement<P, T>;\n@deprecated Use `ReactElement<P, React.ComponentClass<P>>`\n     \n    interface ComponentElement<P, T extends Component<P, ComponentState>> extends ReactElement<P, ComponentClass<P>> {\n@deprecated Use `element.props.ref` instead.\n         \n        ref?: Ref<T> | undefined;\n    }\n@deprecated Use {@link ComponentElement} instead.\n     \n    type ClassicElement<P> = CElement<P, ClassicComponent<P, ComponentState>>;\n\n    // string fallback for custom web-components\n@deprecated Use `ReactElement<P, string>`\n     \n    interface DOMElement<P extends HTMLAttributes<T> | SVGAttributes<T>, T extends Element>\n        extends ReactElement<P, string>\n    {\n@deprecated Use `element.props.ref` instead.\n         \n        ref: Ref<T>;\n    }\n\n    // ReactHTML for ReactHTMLElement\n    interface ReactHTMLElement<T extends HTMLElement> extends DetailedReactHTMLElement<AllHTMLAttributes<T>, T> {}\n\n    interface DetailedReactHTMLElement<P extends HTMLAttributes<T>, T extends HTMLElement> extends DOMElement<P, T> {\n        type: HTMLElementType;\n    }\n\n    // ReactSVG for ReactSVGElement\n    interface ReactSVGElement extends DOMElement<SVGAttributes<SVGElement>, SVGElement> {\n        type: SVGElementType;\n    }\n\n    interface ReactPortal extends ReactElement {\n        children: ReactNode;\n    }\nDifferent release channels declare additional types of ReactNode this particular release channel accepts.\nApp or library types should never augment this interface.\n     \n    interface DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES {}\nRepresents all of the things React can render.\n* Where {@link ReactElement} only represents JSX, `ReactNode` represents everything that can be rendered.\n* @see {@link https://react-typescript-cheatsheet.netlify.app/docs/react-types/reactnode/ React TypeScript Cheatsheet}\n* @example\n* ```tsx\n// Typing children\ntype Props = { children: ReactNode }\n* const Component = ({ children }: Props) => <div>{children}</div>\n* <Component>hello</Component>\n```\n* @example\n* ```tsx\n// Typing a custom element\ntype Props = { customElement: ReactNode }\n* const Component = ({ customElement }: Props) => <div>{customElement}</div>\n* <Component customElement={<div>hello</div>} />\n```\n     \n    // non-thenables need to be kept in sync with AwaitedReactNode\n    type ReactNode =\n        | ReactElement\n        | string\n        | number\n        | bigint\n        | Iterable<ReactNode>\n        | ReactPortal\n        | boolean\n        | null\n        | undefined\n        | DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES[\n            keyof DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES\n        ]\n        | Promise<AwaitedReactNode>;\n\n    //\n    // Top Level API\n    // ----------------------------------------------------------------------\n\n    // DOM Elements\n    // TODO: generalize this to everything in `keyof ReactHTML`, not just \"input\"\n    function createElement(\n        type: \"input\",\n        props?: InputHTMLAttributes<HTMLInputElement> & ClassAttributes<HTMLInputElement> | null,\n        ...children: ReactNode[]\n    ): DetailedReactHTMLElement<InputHTMLAttributes<HTMLInputElement>, HTMLInputElement>;\n    function createElement<P extends HTMLAttributes<T>, T extends HTMLElement>(\n        type: HTMLElementType,\n        props?: ClassAttributes<T> & P | null,\n        ...children: ReactNode[]\n    ): DetailedReactHTMLElement<P, T>;\n    function createElement<P extends SVGAttributes<T>, T extends SVGElement>(\n        type: SVGElementType,\n        props?: ClassAttributes<T> & P | null,\n        ...children: ReactNode[]\n    ): ReactSVGElement;\n    function createElement<P extends DOMAttributes<T>, T extends Element>(\n        type: string,\n        props?: ClassAttributes<T> & P | null,\n        ...children: ReactNode[]\n    ): DOMElement<P, T>;\n\n    // Custom components\n\n    function createElement<P extends {}>(\n        type: FunctionComponent<P>,\n        props?: Attributes & P | null,\n        ...children: ReactNode[]\n    ): FunctionComponentElement<P>;\n    function createElement<P extends {}, T extends Component<P, ComponentState>, C extends ComponentClass<P>>(\n        type: ClassType<P, T, C>,\n        props?: ClassAttributes<T> & P | null,\n        ...children: ReactNode[]\n    ): CElement<P, T>;\n    function createElement<P extends {}>(\n        type: FunctionComponent<P> | ComponentClass<P> | string,\n        props?: Attributes & P | null,\n        ...children: ReactNode[]\n    ): ReactElement<P>;\n\n    // DOM Elements\n    // ReactHTMLElement\n    function cloneElement<P extends HTMLAttributes<T>, T extends HTMLElement>(\n        element: DetailedReactHTMLElement<P, T>,\n        props?: P,\n        ...children: ReactNode[]\n    ): DetailedReactHTMLElement<P, T>;\n    // ReactHTMLElement, less specific\n    function cloneElement<P extends HTMLAttributes<T>, T extends HTMLElement>(\n        element: ReactHTMLElement<T>,\n        props?: P,\n        ...children: ReactNode[]\n    ): ReactHTMLElement<T>;\n    // SVGElement\n    function cloneElement<P extends SVGAttributes<T>, T extends SVGElement>(\n        element: ReactSVGElement,\n        props?: P,\n        ...children: ReactNode[]\n    ): ReactSVGElement;\n    // DOM Element (has to be the last, because type checking stops at first overload that fits)\n    function cloneElement<P extends DOMAttributes<T>, T extends Element>(\n        element: DOMElement<P, T>,\n        props?: DOMAttributes<T> & P,\n        ...children: ReactNode[]\n    ): DOMElement<P, T>;\n\n    // Custom components\n    function cloneElement<P>(\n        element: FunctionComponentElement<P>,\n        props?: Partial<P> & Attributes,\n        ...children: ReactNode[]\n    ): FunctionComponentElement<P>;\n    function cloneElement<P, T extends Component<P, ComponentState>>(\n        element: CElement<P, T>,\n        props?: Partial<P> & ClassAttributes<T>,\n        ...children: ReactNode[]\n    ): CElement<P, T>;\n    function cloneElement<P>(\n        element: ReactElement<P>,\n        props?: Partial<P> & Attributes,\n        ...children: ReactNode[]\n    ): ReactElement<P>;\nDescribes the props accepted by a Context {@link Provider}.\n* @template T The type of the value the context provides.\n     \n    interface ProviderProps<T> {\n        value: T;\n        children?: ReactNode | undefined;\n    }\nDescribes the props accepted by a Context {@link Consumer}.\n* @template T The type of the value the context provides.\n     \n    interface ConsumerProps<T> {\n        children: (value: T) => ReactNode;\n    }\nAn object masquerading as a component. These are created by functions\nlike {@link forwardRef}, {@link memo}, and {@link createContext}.\n* In order to make TypeScript work, we pretend that they are normal\ncomponents.\n* But they are, in fact, not callable - instead, they are objects which\nare treated specially by the renderer.\n* @template P The props the component accepts.\n     \n    interface ExoticComponent<P = {}> {\n        (props: P): ReactNode;\n        readonly $$typeof: symbol;\n    }\nAn {@link ExoticComponent} with a `displayName` property applied to it.\n* @template P The props the component accepts.\n     \n    interface NamedExoticComponent<P = {}> extends ExoticComponent<P> {\nUsed in debugging messages. You might want to set it\nexplicitly if you want to display a different name for\ndebugging purposes.\n* @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs}\n         \n        displayName?: string | undefined;\n    }\nAn {@link ExoticComponent} with a `propTypes` property applied to it.\n* @template P The props the component accepts.\n     \n    interface ProviderExoticComponent<P> extends ExoticComponent<P> {\n    }\nUsed to retrieve the type of a context object from a {@link Context}.\n* @template C The context object.\n* @example\n* ```tsx\nimport { createContext } from 'react';\n* const MyContext = createContext({ foo: 'bar' });\n* type ContextType = ContextType<typeof MyContext>;\n// ContextType = { foo: string }\n```\n     \n    type ContextType<C extends Context<any>> = C extends Context<infer T> ? T : never;\nWraps your components to specify the value of this context for all components inside.\n* @see {@link https://react.dev/reference/react/createContext#provider React Docs}\n* @example\n* ```tsx\nimport { createContext } from 'react';\n* const ThemeContext = createContext('light');\n* function App() {\nreturn (\n<ThemeContext.Provider value=\"dark\">\n<Toolbar />\n</ThemeContext.Provider>\n);\n}\n```\n     \n    type Provider<T> = ProviderExoticComponent<ProviderProps<T>>;\nThe old way to read context, before {@link useContext} existed.\n* @see {@link https://react.dev/reference/react/createContext#consumer React Docs}\n* @example\n* ```tsx\nimport { UserContext } from './user-context';\n* function Avatar() {\nreturn (\n<UserContext.Consumer>\n{user => <img src={user.profileImage} alt={user.name} />}\n</UserContext.Consumer>\n);\n}\n```\n     \n    type Consumer<T> = ExoticComponent<ConsumerProps<T>>;\nContext lets components pass information deep down without explicitly\npassing props.\n* Created from {@link createContext}\n* @see {@link https://react.dev/learn/passing-data-deeply-with-context React Docs}\n@see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/context/ React TypeScript Cheatsheet}\n* @example\n* ```tsx\nimport { createContext } from 'react';\n* const ThemeContext = createContext('light');\n```\n     \n    interface Context<T> extends Provider<T> {\n        Provider: Provider<T>;\n        Consumer: Consumer<T>;\nUsed in debugging messages. You might want to set it\nexplicitly if you want to display a different name for\ndebugging purposes.\n* @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs}\n         \n        displayName?: string | undefined;\n    }\nLets you create a {@link Context} that components can provide or read.\n* @param defaultValue The value you want the context to have when there is no matching\n{@link Provider} in the tree above the component reading the context. This is meant\nas a \"last resort\" fallback.\n* @see {@link https://react.dev/reference/react/createContext#reference React Docs}\n@see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/context/ React TypeScript Cheatsheet}\n* @example\n* ```tsx\nimport { createContext } from 'react';\n* const ThemeContext = createContext('light');\nfunction App() {\nreturn (\n<ThemeContext value=\"dark\">\n<Toolbar />\n</ThemeContext>\n);\n}\n```\n     \n    function createContext<T>(\n        // If you thought this should be optional, see\n        // https://github.com/DefinitelyTyped/DefinitelyTyped/pull/24509#issuecomment-382213106\n        defaultValue: T,\n    ): Context<T>;\n\n    function isValidElement<P>(object: {} | null | undefined): object is ReactElement<P>;\n\n    const Children: {\n        map<T, C>(\n            children: C | readonly C[],\n            fn: (child: C, index: number) => T,\n        ): C extends null | undefined ? C : Array<Exclude<T, boolean | null | undefined>>;\n        forEach<C>(children: C | readonly C[], fn: (child: C, index: number) => void): void;\n        count(children: any): number;\n        only<C>(children: C): C extends any[] ? never : C;\n        toArray(children: ReactNode | ReactNode[]): Array<Exclude<ReactNode, boolean | null | undefined>>;\n    };\n\n    export interface FragmentProps {\n        children?: React.ReactNode;\n    }\nLets you group elements without a wrapper node.\n* @see {@link https://react.dev/reference/react/Fragment React Docs}\n* @example\n* ```tsx\nimport { Fragment } from 'react';\n* <Fragment>\n<td>Hello</td>\n<td>World</td>\n</Fragment>\n```\n* @example\n* ```tsx\n// Using the <></> shorthand syntax:\n* <>\n<td>Hello</td>\n<td>World</td>\n</>\n```\n     \n    const Fragment: ExoticComponent<FragmentProps>;\nLets you find common bugs in your components early during development.\n* @see {@link https://react.dev/reference/react/StrictMode React Docs}\n* @example\n* ```tsx\nimport { StrictMode } from 'react';\n* <StrictMode>\n<App />\n</StrictMode>\n```\n     \n    const StrictMode: ExoticComponent<{ children?: ReactNode | undefined }>;\nThe props accepted by {@link Suspense}.\n* @see {@link https://react.dev/reference/react/Suspense React Docs}\n     \n    interface SuspenseProps {\n        children?: ReactNode | undefined;\n\n         A fallback react tree to show when a Suspense child (like React.lazy) suspends \n        fallback?: ReactNode;\nA name for this Suspense boundary for instrumentation purposes.\nThe name will help identify this boundary in React DevTools.\n         \n        name?: string | undefined;\n    }\nLets you display a fallback until its children have finished loading.\n* @see {@link https://react.dev/reference/react/Suspense React Docs}\n* @example\n* ```tsx\nimport { Suspense } from 'react';\n* <Suspense fallback={<Loading />}>\n<ProfileDetails />\n</Suspense>\n```\n     \n    const Suspense: ExoticComponent<SuspenseProps>;\n    const version: string;\nThe callback passed to {@link ProfilerProps.onRender}.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n     \n    type ProfilerOnRenderCallback = (\nThe string id prop of the {@link Profiler} tree that has just committed. This lets\nyou identify which part of the tree was committed if you are using multiple\nprofilers.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n         \n        id: string,\nThis lets you know whether the tree has just been mounted for the first time\nor re-rendered due to a change in props, state, or hooks.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n         \n        phase: \"mount\" | \"update\" | \"nested-update\",\nThe number of milliseconds spent rendering the {@link Profiler} and its descendants\nfor the current update. This indicates how well the subtree makes use of\nmemoization (e.g. {@link memo} and {@link useMemo}). Ideally this value should decrease\nsignificantly after the initial mount as many of the descendants will only need to\nre-render if their specific props change.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n         \n        actualDuration: number,\nThe number of milliseconds estimating how much time it would take to re-render the entire\n{@link Profiler} subtree without any optimizations. It is calculated by summing up the most\nrecent render durations of each component in the tree. This value estimates a worst-case\ncost of rendering (e.g. the initial mount or a tree with no memoization). Compare\n{@link actualDuration} against it to see if memoization is working.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n         \n        baseDuration: number,\nA numeric timestamp for when React began rendering the current update.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n         \n        startTime: number,\nA numeric timestamp for when React committed the current update. This value is shared\nbetween all profilers in a commit, enabling them to be grouped if desirable.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n         \n        commitTime: number,\n    ) => void;\nThe props accepted by {@link Profiler}.\n* @see {@link https://react.dev/reference/react/Profiler React Docs}\n     \n    interface ProfilerProps {\n        children?: ReactNode | undefined;\n        id: string;\n        onRender: ProfilerOnRenderCallback;\n    }\nLets you measure rendering performance of a React tree programmatically.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n* @example\n* ```tsx\n<Profiler id=\"App\" onRender={onRender}>\n<App />\n</Profiler>\n```\n     \n    const Profiler: ExoticComponent<ProfilerProps>;\n\n    //\n    // Component API\n    // ----------------------------------------------------------------------\n\n    type ReactInstance = Component<any> | Element;\n\n    // Base component for plain JS classes\n    interface Component<P = {}, S = {}, SS = any> extends ComponentLifecycle<P, S, SS> {}\n    class Component<P, S> {\nIf set, `this.context` will be set at runtime to the current value of the given Context.\n* @example\n* ```ts\ntype MyContext = number\nconst Ctx = React.createContext<MyContext>(0)\n* class Foo extends React.Component {\nstatic contextType = Ctx\ncontext!: React.ContextType<typeof Ctx>\nrender () {\nreturn <>My context's value: {this.context}</>;\n}\n}\n```\n* @see {@link https://react.dev/reference/react/Component#static-contexttype}\n         \n        static contextType?: Context<any> | undefined;\nIgnored by React.\n@deprecated Only kept in types for backwards compatibility. Will be removed in a future major release.\n         \n        static propTypes?: any;\nIf using the new style context, re-declare this in your class to be the\n`React.ContextType` of your `static contextType`.\nShould be used with type annotation or static contextType.\n* @example\n```ts\nstatic contextType = MyContext\n// For TS pre-3.7:\ncontext!: React.ContextType<typeof MyContext>\n// For TS 3.7 and above:\ndeclare context: React.ContextType<typeof MyContext>\n```\n* @see {@link https://react.dev/reference/react/Component#context React Docs}\n         \n        context: unknown;\n\n        // Keep in sync with constructor signature of JSXElementConstructor and ComponentClass.\n        constructor(props: P);\n\n        // We MUST keep setState() as a unified signature because it allows proper checking of the method return type.\n        // See: https://github.com/DefinitelyTyped/DefinitelyTyped/issues/18365#issuecomment-351013257\n        // Also, the ` | S` allows intellisense to not be dumbisense\n        setState<K extends keyof S>(\n            state: ((prevState: Readonly<S>, props: Readonly<P>) => Pick<S, K> | S | null) | (Pick<S, K> | S | null),\n            callback?: () => void,\n        ): void;\n\n        forceUpdate(callback?: () => void): void;\n        render(): ReactNode;\n\n        readonly props: Readonly<P>;\n        state: Readonly<S>;\n    }\n\n    class PureComponent<P = {}, S = {}, SS = any> extends Component<P, S, SS> {}\n@deprecated Use `ClassicComponent` from `create-react-class`\n* @see {@link https://legacy.reactjs.org/docs/react-without-es6.html Legacy React Docs}\n@see {@link https://www.npmjs.com/package/create-react-class `create-react-class` on npm}\n     \n    interface ClassicComponent<P = {}, S = {}> extends Component<P, S> {\n        replaceState(nextState: S, callback?: () => void): void;\n        isMounted(): boolean;\n        getInitialState?(): S;\n    }\n\n    //\n    // Class Interfaces\n    // ----------------------------------------------------------------------\nRepresents the type of a function component. Can optionally\nreceive a type argument that represents the props the component\nreceives.\n* @template P The props the component accepts.\n@see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/function_components React TypeScript Cheatsheet}\n@alias for {@link FunctionComponent}\n* @example\n* ```tsx\n// With props:\ntype Props = { name: string }\n* const MyComponent: FC<Props> = (props) => {\nreturn <div>{props.name}</div>\n}\n```\n* @example\n* ```tsx\n// Without props:\nconst MyComponentWithoutProps: FC = () => {\nreturn <div>MyComponentWithoutProps</div>\n}\n```\n     \n    type FC<P = {}> = FunctionComponent<P>;\nRepresents the type of a function component. Can optionally\nreceive a type argument that represents the props the component\naccepts.\n* @template P The props the component accepts.\n@see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/function_components React TypeScript Cheatsheet}\n* @example\n* ```tsx\n// With props:\ntype Props = { name: string }\n* const MyComponent: FunctionComponent<Props> = (props) => {\nreturn <div>{props.name}</div>\n}\n```\n* @example\n* ```tsx\n// Without props:\nconst MyComponentWithoutProps: FunctionComponent = () => {\nreturn <div>MyComponentWithoutProps</div>\n}\n```\n     \n    interface FunctionComponent<P = {}> {\n        (props: P): ReactNode | Promise<ReactNode>;\nIgnored by React.\n@deprecated Only kept in types for backwards compatibility. Will be removed in a future major release.\n         \n        propTypes?: any;\nUsed in debugging messages. You might want to set it\nexplicitly if you want to display a different name for\ndebugging purposes.\n* @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs}\n* @example\n* ```tsx\n* const MyComponent: FC = () => {\nreturn <div>Hello!</div>\n}\n* MyComponent.displayName = 'MyAwesomeComponent'\n```\n         \n        displayName?: string | undefined;\n    }\nThe type of the ref received by a {@link ForwardRefRenderFunction}.\n* @see {@link ForwardRefRenderFunction}\n     \n    // Making T nullable is assuming the refs will be managed by React or the component impl will write it somewhere else.\n    // But this isn't necessarily true. We haven't heard complains about it yet and hopefully `forwardRef` is removed from React before we do.\n    type ForwardedRef<T> = ((instance: T | null) => void) | RefObject<T | null> | null;\nThe type of the function passed to {@link forwardRef}. This is considered different\nto a normal {@link FunctionComponent} because it receives an additional argument,\n* @param props Props passed to the component, if any.\n@param ref A ref forwarded to the component of type {@link ForwardedRef}.\n* @template T The type of the forwarded ref.\n@template P The type of the props the component accepts.\n* @see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/forward_and_create_ref/ React TypeScript Cheatsheet}\n@see {@link forwardRef}\n     \n    interface ForwardRefRenderFunction<T, P = {}> {\n        (props: P, ref: ForwardedRef<T>): ReactNode;\nUsed in debugging messages. You might want to set it\nexplicitly if you want to display a different name for\ndebugging purposes.\n* Will show `ForwardRef(${Component.displayName || Component.name})`\nin devtools by default, but can be given its own specific name.\n* @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs}\n         \n        displayName?: string | undefined;\nIgnored by React.\n@deprecated Only kept in types for backwards compatibility. Will be removed in a future major release.\n         \n        propTypes?: any;\n    }\nRepresents a component class in React.\n* @template P The props the component accepts.\n@template S The internal state of the component.\n     \n    interface ComponentClass<P = {}, S = ComponentState> extends StaticLifecycle<P, S> {\n        // constructor signature must match React.Component\n        new(props: P): Component<P, S>;\nIgnored by React.\n@deprecated Only kept in types for backwards compatibility. Will be removed in a future major release.\n         \n        propTypes?: any;\n        contextType?: Context<any> | undefined;\n        defaultProps?: Partial<P> | undefined;\nUsed in debugging messages. You might want to set it\nexplicitly if you want to display a different name for\ndebugging purposes.\n* @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs}\n         \n        displayName?: string | undefined;\n    }\n@deprecated Use `ClassicComponentClass` from `create-react-class`\n* @see {@link https://legacy.reactjs.org/docs/react-without-es6.html Legacy React Docs}\n@see {@link https://www.npmjs.com/package/create-react-class `create-react-class` on npm}\n     \n    interface ClassicComponentClass<P = {}> extends ComponentClass<P> {\n        new(props: P): ClassicComponent<P, ComponentState>;\n        getDefaultProps?(): P;\n    }\nUsed in {@link createElement} and {@link createFactory} to represent\na class.\n* An intersection type is used to infer multiple type parameters from\na single argument, which is useful for many top-level API defs.\nSee {@link https://github.com/Microsoft/TypeScript/issues/7234 this GitHub issue}\nfor more info.\n     \n    type ClassType<P, T extends Component<P, ComponentState>, C extends ComponentClass<P>> =\n        & C\n        & (new(props: P) => T);\n\n    //\n    // Component Specs and Lifecycle\n    // ----------------------------------------------------------------------\n\n    // This should actually be something like `Lifecycle<P, S> | DeprecatedLifecycle<P, S>`,\n    // as React will _not_ call the deprecated lifecycle methods if any of the new lifecycle\n    // methods are present.\n    interface ComponentLifecycle<P, S, SS = any> extends NewLifecycle<P, S, SS>, DeprecatedLifecycle<P, S> {\nCalled immediately after a component is mounted. Setting state here will trigger re-rendering.\n         \n        componentDidMount?(): void;\nCalled to determine whether the change in props and state should trigger a re-render.\n* `Component` always returns true.\n`PureComponent` implements a shallow comparison on props and state and returns true if any\nprops or states have changed.\n* If false is returned, {@link Component.render}, `componentWillUpdate`\nand `componentDidUpdate` will not be called.\n         \n        shouldComponentUpdate?(nextProps: Readonly<P>, nextState: Readonly<S>, nextContext: any): boolean;\nCalled immediately before a component is destroyed. Perform any necessary cleanup in this method, such as\ncancelled network requests, or cleaning up any DOM elements created in `componentDidMount`.\n         \n        componentWillUnmount?(): void;\nCatches exceptions generated in descendant components. Unhandled exceptions will cause\nthe entire component tree to unmount.\n         \n        componentDidCatch?(error: Error, errorInfo: ErrorInfo): void;\n    }\n\n    // Unfortunately, we have no way of declaring that the component constructor must implement this\n    interface StaticLifecycle<P, S> {\n        getDerivedStateFromProps?: GetDerivedStateFromProps<P, S> | undefined;\n        getDerivedStateFromError?: GetDerivedStateFromError<P, S> | undefined;\n    }\n\n    type GetDerivedStateFromProps<P, S> =\nReturns an update to a component's state based on its new props and old state.\n* Note: its presence prevents any of the deprecated lifecycle methods from being invoked\n         \n        (nextProps: Readonly<P>, prevState: S) => Partial<S> | null;\n\n    type GetDerivedStateFromError<P, S> =\nThis lifecycle is invoked after an error has been thrown by a descendant component.\nIt receives the error that was thrown as a parameter and should return a value to update state.\n* Note: its presence prevents any of the deprecated lifecycle methods from being invoked\n         \n        (error: any) => Partial<S> | null;\n\n    // This should be \"infer SS\" but can't use it yet\n    interface NewLifecycle<P, S, SS> {\nRuns before React applies the result of {@link Component.render render} to the document, and\nreturns an object to be given to {@link componentDidUpdate}. Useful for saving\nthings such as scroll position before {@link Component.render render} causes changes to it.\n* Note: the presence of this method prevents any of the deprecated\nlifecycle events from running.\n         \n        getSnapshotBeforeUpdate?(prevProps: Readonly<P>, prevState: Readonly<S>): SS | null;\nCalled immediately after updating occurs. Not called for the initial render.\n* The snapshot is only present if {@link getSnapshotBeforeUpdate} is present and returns non-null.\n         \n        componentDidUpdate?(prevProps: Readonly<P>, prevState: Readonly<S>, snapshot?: SS): void;\n    }\n\n    interface DeprecatedLifecycle<P, S> {\nCalled immediately before mounting occurs, and before {@link Component.render}.\nAvoid introducing any side-effects or subscriptions in this method.\n* Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate}\nor {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents\nthis from being invoked.\n* @deprecated 16.3, use {@link ComponentLifecycle.componentDidMount componentDidMount} or the constructor instead; will stop working in React 17\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#initializing-state}\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path}\n         \n        componentWillMount?(): void;\nCalled immediately before mounting occurs, and before {@link Component.render}.\nAvoid introducing any side-effects or subscriptions in this method.\n* This method will not stop working in React 17.\n* Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate}\nor {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents\nthis from being invoked.\n* @deprecated 16.3, use {@link ComponentLifecycle.componentDidMount componentDidMount} or the constructor instead\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#initializing-state}\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path}\n         \n        UNSAFE_componentWillMount?(): void;\nCalled when the component may be receiving new props.\nReact may call this even if props have not changed, so be sure to compare new and existing\nprops if you only want to handle changes.\n* Calling {@link Component.setState} generally does not trigger this method.\n* Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate}\nor {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents\nthis from being invoked.\n* @deprecated 16.3, use static {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} instead; will stop working in React 17\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#updating-state-based-on-props}\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path}\n         \n        componentWillReceiveProps?(nextProps: Readonly<P>, nextContext: any): void;\nCalled when the component may be receiving new props.\nReact may call this even if props have not changed, so be sure to compare new and existing\nprops if you only want to handle changes.\n* Calling {@link Component.setState} generally does not trigger this method.\n* This method will not stop working in React 17.\n* Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate}\nor {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents\nthis from being invoked.\n* @deprecated 16.3, use static {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} instead\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#updating-state-based-on-props}\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path}\n         \n        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<P>, nextContext: any): void;\nCalled immediately before rendering when new props or state is received. Not called for the initial render.\n* Note: You cannot call {@link Component.setState} here.\n* Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate}\nor {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents\nthis from being invoked.\n* @deprecated 16.3, use getSnapshotBeforeUpdate instead; will stop working in React 17\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#reading-dom-properties-before-an-update}\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path}\n         \n        componentWillUpdate?(nextProps: Readonly<P>, nextState: Readonly<S>, nextContext: any): void;\nCalled immediately before rendering when new props or state is received. Not called for the initial render.\n* Note: You cannot call {@link Component.setState} here.\n* This method will not stop working in React 17.\n* Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate}\nor {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents\nthis from being invoked.\n* @deprecated 16.3, use getSnapshotBeforeUpdate instead\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#reading-dom-properties-before-an-update}\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path}\n         \n        UNSAFE_componentWillUpdate?(nextProps: Readonly<P>, nextState: Readonly<S>, nextContext: any): void;\n    }\n\n    function createRef<T>(): RefObject<T | null>;\nThe type of the component returned from {@link forwardRef}.\n* @template P The props the component accepts, if any.\n* @see {@link ExoticComponent}\n     \n    interface ForwardRefExoticComponent<P> extends NamedExoticComponent<P> {\nIgnored by React.\n@deprecated Only kept in types for backwards compatibility. Will be removed in a future major release.\n         \n        propTypes?: any;\n    }\nLets your component expose a DOM node to a parent component\nusing a ref.\n* @see {@link https://react.dev/reference/react/forwardRef React Docs}\n@see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/forward_and_create_ref/ React TypeScript Cheatsheet}\n* @param render See the {@link ForwardRefRenderFunction}.\n* @template T The type of the DOM node.\n@template P The props the component accepts, if any.\n* @example\n* ```tsx\ninterface Props {\nchildren?: ReactNode;\ntype: \"submit\" | \"button\";\n}\n* export const FancyButton = forwardRef<HTMLButtonElement, Props>((props, ref) => (\n<button ref={ref} className=\"MyClassName\" type={props.type}>\n{props.children}\n</button>\n));\n```\n     \n    function forwardRef<T, P = {}>(\n        render: ForwardRefRenderFunction<T, PropsWithoutRef<P>>,\n    ): ForwardRefExoticComponent<PropsWithoutRef<P> & RefAttributes<T>>;\nOmits the 'ref' attribute from the given props object.\n* @template Props The props object type.\n     \n    type PropsWithoutRef<Props> =\n        // Omit would not be sufficient for this. We'd like to avoid unnecessary mapping and need a distributive conditional to support unions.\n        // see: https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types\n        // https://github.com/Microsoft/TypeScript/issues/28339\n        Props extends any ? (\"ref\" extends keyof Props ? Omit<Props, \"ref\"> : Props) : Props;\nEnsures that the props do not include string ref, which cannot be forwarded\n@deprecated Use `Props` directly. `PropsWithRef<Props>` is just an alias for `Props`\n     \n    type PropsWithRef<Props> = Props;\n\n    type PropsWithChildren<P = unknown> = P & { children?: ReactNode | undefined };\nUsed to retrieve the props a component accepts. Can either be passed a string,\nindicating a DOM element (e.g. 'div', 'span', etc.) or the type of a React\ncomponent.\n* It's usually better to use {@link ComponentPropsWithRef} or {@link ComponentPropsWithoutRef}\ninstead of this type, as they let you be explicit about whether or not to include\nthe `ref` prop.\n* @see {@link https://react-typescript-cheatsheet.netlify.app/docs/react-types/componentprops/ React TypeScript Cheatsheet}\n* @example\n* ```tsx\n// Retrieves the props an 'input' element accepts\ntype InputProps = React.ComponentProps<'input'>;\n```\n* @example\n* ```tsx\nconst MyComponent = (props: { foo: number, bar: string }) => <div />;\n* // Retrieves the props 'MyComponent' accepts\ntype MyComponentProps = React.ComponentProps<typeof MyComponent>;\n```\n     \n    type ComponentProps<T extends keyof JSX.IntrinsicElements | JSXElementConstructor<any>> = T extends\n        JSXElementConstructor<infer Props> ? Props\n        : T extends keyof JSX.IntrinsicElements ? JSX.IntrinsicElements[T]\n        : {};\nUsed to retrieve the props a component accepts with its ref. Can either be\npassed a string, indicating a DOM element (e.g. 'div', 'span', etc.) or the\ntype of a React component.\n* @see {@link https://react-typescript-cheatsheet.netlify.app/docs/react-types/componentprops/ React TypeScript Cheatsheet}\n* @example\n* ```tsx\n// Retrieves the props an 'input' element accepts\ntype InputProps = React.ComponentPropsWithRef<'input'>;\n```\n* @example\n* ```tsx\nconst MyComponent = (props: { foo: number, bar: string }) => <div />;\n* // Retrieves the props 'MyComponent' accepts\ntype MyComponentPropsWithRef = React.ComponentPropsWithRef<typeof MyComponent>;\n```\n     \n    type ComponentPropsWithRef<T extends ElementType> = T extends JSXElementConstructor<infer Props>\n        // If it's a class i.e. newable we're dealing with a class component\n        ? T extends abstract new(args: any) => any ? PropsWithoutRef<Props> & RefAttributes<InstanceType<T>>\n        : Props\n        : ComponentProps<T>;\nUsed to retrieve the props a custom component accepts with its ref.\n* Unlike {@link ComponentPropsWithRef}, this only works with custom\ncomponents, i.e. components you define yourself. This is to improve\ntype-checking performance.\n* @example\n* ```tsx\nconst MyComponent = (props: { foo: number, bar: string }) => <div />;\n* // Retrieves the props 'MyComponent' accepts\ntype MyComponentPropsWithRef = React.CustomComponentPropsWithRef<typeof MyComponent>;\n```\n     \n    type CustomComponentPropsWithRef<T extends ComponentType> = T extends JSXElementConstructor<infer Props>\n        // If it's a class i.e. newable we're dealing with a class component\n        ? T extends abstract new(args: any) => any ? PropsWithoutRef<Props> & RefAttributes<InstanceType<T>>\n        : Props\n        : never;\nUsed to retrieve the props a component accepts without its ref. Can either be\npassed a string, indicating a DOM element (e.g. 'div', 'span', etc.) or the\ntype of a React component.\n* @see {@link https://react-typescript-cheatsheet.netlify.app/docs/react-types/componentprops/ React TypeScript Cheatsheet}\n* @example\n* ```tsx\n// Retrieves the props an 'input' element accepts\ntype InputProps = React.ComponentPropsWithoutRef<'input'>;\n```\n* @example\n* ```tsx\nconst MyComponent = (props: { foo: number, bar: string }) => <div />;\n* // Retrieves the props 'MyComponent' accepts\ntype MyComponentPropsWithoutRef = React.ComponentPropsWithoutRef<typeof MyComponent>;\n```\n     \n    type ComponentPropsWithoutRef<T extends ElementType> = PropsWithoutRef<ComponentProps<T>>;\nRetrieves the type of the 'ref' prop for a given component type or tag name.\n* @template C The component type.\n* @example\n* ```tsx\ntype MyComponentRef = React.ComponentRef<typeof MyComponent>;\n```\n* @example\n* ```tsx\ntype DivRef = React.ComponentRef<'div'>;\n```\n     \n    type ComponentRef<T extends ElementType> = ComponentPropsWithRef<T> extends RefAttributes<infer Method> ? Method\n        : never;\n\n    // will show `Memo(${Component.displayName || Component.name})` in devtools by default,\n    // but can be given its own specific name\n    type MemoExoticComponent<T extends ComponentType<any>> = NamedExoticComponent<CustomComponentPropsWithRef<T>> & {\n        readonly type: T;\n    };\nLets you skip re-rendering a component when its props are unchanged.\n* @see {@link https://react.dev/reference/react/memo React Docs}\n* @param Component The component to memoize.\n@param propsAreEqual A function that will be used to determine if the props have changed.\n* @example\n* ```tsx\nimport { memo } from 'react';\n* const SomeComponent = memo(function SomeComponent(props: { foo: string }) {\n// ...\n});\n```\n     \n    function memo<P extends object>(\n        Component: FunctionComponent<P>,\n        propsAreEqual?: (prevProps: Readonly<P>, nextProps: Readonly<P>) => boolean,\n    ): NamedExoticComponent<P>;\n    function memo<T extends ComponentType<any>>(\n        Component: T,\n        propsAreEqual?: (prevProps: Readonly<ComponentProps<T>>, nextProps: Readonly<ComponentProps<T>>) => boolean,\n    ): MemoExoticComponent<T>;\n\n    interface LazyExoticComponent<T extends ComponentType<any>>\n        extends ExoticComponent<CustomComponentPropsWithRef<T>>\n    {\n        readonly _result: T;\n    }\nLets you defer loading a component’s code until it is rendered for the first time.\n* @see {@link https://react.dev/reference/react/lazy React Docs}\n* @param load A function that returns a `Promise` or another thenable (a `Promise`-like object with a\nthen method). React will not call `load` until the first time you attempt to render the returned\ncomponent. After React first calls load, it will wait for it to resolve, and then render the\nresolved value’s `.default` as a React component. Both the returned `Promise` and the `Promise`’s\nresolved value will be cached, so React will not call load more than once. If the `Promise` rejects,\nReact will throw the rejection reason for the nearest Error Boundary to handle.\n* @example\n* ```tsx\nimport { lazy } from 'react';\n* const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));\n```\n     \n    function lazy<T extends ComponentType<any>>(\n        load: () => Promise<{ default: T }>,\n    ): LazyExoticComponent<T>;\n\n    //\n    // React Hooks\n    // ----------------------------------------------------------------------\nThe instruction passed to a {@link Dispatch} function in {@link useState}\nto tell React what the next value of the {@link useState} should be.\n* Often found wrapped in {@link Dispatch}.\n* @template S The type of the state.\n* @example\n* ```tsx\n// This return type correctly represents the type of\n// `setCount` in the example below.\nconst useCustomState = (): Dispatch<SetStateAction<number>> => {\nconst [count, setCount] = useState(0);\n*   return setCount;\n}\n```\n     \n    type SetStateAction<S> = S | ((prevState: S) => S);\nA function that can be used to update the state of a {@link useState}\nor {@link useReducer} hook.\n     \n    type Dispatch<A> = (value: A) => void;\nA {@link Dispatch} function can sometimes be called without any arguments.\n     \n    type DispatchWithoutAction = () => void;\n    // Limit the reducer to accept only 0 or 1 action arguments\n    // eslint-disable-next-line @definitelytyped/no-single-element-tuple-type\n    type AnyActionArg = [] | [any];\n    // Get the dispatch type from the reducer arguments (captures optional action argument correctly)\n    type ActionDispatch<ActionArg extends AnyActionArg> = (...args: ActionArg) => void;\n    // Unlike redux, the actions _can_ be anything\n    type Reducer<S, A> = (prevState: S, action: A) => S;\n    // If useReducer accepts a reducer without action, dispatch may be called without any parameters.\n    type ReducerWithoutAction<S> = (prevState: S) => S;\n    // types used to try and prevent the compiler from reducing S\n    // to a supertype common with the second argument to useReducer()\n    type ReducerState<R extends Reducer<any, any>> = R extends Reducer<infer S, any> ? S : never;\n    type DependencyList = readonly unknown[];\n\n    // NOTE: callbacks are _only_ allowed to return either void, or a destructor.\n    type EffectCallback = () => void | Destructor;\n@deprecated Use `RefObject` instead.\n     \n    interface MutableRefObject<T> {\n        current: T;\n    }\n\n    // This will technically work if you give a Consumer<T> or Provider<T> but it's deprecated and warns\nAccepts a context object (the value returned from `React.createContext`) and returns the current\ncontext value, as given by the nearest context provider for the given context.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useContext}\n     \n    function useContext<T>(context: Context<T> /*, (not public API) observedBits?: number|boolean ): T;\nReturns a stateful value, and a function to update it.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useState}\n     \n    function useState<S>(initialState: S | (() => S)): [S, Dispatch<SetStateAction<S>>];\n    // convenience overload when first argument is omitted\nReturns a stateful value, and a function to update it.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useState}\n     \n    function useState<S = undefined>(): [S | undefined, Dispatch<SetStateAction<S | undefined>>];\nAn alternative to `useState`.\n* `useReducer` is usually preferable to `useState` when you have complex state logic that involves\nmultiple sub-values. It also lets you optimize performance for components that trigger deep\nupdates because you can pass `dispatch` down instead of callbacks.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useReducer}\n     \n    function useReducer<S, A extends AnyActionArg>(\n        reducer: (prevState: S, ...args: A) => S,\n        initialState: S,\n    ): [S, ActionDispatch<A>];\nAn alternative to `useState`.\n* `useReducer` is usually preferable to `useState` when you have complex state logic that involves\nmultiple sub-values. It also lets you optimize performance for components that trigger deep\nupdates because you can pass `dispatch` down instead of callbacks.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useReducer}\n     \n    function useReducer<S, A extends AnyActionArg>(\n        reducer: (prevState: S, ...args: A) => S,\n        initialState: S,\n    ): [S, ActionDispatch<A>];\nAn alternative to `useState`.\n* `useReducer` is usually preferable to `useState` when you have complex state logic that involves\nmultiple sub-values. It also lets you optimize performance for components that trigger deep\nupdates because you can pass `dispatch` down instead of callbacks.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useReducer}\n     \n    function useReducer<S, I, A extends AnyActionArg>(\n        reducer: (prevState: S, ...args: A) => S,\n        initialArg: I,\n        init: (i: I) => S,\n    ): [S, ActionDispatch<A>];\n`useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument\n(`initialValue`). The returned object will persist for the full lifetime of the component.\n* Note that `useRef()` is useful for more than the `ref` attribute. It’s handy for keeping any mutable\nvalue around similar to how you’d use instance fields in classes.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useRef}\n     \n    function useRef<T>(initialValue: T): RefObject<T>;\n    // convenience overload for refs given as a ref prop as they typically start with a null value\n`useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument\n(`initialValue`). The returned object will persist for the full lifetime of the component.\n* Note that `useRef()` is useful for more than the `ref` attribute. It’s handy for keeping any mutable\nvalue around similar to how you’d use instance fields in classes.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useRef}\n     \n    function useRef<T>(initialValue: T | null): RefObject<T | null>;\n    // convenience overload for undefined initialValue\n`useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument\n(`initialValue`). The returned object will persist for the full lifetime of the component.\n* Note that `useRef()` is useful for more than the `ref` attribute. It’s handy for keeping any mutable\nvalue around similar to how you’d use instance fields in classes.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useRef}\n     \n    function useRef<T>(initialValue: T | undefined): RefObject<T | undefined>;\nThe signature is identical to `useEffect`, but it fires synchronously after all DOM mutations.\nUse this to read layout from the DOM and synchronously re-render. Updates scheduled inside\n`useLayoutEffect` will be flushed synchronously, before the browser has a chance to paint.\n* Prefer the standard `useEffect` when possible to avoid blocking visual updates.\n* If you’re migrating code from a class component, `useLayoutEffect` fires in the same phase as\n`componentDidMount` and `componentDidUpdate`.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useLayoutEffect}\n     \n    function useLayoutEffect(effect: EffectCallback, deps?: DependencyList): void;\nAccepts a function that contains imperative, possibly effectful code.\n* @param effect Imperative function that can return a cleanup function\n@param deps If present, effect will only activate if the values in the list change.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useEffect}\n     \n    function useEffect(effect: EffectCallback, deps?: DependencyList): void;\n    // NOTE: this does not accept strings, but this will have to be fixed by removing strings from type Ref<T>\n`useImperativeHandle` customizes the instance value that is exposed to parent components when using\n`ref`. As always, imperative code using refs should be avoided in most cases.\n* `useImperativeHandle` should be used with `React.forwardRef`.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useImperativeHandle}\n     \n    function useImperativeHandle<T, R extends T>(ref: Ref<T> | undefined, init: () => R, deps?: DependencyList): void;\n    // I made 'inputs' required here and in useMemo as there's no point to memoizing without the memoization key\n    // useCallback(X) is identical to just using X, useMemo(() => Y) is identical to just using Y.\n`useCallback` will return a memoized version of the callback that only changes if one of the `inputs`\nhas changed.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useCallback}\n     \n    // A specific function type would not trigger implicit any.\n    // See https://github.com/DefinitelyTyped/DefinitelyTyped/issues/52873#issuecomment-845806435 for a comparison between `Function` and more specific types.\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n    function useCallback<T extends Function>(callback: T, deps: DependencyList): T;\n`useMemo` will only recompute the memoized value when one of the `deps` has changed.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useMemo}\n     \n    // allow undefined, but don't make it optional as that is very likely a mistake\n    function useMemo<T>(factory: () => T, deps: DependencyList): T;\n`useDebugValue` can be used to display a label for custom hooks in React DevTools.\n* NOTE: We don’t recommend adding debug values to every custom hook.\nIt’s most valuable for custom hooks that are part of shared libraries.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useDebugValue}\n     \n    // the name of the custom hook is itself derived from the function name at runtime:\n    // it's just the function name without the \"use\" prefix.\n    function useDebugValue<T>(value: T, format?: (value: T) => any): void;\n\n    export type TransitionFunction = () => VoidOrUndefinedOnly | Promise<VoidOrUndefinedOnly>;\n    // strange definition to allow vscode to show documentation on the invocation\n    export interface TransitionStartFunction {\nState updates caused inside the callback are allowed to be deferred.\n* **If some state update causes a component to suspend, that state update should be wrapped in a transition.**\n* @param callback A function which causes state updates that can be deferred.\n         \n        (callback: TransitionFunction): void;\n    }\nReturns a deferred version of the value that may “lag behind” it.\n* This is commonly used to keep the interface responsive when you have something that renders immediately\nbased on user input and something that needs to wait for a data fetch.\n* A good example of this is a text input.\n* @param value The value that is going to be deferred\n@param initialValue A value to use during the initial render of a component. If this option is omitted, `useDeferredValue` will not defer during the initial render, because there’s no previous version of `value` that it can render instead.\n* @see {@link https://react.dev/reference/react/useDeferredValue}\n     \n    export function useDeferredValue<T>(value: T, initialValue?: T): T;\nAllows components to avoid undesirable loading states by waiting for content to load\nbefore transitioning to the next screen. It also allows components to defer slower,\ndata fetching updates until subsequent renders so that more crucial updates can be\nrendered immediately.\n* The `useTransition` hook returns two values in an array.\n* The first is a boolean, React’s way of informing us whether we’re waiting for the transition to finish.\nThe second is a function that takes a callback. We can use it to tell React which state we want to defer.\n* **If some state update causes a component to suspend, that state update should be wrapped in a transition.**\n* @see {@link https://react.dev/reference/react/useTransition}\n     \n    export function useTransition(): [boolean, TransitionStartFunction];\nSimilar to `useTransition` but allows uses where hooks are not available.\n* @param callback A function which causes state updates that can be deferred.\n     \n    export function startTransition(scope: TransitionFunction): void;\nWrap any code rendering and triggering updates to your components into `act()` calls.\n* Ensures that the behavior in your tests matches what happens in the browser\nmore closely by executing pending `useEffect`s before returning. This also\nreduces the amount of re-renders done.\n* @param callback A synchronous, void callback that will execute as a single, complete React commit.\n* @see https://reactjs.org/blog/2019/02/06/react-v16.8.0.html#testing-hooks\n     \n    // NOTES\n    // - the order of these signatures matters - typescript will check the signatures in source order.\n    //   If the `() => VoidOrUndefinedOnly` signature is first, it'll erroneously match a Promise returning function for users with\n    //   `strictNullChecks: false`.\n    // - VoidOrUndefinedOnly is there to forbid any non-void return values for users with `strictNullChecks: true`\n    // While act does always return Thenable, if a void function is passed, we pretend the return value is also void to not trigger dangling Promise lint rules.\n    export function act(callback: () => VoidOrUndefinedOnly): void;\n    export function act<T>(callback: () => T | Promise<T>): Promise<T>;\n\n    export function useId(): string;\n@param effect Imperative function that can return a cleanup function\n@param deps If present, effect will only activate if the values in the list change.\n* @see {@link https://github.com/facebook/react/pull/21913}",
    "packageType": "javascript"
  },
  {
    "objectName": "useInsertionEffect",
    "signature": "useInsertionEffect: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/useInsertionEffect",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "useInsertionEffect: any",
    "documentation": "Exported variable useInsertionEffect",
    "description": "Added new variable useInsertionEffect",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable useInsertionEffect\n\nNew source code:\n\n```typescript\nuseInsertionEffect: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable useInsertionEffect",
    "packageType": "javascript"
  },
  {
    "objectName": "useInsertionEffect",
    "signature": "property useInsertionEffect",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/useInsertionEffect",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property useInsertionEffect",
    "documentation": "Property useInsertionEffect",
    "description": "Added new property useInsertionEffect",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty useInsertionEffect\n\nNew source code:\n\n```typescript\nproperty useInsertionEffect\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property useInsertionEffect",
    "packageType": "javascript"
  },
  {
    "objectName": "useLayoutEffect",
    "signature": "function useLayoutEffect",
    "objectType": "function",
    "objectIdentifier": "react/cjs/react/development/useLayoutEffect",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function useLayoutEffect",
    "documentation": "Module: cjs/react.development",
    "description": "Added new function useLayoutEffect",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nModule: cjs/react.development\n\nNew source code:\n\n```typescript\nfunction useLayoutEffect\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Module: cjs/react.development",
    "packageType": "javascript"
  },
  {
    "objectName": "useLayoutEffect",
    "signature": "useLayoutEffect: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/useLayoutEffect",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "useLayoutEffect: any",
    "documentation": "Exported variable useLayoutEffect",
    "description": "Added new variable useLayoutEffect",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable useLayoutEffect\n\nNew source code:\n\n```typescript\nuseLayoutEffect: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable useLayoutEffect",
    "packageType": "javascript"
  },
  {
    "objectName": "useLayoutEffect",
    "signature": "property useLayoutEffect",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/useLayoutEffect",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property useLayoutEffect",
    "documentation": "Property useLayoutEffect",
    "description": "Added new property useLayoutEffect",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty useLayoutEffect\n\nNew source code:\n\n```typescript\nproperty useLayoutEffect\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property useLayoutEffect",
    "packageType": "javascript"
  },
  {
    "objectName": "useMemo",
    "signature": "function useMemo",
    "objectType": "function",
    "objectIdentifier": "react/cjs/react/development/useMemo",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function useMemo",
    "documentation": "Module: cjs/react.development",
    "description": "Added new function useMemo",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nModule: cjs/react.development\n\nNew source code:\n\n```typescript\nfunction useMemo\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Module: cjs/react.development",
    "packageType": "javascript"
  },
  {
    "objectName": "useMemo",
    "signature": "useMemo: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/useMemo",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "useMemo: any",
    "documentation": "Exported variable useMemo",
    "description": "Added new variable useMemo",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable useMemo\n\nNew source code:\n\n```typescript\nuseMemo: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable useMemo",
    "packageType": "javascript"
  },
  {
    "objectName": "useMemo",
    "signature": "property useMemo",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/useMemo",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property useMemo",
    "documentation": "Property useMemo",
    "description": "Added new property useMemo",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty useMemo\n\nNew source code:\n\n```typescript\nproperty useMemo\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property useMemo",
    "packageType": "javascript"
  },
  {
    "objectName": "useOptimistic",
    "signature": "function useOptimistic",
    "objectType": "function",
    "objectIdentifier": "react/functions/useOptimistic",
    "packagePath": "react",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function useOptimistic",
    "documentation": "",
    "description": "Added new function useOptimistic",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nFunction useOptimistic from react.\n\nSignature: function useOptimistic\n\nNew source code:\n\n```typescript\nfunction useOptimistic\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Function useOptimistic from react.\n\nSignature: function useOptimistic",
    "packageType": "javascript"
  },
  {
    "objectName": "useOptimistic",
    "signature": "useOptimistic: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/useOptimistic",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "useOptimistic: any",
    "documentation": "Exported variable useOptimistic",
    "description": "Added new variable useOptimistic",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable useOptimistic\n\nNew source code:\n\n```typescript\nuseOptimistic: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable useOptimistic",
    "packageType": "javascript"
  },
  {
    "objectName": "useOptimistic",
    "signature": "property useOptimistic",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/useOptimistic",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property useOptimistic",
    "documentation": "Property useOptimistic",
    "description": "Added new property useOptimistic",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty useOptimistic\n\nNew source code:\n\n```typescript\nproperty useOptimistic\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property useOptimistic",
    "packageType": "javascript"
  },
  {
    "objectName": "useReducer",
    "signature": "function useReducer",
    "objectType": "function",
    "objectIdentifier": "react/cjs/react/development/useReducer",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function useReducer",
    "documentation": "Module: cjs/react.development",
    "description": "Added new function useReducer",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nModule: cjs/react.development\n\nNew source code:\n\n```typescript\nfunction useReducer\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Module: cjs/react.development",
    "packageType": "javascript"
  },
  {
    "objectName": "useReducer",
    "signature": "useReducer: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/useReducer",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "useReducer: any",
    "documentation": "Exported variable useReducer",
    "description": "Added new variable useReducer",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable useReducer\n\nNew source code:\n\n```typescript\nuseReducer: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable useReducer",
    "packageType": "javascript"
  },
  {
    "objectName": "useReducer",
    "signature": "property useReducer",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/useReducer",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property useReducer",
    "documentation": "Property useReducer",
    "description": "Added new property useReducer",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty useReducer\n\nNew source code:\n\n```typescript\nproperty useReducer\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property useReducer",
    "packageType": "javascript"
  },
  {
    "objectName": "useRef",
    "signature": "function useRef",
    "objectType": "function",
    "objectIdentifier": "react/cjs/react/development/useRef",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function useRef",
    "documentation": "Module: cjs/react.development",
    "description": "Added new function useRef",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nModule: cjs/react.development\n\nNew source code:\n\n```typescript\nfunction useRef\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Module: cjs/react.development",
    "packageType": "javascript"
  },
  {
    "objectName": "useRef",
    "signature": "useRef: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/useRef",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "useRef: any",
    "documentation": "Exported variable useRef",
    "description": "Added new variable useRef",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable useRef\n\nNew source code:\n\n```typescript\nuseRef: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable useRef",
    "packageType": "javascript"
  },
  {
    "objectName": "useRef",
    "signature": "property useRef",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/useRef",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property useRef",
    "documentation": "Property useRef",
    "description": "Added new property useRef",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty useRef\n\nNew source code:\n\n```typescript\nproperty useRef\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property useRef",
    "packageType": "javascript"
  },
  {
    "objectName": "useState",
    "signature": "function useState",
    "objectType": "function",
    "objectIdentifier": "react/cjs/react/development/useState",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function useState",
    "documentation": "Module: cjs/react.development",
    "description": "Added new function useState",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nModule: cjs/react.development\n\nNew source code:\n\n```typescript\nfunction useState\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Module: cjs/react.development",
    "packageType": "javascript"
  },
  {
    "objectName": "useState",
    "signature": "useState: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/useState",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "useState: any",
    "documentation": "Exported variable useState",
    "description": "Added new variable useState",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable useState\n\nNew source code:\n\n```typescript\nuseState: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable useState",
    "packageType": "javascript"
  },
  {
    "objectName": "useState",
    "signature": "property useState",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/useState",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property useState",
    "documentation": "Property useState",
    "description": "Added new property useState",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty useState\n\nNew source code:\n\n```typescript\nproperty useState\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property useState",
    "packageType": "javascript"
  },
  {
    "objectName": "useSyncExternalStore",
    "signature": "function useSyncExternalStore",
    "objectType": "function",
    "objectIdentifier": "react/functions/useSyncExternalStore",
    "packagePath": "react",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function useSyncExternalStore",
    "documentation": "",
    "description": "Added new function useSyncExternalStore",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nFunction useSyncExternalStore from react.\n\nSignature: function useSyncExternalStore\n\nNew source code:\n\n```typescript\nfunction useSyncExternalStore\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Function useSyncExternalStore from react.\n\nSignature: function useSyncExternalStore",
    "packageType": "javascript"
  },
  {
    "objectName": "useSyncExternalStore",
    "signature": "useSyncExternalStore: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/useSyncExternalStore",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "useSyncExternalStore: any",
    "documentation": "Exported variable useSyncExternalStore",
    "description": "Added new variable useSyncExternalStore",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable useSyncExternalStore\n\nNew source code:\n\n```typescript\nuseSyncExternalStore: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable useSyncExternalStore",
    "packageType": "javascript"
  },
  {
    "objectName": "useSyncExternalStore",
    "signature": "property useSyncExternalStore",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/useSyncExternalStore",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property useSyncExternalStore",
    "documentation": "Property useSyncExternalStore",
    "description": "Added new property useSyncExternalStore",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty useSyncExternalStore\n\nNew source code:\n\n```typescript\nproperty useSyncExternalStore\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property useSyncExternalStore",
    "packageType": "javascript"
  },
  {
    "objectName": "useTransition",
    "signature": "function useTransition",
    "objectType": "function",
    "objectIdentifier": "react/functions/useTransition",
    "packagePath": "react",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function useTransition",
    "documentation": "Used to represent DOM API's where users can either pass true or false as a boolean or as its equivalent strings. type Booleanish = boolean | \"true\" | \"false\"; @see {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/crossorigin MDN} type CrossOrigin = \"anonymous\" | \"use-credentials\" | \"\" | undefined; declare const UNDEFINED_VOID_ONLY: unique symbol; @internal Use `Awaited<ReactNode>` instead // Helper type to enable `Awaited<ReactNode>`. // Must be a copy of the non-thenables of `ReactNode`. type AwaitedReactNode = | React.ReactElement | string | number | bigint | Iterable<React.ReactNode> | React.ReactPortal | boolean | null | undefined | React.DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES[ keyof React.DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES ]; The function returned from an effect passed to {@link React.useEffect useEffect}, which can be used to clean up the effect when the component unmounts. * @see {@link https://react.dev/reference/react/useEffect React Docs} type Destructor = () => void | { [UNDEFINED_VOID_ONLY]: never }; type VoidOrUndefinedOnly = void | { [UNDEFINED_VOID_ONLY]: never }; // eslint-disable-next-line @definitelytyped/export-just-namespace export = React; export as namespace React; declare namespace React { // // React Elements // ---------------------------------------------------------------------- Used to retrieve the possible components which accept a given set of props. * Can be passed no type parameters to get a union of all possible components and tags. * Is a superset of {@link ComponentType}. * @template P The props to match against. If not passed, defaults to any. @template Tag An optional tag to match against. If not passed, attempts to match against all possible tags. * @example * ```tsx // All components and tags (img, embed etc.) // which accept `src` type SrcComponents = ElementType<{ src: any }>; ``` * @example * ```tsx // All components type AllComponents = ElementType; ``` * @example * ```tsx // All custom components which match `src`, and tags which // match `src`, narrowed down to just `audio` and `embed` type SrcComponents = ElementType<{ src: any }, 'audio' | 'embed'>; ``` type ElementType<P = any, Tag extends keyof JSX.IntrinsicElements = keyof JSX.IntrinsicElements> = | { [K in Tag]: P extends JSX.IntrinsicElements[K] ? K : never }[Tag] | ComponentType<P>; Represents any user-defined component, either as a function or a class. * Similar to {@link JSXElementConstructor}, but with extra properties like {@link FunctionComponent.defaultProps defaultProps }. * @template P The props the component accepts. * @see {@link ComponentClass} @see {@link FunctionComponent} type ComponentType<P = {}> = ComponentClass<P> | FunctionComponent<P>; Represents any user-defined component, either as a function or a class. * Similar to {@link ComponentType}, but without extra properties like {@link FunctionComponent.defaultProps defaultProps }. * @template P The props the component accepts. type JSXElementConstructor<P> = | (( props: P, ) => ReactNode | Promise<ReactNode>) // constructor signature must match React.Component | (new(props: P) => Component<any, any>); Created by {@link createRef}, or {@link useRef} when passed `null`. * @template T The type of the ref's value. * @example * ```tsx const ref = createRef<HTMLDivElement>(); * ref.current = document.createElement('div'); // Error ``` interface RefObject<T> { The current value of the ref. current: T; } interface DO_NOT_USE_OR_YOU_WILL_BE_FIRED_CALLBACK_REF_RETURN_VALUES { } A callback fired whenever the ref's value changes. * @template T The type of the ref's value. * @see {@link https://react.dev/reference/react-dom/components/common#ref-callback React Docs} * @example * ```tsx <div ref={(node) => console.log(node)} /> ``` type RefCallback<T> = { bivarianceHack( instance: T | null, ): | void | (() => VoidOrUndefinedOnly) | DO_NOT_USE_OR_YOU_WILL_BE_FIRED_CALLBACK_REF_RETURN_VALUES[ keyof DO_NOT_USE_OR_YOU_WILL_BE_FIRED_CALLBACK_REF_RETURN_VALUES ]; }[\"bivarianceHack\"]; A union type of all possible shapes for React refs. * @see {@link RefCallback} @see {@link RefObject} type Ref<T> = RefCallback<T> | RefObject<T | null> | null; @deprecated Use `Ref` instead. String refs are no longer supported. If you're typing a library with support for React versions with string refs, use `RefAttributes<T>['ref']` instead. type LegacyRef<T> = Ref<T>; @deprecated Use `ComponentRef<T>` instead * Retrieves the type of the 'ref' prop for a given component type or tag name. * @template C The component type. * @example * ```tsx type MyComponentRef = React.ElementRef<typeof MyComponent>; ``` * @example * ```tsx type DivRef = React.ElementRef<'div'>; ``` type ElementRef< C extends | ForwardRefExoticComponent<any> | { new(props: any): Component<any> } | ((props: any) => ReactNode) | keyof JSX.IntrinsicElements, > = ComponentRef<C>; type ComponentState = any; A value which uniquely identifies a node among items in an array. * @see {@link https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key React Docs} type Key = string | number | bigint; @internal The props any component can receive. You don't have to add this type. All components automatically accept these props. ```tsx const Component = () => <div />; <Component key=\"one\" /> ``` * WARNING: The implementation of a component will never have access to these attributes. The following example would be incorrect usage because {@link Component} would never have access to `key`: ```tsx const Component = (props: React.Attributes) => props.key; ``` interface Attributes { key?: Key | null | undefined; } The props any component accepting refs can receive. Class components, built-in browser components (e.g. `div`) and forwardRef components can receive refs and automatically accept these props. ```tsx const Component = forwardRef(() => <div />); <Component ref={(current) => console.log(current)} /> ``` * You only need this type if you manually author the types of props that need to be compatible with legacy refs. ```tsx interface Props extends React.RefAttributes<HTMLDivElement> {} declare const Component: React.FunctionComponent<Props>; ``` * Otherwise it's simpler to directly use {@link Ref} since you can safely use the props type to describe to props that a consumer can pass to the component as well as describing the props the implementation of a component \"sees\". {@link RefAttributes} is generally not safe to describe both consumer and seen props. * ```tsx interface Props extends { ref?: React.Ref<HTMLDivElement> | undefined; } declare const Component: React.FunctionComponent<Props>; ``` * WARNING: The implementation of a component will not have access to the same type in versions of React supporting string refs. The following example would be incorrect usage because {@link Component} would never have access to a `ref` with type `string` ```tsx const Component = (props: React.RefAttributes) => props.ref; ``` interface RefAttributes<T> extends Attributes { Allows getting a ref to the component instance. Once the component unmounts, React will set `ref.current` to `null` (or call the ref with `null` if you passed a callback ref). * @see {@link https://react.dev/learn/referencing-values-with-refs#refs-and-the-dom React Docs} ref?: Ref<T> | undefined; } Represents the built-in attributes available to class components. interface ClassAttributes<T> extends RefAttributes<T> { } Represents a JSX element. * Where {@link ReactNode} represents everything that can be rendered, `ReactElement` only represents JSX. * @template P The type of the props object @template T The type of the component or tag * @example * ```tsx const element: ReactElement = <div />; ``` interface ReactElement< P = unknown, T extends string | JSXElementConstructor<any> = string | JSXElementConstructor<any>, > { type: T; props: P; key: string | null; } @deprecated interface ReactComponentElement< T extends keyof JSX.IntrinsicElements | JSXElementConstructor<any>, P = Pick<ComponentProps<T>, Exclude<keyof ComponentProps<T>, \"key\" | \"ref\">>, > extends ReactElement<P, Exclude<T, number>> {} @deprecated Use `ReactElement<P, React.FunctionComponent<P>>` interface FunctionComponentElement<P> extends ReactElement<P, FunctionComponent<P>> { @deprecated Use `element.props.ref` instead. ref?: (\"ref\" extends keyof P ? P extends { ref?: infer R | undefined } ? R : never : never) | undefined; } @deprecated Use `ReactElement<P, React.ComponentClass<P>>` type CElement<P, T extends Component<P, ComponentState>> = ComponentElement<P, T>; @deprecated Use `ReactElement<P, React.ComponentClass<P>>` interface ComponentElement<P, T extends Component<P, ComponentState>> extends ReactElement<P, ComponentClass<P>> { @deprecated Use `element.props.ref` instead. ref?: Ref<T> | undefined; } @deprecated Use {@link ComponentElement} instead. type ClassicElement<P> = CElement<P, ClassicComponent<P, ComponentState>>; // string fallback for custom web-components @deprecated Use `ReactElement<P, string>` interface DOMElement<P extends HTMLAttributes<T> | SVGAttributes<T>, T extends Element> extends ReactElement<P, string> { @deprecated Use `element.props.ref` instead. ref: Ref<T>; } // ReactHTML for ReactHTMLElement interface ReactHTMLElement<T extends HTMLElement> extends DetailedReactHTMLElement<AllHTMLAttributes<T>, T> {} interface DetailedReactHTMLElement<P extends HTMLAttributes<T>, T extends HTMLElement> extends DOMElement<P, T> { type: HTMLElementType; } // ReactSVG for ReactSVGElement interface ReactSVGElement extends DOMElement<SVGAttributes<SVGElement>, SVGElement> { type: SVGElementType; } interface ReactPortal extends ReactElement { children: ReactNode; } Different release channels declare additional types of ReactNode this particular release channel accepts. App or library types should never augment this interface. interface DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES {} Represents all of the things React can render. * Where {@link ReactElement} only represents JSX, `ReactNode` represents everything that can be rendered. * @see {@link https://react-typescript-cheatsheet.netlify.app/docs/react-types/reactnode/ React TypeScript Cheatsheet} * @example * ```tsx // Typing children type Props = { children: ReactNode } * const Component = ({ children }: Props) => <div>{children}</div> * <Component>hello</Component> ``` * @example * ```tsx // Typing a custom element type Props = { customElement: ReactNode } * const Component = ({ customElement }: Props) => <div>{customElement}</div> * <Component customElement={<div>hello</div>} /> ``` // non-thenables need to be kept in sync with AwaitedReactNode type ReactNode = | ReactElement | string | number | bigint | Iterable<ReactNode> | ReactPortal | boolean | null | undefined | DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES[ keyof DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES ] | Promise<AwaitedReactNode>; // // Top Level API // ---------------------------------------------------------------------- // DOM Elements // TODO: generalize this to everything in `keyof ReactHTML`, not just \"input\" function createElement( type: \"input\", props?: InputHTMLAttributes<HTMLInputElement> & ClassAttributes<HTMLInputElement> | null, ...children: ReactNode[] ): DetailedReactHTMLElement<InputHTMLAttributes<HTMLInputElement>, HTMLInputElement>; function createElement<P extends HTMLAttributes<T>, T extends HTMLElement>( type: HTMLElementType, props?: ClassAttributes<T> & P | null, ...children: ReactNode[] ): DetailedReactHTMLElement<P, T>; function createElement<P extends SVGAttributes<T>, T extends SVGElement>( type: SVGElementType, props?: ClassAttributes<T> & P | null, ...children: ReactNode[] ): ReactSVGElement; function createElement<P extends DOMAttributes<T>, T extends Element>( type: string, props?: ClassAttributes<T> & P | null, ...children: ReactNode[] ): DOMElement<P, T>; // Custom components function createElement<P extends {}>( type: FunctionComponent<P>, props?: Attributes & P | null, ...children: ReactNode[] ): FunctionComponentElement<P>; function createElement<P extends {}, T extends Component<P, ComponentState>, C extends ComponentClass<P>>( type: ClassType<P, T, C>, props?: ClassAttributes<T> & P | null, ...children: ReactNode[] ): CElement<P, T>; function createElement<P extends {}>( type: FunctionComponent<P> | ComponentClass<P> | string, props?: Attributes & P | null, ...children: ReactNode[] ): ReactElement<P>; // DOM Elements // ReactHTMLElement function cloneElement<P extends HTMLAttributes<T>, T extends HTMLElement>( element: DetailedReactHTMLElement<P, T>, props?: P, ...children: ReactNode[] ): DetailedReactHTMLElement<P, T>; // ReactHTMLElement, less specific function cloneElement<P extends HTMLAttributes<T>, T extends HTMLElement>( element: ReactHTMLElement<T>, props?: P, ...children: ReactNode[] ): ReactHTMLElement<T>; // SVGElement function cloneElement<P extends SVGAttributes<T>, T extends SVGElement>( element: ReactSVGElement, props?: P, ...children: ReactNode[] ): ReactSVGElement; // DOM Element (has to be the last, because type checking stops at first overload that fits) function cloneElement<P extends DOMAttributes<T>, T extends Element>( element: DOMElement<P, T>, props?: DOMAttributes<T> & P, ...children: ReactNode[] ): DOMElement<P, T>; // Custom components function cloneElement<P>( element: FunctionComponentElement<P>, props?: Partial<P> & Attributes, ...children: ReactNode[] ): FunctionComponentElement<P>; function cloneElement<P, T extends Component<P, ComponentState>>( element: CElement<P, T>, props?: Partial<P> & ClassAttributes<T>, ...children: ReactNode[] ): CElement<P, T>; function cloneElement<P>( element: ReactElement<P>, props?: Partial<P> & Attributes, ...children: ReactNode[] ): ReactElement<P>; Describes the props accepted by a Context {@link Provider}. * @template T The type of the value the context provides. interface ProviderProps<T> { value: T; children?: ReactNode | undefined; } Describes the props accepted by a Context {@link Consumer}. * @template T The type of the value the context provides. interface ConsumerProps<T> { children: (value: T) => ReactNode; } An object masquerading as a component. These are created by functions like {@link forwardRef}, {@link memo}, and {@link createContext}. * In order to make TypeScript work, we pretend that they are normal components. * But they are, in fact, not callable - instead, they are objects which are treated specially by the renderer. * @template P The props the component accepts. interface ExoticComponent<P = {}> { (props: P): ReactNode; readonly $$typeof: symbol; } An {@link ExoticComponent} with a `displayName` property applied to it. * @template P The props the component accepts. interface NamedExoticComponent<P = {}> extends ExoticComponent<P> { Used in debugging messages. You might want to set it explicitly if you want to display a different name for debugging purposes. * @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs} displayName?: string | undefined; } An {@link ExoticComponent} with a `propTypes` property applied to it. * @template P The props the component accepts. interface ProviderExoticComponent<P> extends ExoticComponent<P> { } Used to retrieve the type of a context object from a {@link Context}. * @template C The context object. * @example * ```tsx import { createContext } from 'react'; * const MyContext = createContext({ foo: 'bar' }); * type ContextType = ContextType<typeof MyContext>; // ContextType = { foo: string } ``` type ContextType<C extends Context<any>> = C extends Context<infer T> ? T : never; Wraps your components to specify the value of this context for all components inside. * @see {@link https://react.dev/reference/react/createContext#provider React Docs} * @example * ```tsx import { createContext } from 'react'; * const ThemeContext = createContext('light'); * function App() { return ( <ThemeContext.Provider value=\"dark\"> <Toolbar /> </ThemeContext.Provider> ); } ``` type Provider<T> = ProviderExoticComponent<ProviderProps<T>>; The old way to read context, before {@link useContext} existed. * @see {@link https://react.dev/reference/react/createContext#consumer React Docs} * @example * ```tsx import { UserContext } from './user-context'; * function Avatar() { return ( <UserContext.Consumer> {user => <img src={user.profileImage} alt={user.name} />} </UserContext.Consumer> ); } ``` type Consumer<T> = ExoticComponent<ConsumerProps<T>>; Context lets components pass information deep down without explicitly passing props. * Created from {@link createContext} * @see {@link https://react.dev/learn/passing-data-deeply-with-context React Docs} @see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/context/ React TypeScript Cheatsheet} * @example * ```tsx import { createContext } from 'react'; * const ThemeContext = createContext('light'); ``` interface Context<T> extends Provider<T> { Provider: Provider<T>; Consumer: Consumer<T>; Used in debugging messages. You might want to set it explicitly if you want to display a different name for debugging purposes. * @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs} displayName?: string | undefined; } Lets you create a {@link Context} that components can provide or read. * @param defaultValue The value you want the context to have when there is no matching {@link Provider} in the tree above the component reading the context. This is meant as a \"last resort\" fallback. * @see {@link https://react.dev/reference/react/createContext#reference React Docs} @see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/context/ React TypeScript Cheatsheet} * @example * ```tsx import { createContext } from 'react'; * const ThemeContext = createContext('light'); function App() { return ( <ThemeContext value=\"dark\"> <Toolbar /> </ThemeContext> ); } ``` function createContext<T>( // If you thought this should be optional, see // https://github.com/DefinitelyTyped/DefinitelyTyped/pull/24509#issuecomment-382213106 defaultValue: T, ): Context<T>; function isValidElement<P>(object: {} | null | undefined): object is ReactElement<P>; const Children: { map<T, C>( children: C | readonly C[], fn: (child: C, index: number) => T, ): C extends null | undefined ? C : Array<Exclude<T, boolean | null | undefined>>; forEach<C>(children: C | readonly C[], fn: (child: C, index: number) => void): void; count(children: any): number; only<C>(children: C): C extends any[] ? never : C; toArray(children: ReactNode | ReactNode[]): Array<Exclude<ReactNode, boolean | null | undefined>>; }; export interface FragmentProps { children?: React.ReactNode; } Lets you group elements without a wrapper node. * @see {@link https://react.dev/reference/react/Fragment React Docs} * @example * ```tsx import { Fragment } from 'react'; * <Fragment> <td>Hello</td> <td>World</td> </Fragment> ``` * @example * ```tsx // Using the <></> shorthand syntax: * <> <td>Hello</td> <td>World</td> </> ``` const Fragment: ExoticComponent<FragmentProps>; Lets you find common bugs in your components early during development. * @see {@link https://react.dev/reference/react/StrictMode React Docs} * @example * ```tsx import { StrictMode } from 'react'; * <StrictMode> <App /> </StrictMode> ``` const StrictMode: ExoticComponent<{ children?: ReactNode | undefined }>; The props accepted by {@link Suspense}. * @see {@link https://react.dev/reference/react/Suspense React Docs} interface SuspenseProps { children?: ReactNode | undefined; A fallback react tree to show when a Suspense child (like React.lazy) suspends fallback?: ReactNode; A name for this Suspense boundary for instrumentation purposes. The name will help identify this boundary in React DevTools. name?: string | undefined; } Lets you display a fallback until its children have finished loading. * @see {@link https://react.dev/reference/react/Suspense React Docs} * @example * ```tsx import { Suspense } from 'react'; * <Suspense fallback={<Loading />}> <ProfileDetails /> </Suspense> ``` const Suspense: ExoticComponent<SuspenseProps>; const version: string; The callback passed to {@link ProfilerProps.onRender}. * @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs} type ProfilerOnRenderCallback = ( The string id prop of the {@link Profiler} tree that has just committed. This lets you identify which part of the tree was committed if you are using multiple profilers. * @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs} id: string, This lets you know whether the tree has just been mounted for the first time or re-rendered due to a change in props, state, or hooks. * @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs} phase: \"mount\" | \"update\" | \"nested-update\", The number of milliseconds spent rendering the {@link Profiler} and its descendants for the current update. This indicates how well the subtree makes use of memoization (e.g. {@link memo} and {@link useMemo}). Ideally this value should decrease significantly after the initial mount as many of the descendants will only need to re-render if their specific props change. * @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs} actualDuration: number, The number of milliseconds estimating how much time it would take to re-render the entire {@link Profiler} subtree without any optimizations. It is calculated by summing up the most recent render durations of each component in the tree. This value estimates a worst-case cost of rendering (e.g. the initial mount or a tree with no memoization). Compare {@link actualDuration} against it to see if memoization is working. * @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs} baseDuration: number, A numeric timestamp for when React began rendering the current update. * @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs} startTime: number, A numeric timestamp for when React committed the current update. This value is shared between all profilers in a commit, enabling them to be grouped if desirable. * @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs} commitTime: number, ) => void; The props accepted by {@link Profiler}. * @see {@link https://react.dev/reference/react/Profiler React Docs} interface ProfilerProps { children?: ReactNode | undefined; id: string; onRender: ProfilerOnRenderCallback; } Lets you measure rendering performance of a React tree programmatically. * @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs} * @example * ```tsx <Profiler id=\"App\" onRender={onRender}> <App /> </Profiler> ``` const Profiler: ExoticComponent<ProfilerProps>; // // Component API // ---------------------------------------------------------------------- type ReactInstance = Component<any> | Element; // Base component for plain JS classes interface Component<P = {}, S = {}, SS = any> extends ComponentLifecycle<P, S, SS> {} class Component<P, S> { If set, `this.context` will be set at runtime to the current value of the given Context. * @example * ```ts type MyContext = number const Ctx = React.createContext<MyContext>(0) * class Foo extends React.Component { static contextType = Ctx context!: React.ContextType<typeof Ctx> render () { return <>My context's value: {this.context}</>; } } ``` * @see {@link https://react.dev/reference/react/Component#static-contexttype} static contextType?: Context<any> | undefined; Ignored by React. @deprecated Only kept in types for backwards compatibility. Will be removed in a future major release. static propTypes?: any; If using the new style context, re-declare this in your class to be the `React.ContextType` of your `static contextType`. Should be used with type annotation or static contextType. * @example ```ts static contextType = MyContext // For TS pre-3.7: context!: React.ContextType<typeof MyContext> // For TS 3.7 and above: declare context: React.ContextType<typeof MyContext> ``` * @see {@link https://react.dev/reference/react/Component#context React Docs} context: unknown; // Keep in sync with constructor signature of JSXElementConstructor and ComponentClass. constructor(props: P); // We MUST keep setState() as a unified signature because it allows proper checking of the method return type. // See: https://github.com/DefinitelyTyped/DefinitelyTyped/issues/18365#issuecomment-351013257 // Also, the ` | S` allows intellisense to not be dumbisense setState<K extends keyof S>( state: ((prevState: Readonly<S>, props: Readonly<P>) => Pick<S, K> | S | null) | (Pick<S, K> | S | null), callback?: () => void, ): void; forceUpdate(callback?: () => void): void; render(): ReactNode; readonly props: Readonly<P>; state: Readonly<S>; } class PureComponent<P = {}, S = {}, SS = any> extends Component<P, S, SS> {} @deprecated Use `ClassicComponent` from `create-react-class` * @see {@link https://legacy.reactjs.org/docs/react-without-es6.html Legacy React Docs} @see {@link https://www.npmjs.com/package/create-react-class `create-react-class` on npm} interface ClassicComponent<P = {}, S = {}> extends Component<P, S> { replaceState(nextState: S, callback?: () => void): void; isMounted(): boolean; getInitialState?(): S; } // // Class Interfaces // ---------------------------------------------------------------------- Represents the type of a function component. Can optionally receive a type argument that represents the props the component receives. * @template P The props the component accepts. @see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/function_components React TypeScript Cheatsheet} @alias for {@link FunctionComponent} * @example * ```tsx // With props: type Props = { name: string } * const MyComponent: FC<Props> = (props) => { return <div>{props.name}</div> } ``` * @example * ```tsx // Without props: const MyComponentWithoutProps: FC = () => { return <div>MyComponentWithoutProps</div> } ``` type FC<P = {}> = FunctionComponent<P>; Represents the type of a function component. Can optionally receive a type argument that represents the props the component accepts. * @template P The props the component accepts. @see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/function_components React TypeScript Cheatsheet} * @example * ```tsx // With props: type Props = { name: string } * const MyComponent: FunctionComponent<Props> = (props) => { return <div>{props.name}</div> } ``` * @example * ```tsx // Without props: const MyComponentWithoutProps: FunctionComponent = () => { return <div>MyComponentWithoutProps</div> } ``` interface FunctionComponent<P = {}> { (props: P): ReactNode | Promise<ReactNode>; Ignored by React. @deprecated Only kept in types for backwards compatibility. Will be removed in a future major release. propTypes?: any; Used in debugging messages. You might want to set it explicitly if you want to display a different name for debugging purposes. * @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs} * @example * ```tsx * const MyComponent: FC = () => { return <div>Hello!</div> } * MyComponent.displayName = 'MyAwesomeComponent' ``` displayName?: string | undefined; } The type of the ref received by a {@link ForwardRefRenderFunction}. * @see {@link ForwardRefRenderFunction} // Making T nullable is assuming the refs will be managed by React or the component impl will write it somewhere else. // But this isn't necessarily true. We haven't heard complains about it yet and hopefully `forwardRef` is removed from React before we do. type ForwardedRef<T> = ((instance: T | null) => void) | RefObject<T | null> | null; The type of the function passed to {@link forwardRef}. This is considered different to a normal {@link FunctionComponent} because it receives an additional argument, * @param props Props passed to the component, if any. @param ref A ref forwarded to the component of type {@link ForwardedRef}. * @template T The type of the forwarded ref. @template P The type of the props the component accepts. * @see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/forward_and_create_ref/ React TypeScript Cheatsheet} @see {@link forwardRef} interface ForwardRefRenderFunction<T, P = {}> { (props: P, ref: ForwardedRef<T>): ReactNode; Used in debugging messages. You might want to set it explicitly if you want to display a different name for debugging purposes. * Will show `ForwardRef(${Component.displayName || Component.name})` in devtools by default, but can be given its own specific name. * @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs} displayName?: string | undefined; Ignored by React. @deprecated Only kept in types for backwards compatibility. Will be removed in a future major release. propTypes?: any; } Represents a component class in React. * @template P The props the component accepts. @template S The internal state of the component. interface ComponentClass<P = {}, S = ComponentState> extends StaticLifecycle<P, S> { // constructor signature must match React.Component new(props: P): Component<P, S>; Ignored by React. @deprecated Only kept in types for backwards compatibility. Will be removed in a future major release. propTypes?: any; contextType?: Context<any> | undefined; defaultProps?: Partial<P> | undefined; Used in debugging messages. You might want to set it explicitly if you want to display a different name for debugging purposes. * @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs} displayName?: string | undefined; } @deprecated Use `ClassicComponentClass` from `create-react-class` * @see {@link https://legacy.reactjs.org/docs/react-without-es6.html Legacy React Docs} @see {@link https://www.npmjs.com/package/create-react-class `create-react-class` on npm} interface ClassicComponentClass<P = {}> extends ComponentClass<P> { new(props: P): ClassicComponent<P, ComponentState>; getDefaultProps?(): P; } Used in {@link createElement} and {@link createFactory} to represent a class. * An intersection type is used to infer multiple type parameters from a single argument, which is useful for many top-level API defs. See {@link https://github.com/Microsoft/TypeScript/issues/7234 this GitHub issue} for more info. type ClassType<P, T extends Component<P, ComponentState>, C extends ComponentClass<P>> = & C & (new(props: P) => T); // // Component Specs and Lifecycle // ---------------------------------------------------------------------- // This should actually be something like `Lifecycle<P, S> | DeprecatedLifecycle<P, S>`, // as React will _not_ call the deprecated lifecycle methods if any of the new lifecycle // methods are present. interface ComponentLifecycle<P, S, SS = any> extends NewLifecycle<P, S, SS>, DeprecatedLifecycle<P, S> { Called immediately after a component is mounted. Setting state here will trigger re-rendering. componentDidMount?(): void; Called to determine whether the change in props and state should trigger a re-render. * `Component` always returns true. `PureComponent` implements a shallow comparison on props and state and returns true if any props or states have changed. * If false is returned, {@link Component.render}, `componentWillUpdate` and `componentDidUpdate` will not be called. shouldComponentUpdate?(nextProps: Readonly<P>, nextState: Readonly<S>, nextContext: any): boolean; Called immediately before a component is destroyed. Perform any necessary cleanup in this method, such as cancelled network requests, or cleaning up any DOM elements created in `componentDidMount`. componentWillUnmount?(): void; Catches exceptions generated in descendant components. Unhandled exceptions will cause the entire component tree to unmount. componentDidCatch?(error: Error, errorInfo: ErrorInfo): void; } // Unfortunately, we have no way of declaring that the component constructor must implement this interface StaticLifecycle<P, S> { getDerivedStateFromProps?: GetDerivedStateFromProps<P, S> | undefined; getDerivedStateFromError?: GetDerivedStateFromError<P, S> | undefined; } type GetDerivedStateFromProps<P, S> = Returns an update to a component's state based on its new props and old state. * Note: its presence prevents any of the deprecated lifecycle methods from being invoked (nextProps: Readonly<P>, prevState: S) => Partial<S> | null; type GetDerivedStateFromError<P, S> = This lifecycle is invoked after an error has been thrown by a descendant component. It receives the error that was thrown as a parameter and should return a value to update state. * Note: its presence prevents any of the deprecated lifecycle methods from being invoked (error: any) => Partial<S> | null; // This should be \"infer SS\" but can't use it yet interface NewLifecycle<P, S, SS> { Runs before React applies the result of {@link Component.render render} to the document, and returns an object to be given to {@link componentDidUpdate}. Useful for saving things such as scroll position before {@link Component.render render} causes changes to it. * Note: the presence of this method prevents any of the deprecated lifecycle events from running. getSnapshotBeforeUpdate?(prevProps: Readonly<P>, prevState: Readonly<S>): SS | null; Called immediately after updating occurs. Not called for the initial render. * The snapshot is only present if {@link getSnapshotBeforeUpdate} is present and returns non-null. componentDidUpdate?(prevProps: Readonly<P>, prevState: Readonly<S>, snapshot?: SS): void; } interface DeprecatedLifecycle<P, S> { Called immediately before mounting occurs, and before {@link Component.render}. Avoid introducing any side-effects or subscriptions in this method. * Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate} or {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents this from being invoked. * @deprecated 16.3, use {@link ComponentLifecycle.componentDidMount componentDidMount} or the constructor instead; will stop working in React 17 @see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#initializing-state} @see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path} componentWillMount?(): void; Called immediately before mounting occurs, and before {@link Component.render}. Avoid introducing any side-effects or subscriptions in this method. * This method will not stop working in React 17. * Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate} or {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents this from being invoked. * @deprecated 16.3, use {@link ComponentLifecycle.componentDidMount componentDidMount} or the constructor instead @see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#initializing-state} @see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path} UNSAFE_componentWillMount?(): void; Called when the component may be receiving new props. React may call this even if props have not changed, so be sure to compare new and existing props if you only want to handle changes. * Calling {@link Component.setState} generally does not trigger this method. * Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate} or {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents this from being invoked. * @deprecated 16.3, use static {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} instead; will stop working in React 17 @see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#updating-state-based-on-props} @see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path} componentWillReceiveProps?(nextProps: Readonly<P>, nextContext: any): void; Called when the component may be receiving new props. React may call this even if props have not changed, so be sure to compare new and existing props if you only want to handle changes. * Calling {@link Component.setState} generally does not trigger this method. * This method will not stop working in React 17. * Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate} or {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents this from being invoked. * @deprecated 16.3, use static {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} instead @see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#updating-state-based-on-props} @see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path} UNSAFE_componentWillReceiveProps?(nextProps: Readonly<P>, nextContext: any): void; Called immediately before rendering when new props or state is received. Not called for the initial render. * Note: You cannot call {@link Component.setState} here. * Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate} or {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents this from being invoked. * @deprecated 16.3, use getSnapshotBeforeUpdate instead; will stop working in React 17 @see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#reading-dom-properties-before-an-update} @see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path} componentWillUpdate?(nextProps: Readonly<P>, nextState: Readonly<S>, nextContext: any): void; Called immediately before rendering when new props or state is received. Not called for the initial render. * Note: You cannot call {@link Component.setState} here. * This method will not stop working in React 17. * Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate} or {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents this from being invoked. * @deprecated 16.3, use getSnapshotBeforeUpdate instead @see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#reading-dom-properties-before-an-update} @see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path} UNSAFE_componentWillUpdate?(nextProps: Readonly<P>, nextState: Readonly<S>, nextContext: any): void; } function createRef<T>(): RefObject<T | null>; The type of the component returned from {@link forwardRef}. * @template P The props the component accepts, if any. * @see {@link ExoticComponent} interface ForwardRefExoticComponent<P> extends NamedExoticComponent<P> { Ignored by React. @deprecated Only kept in types for backwards compatibility. Will be removed in a future major release. propTypes?: any; } Lets your component expose a DOM node to a parent component using a ref. * @see {@link https://react.dev/reference/react/forwardRef React Docs} @see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/forward_and_create_ref/ React TypeScript Cheatsheet} * @param render See the {@link ForwardRefRenderFunction}. * @template T The type of the DOM node. @template P The props the component accepts, if any. * @example * ```tsx interface Props { children?: ReactNode; type: \"submit\" | \"button\"; } * export const FancyButton = forwardRef<HTMLButtonElement, Props>((props, ref) => ( <button ref={ref} className=\"MyClassName\" type={props.type}> {props.children} </button> )); ``` function forwardRef<T, P = {}>( render: ForwardRefRenderFunction<T, PropsWithoutRef<P>>, ): ForwardRefExoticComponent<PropsWithoutRef<P> & RefAttributes<T>>; Omits the 'ref' attribute from the given props object. * @template Props The props object type. type PropsWithoutRef<Props> = // Omit would not be sufficient for this. We'd like to avoid unnecessary mapping and need a distributive conditional to support unions. // see: https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types // https://github.com/Microsoft/TypeScript/issues/28339 Props extends any ? (\"ref\" extends keyof Props ? Omit<Props, \"ref\"> : Props) : Props; Ensures that the props do not include string ref, which cannot be forwarded @deprecated Use `Props` directly. `PropsWithRef<Props>` is just an alias for `Props` type PropsWithRef<Props> = Props; type PropsWithChildren<P = unknown> = P & { children?: ReactNode | undefined }; Used to retrieve the props a component accepts. Can either be passed a string, indicating a DOM element (e.g. 'div', 'span', etc.) or the type of a React component. * It's usually better to use {@link ComponentPropsWithRef} or {@link ComponentPropsWithoutRef} instead of this type, as they let you be explicit about whether or not to include the `ref` prop. * @see {@link https://react-typescript-cheatsheet.netlify.app/docs/react-types/componentprops/ React TypeScript Cheatsheet} * @example * ```tsx // Retrieves the props an 'input' element accepts type InputProps = React.ComponentProps<'input'>; ``` * @example * ```tsx const MyComponent = (props: { foo: number, bar: string }) => <div />; * // Retrieves the props 'MyComponent' accepts type MyComponentProps = React.ComponentProps<typeof MyComponent>; ``` type ComponentProps<T extends keyof JSX.IntrinsicElements | JSXElementConstructor<any>> = T extends JSXElementConstructor<infer Props> ? Props : T extends keyof JSX.IntrinsicElements ? JSX.IntrinsicElements[T] : {}; Used to retrieve the props a component accepts with its ref. Can either be passed a string, indicating a DOM element (e.g. 'div', 'span', etc.) or the type of a React component. * @see {@link https://react-typescript-cheatsheet.netlify.app/docs/react-types/componentprops/ React TypeScript Cheatsheet} * @example * ```tsx // Retrieves the props an 'input' element accepts type InputProps = React.ComponentPropsWithRef<'input'>; ``` * @example * ```tsx const MyComponent = (props: { foo: number, bar: string }) => <div />; * // Retrieves the props 'MyComponent' accepts type MyComponentPropsWithRef = React.ComponentPropsWithRef<typeof MyComponent>; ``` type ComponentPropsWithRef<T extends ElementType> = T extends JSXElementConstructor<infer Props> // If it's a class i.e. newable we're dealing with a class component ? T extends abstract new(args: any) => any ? PropsWithoutRef<Props> & RefAttributes<InstanceType<T>> : Props : ComponentProps<T>; Used to retrieve the props a custom component accepts with its ref. * Unlike {@link ComponentPropsWithRef}, this only works with custom components, i.e. components you define yourself. This is to improve type-checking performance. * @example * ```tsx const MyComponent = (props: { foo: number, bar: string }) => <div />; * // Retrieves the props 'MyComponent' accepts type MyComponentPropsWithRef = React.CustomComponentPropsWithRef<typeof MyComponent>; ``` type CustomComponentPropsWithRef<T extends ComponentType> = T extends JSXElementConstructor<infer Props> // If it's a class i.e. newable we're dealing with a class component ? T extends abstract new(args: any) => any ? PropsWithoutRef<Props> & RefAttributes<InstanceType<T>> : Props : never; Used to retrieve the props a component accepts without its ref. Can either be passed a string, indicating a DOM element (e.g. 'div', 'span', etc.) or the type of a React component. * @see {@link https://react-typescript-cheatsheet.netlify.app/docs/react-types/componentprops/ React TypeScript Cheatsheet} * @example * ```tsx // Retrieves the props an 'input' element accepts type InputProps = React.ComponentPropsWithoutRef<'input'>; ``` * @example * ```tsx const MyComponent = (props: { foo: number, bar: string }) => <div />; * // Retrieves the props 'MyComponent' accepts type MyComponentPropsWithoutRef = React.ComponentPropsWithoutRef<typeof MyComponent>; ``` type ComponentPropsWithoutRef<T extends ElementType> = PropsWithoutRef<ComponentProps<T>>; Retrieves the type of the 'ref' prop for a given component type or tag name. * @template C The component type. * @example * ```tsx type MyComponentRef = React.ComponentRef<typeof MyComponent>; ``` * @example * ```tsx type DivRef = React.ComponentRef<'div'>; ``` type ComponentRef<T extends ElementType> = ComponentPropsWithRef<T> extends RefAttributes<infer Method> ? Method : never; // will show `Memo(${Component.displayName || Component.name})` in devtools by default, // but can be given its own specific name type MemoExoticComponent<T extends ComponentType<any>> = NamedExoticComponent<CustomComponentPropsWithRef<T>> & { readonly type: T; }; Lets you skip re-rendering a component when its props are unchanged. * @see {@link https://react.dev/reference/react/memo React Docs} * @param Component The component to memoize. @param propsAreEqual A function that will be used to determine if the props have changed. * @example * ```tsx import { memo } from 'react'; * const SomeComponent = memo(function SomeComponent(props: { foo: string }) { // ... }); ``` function memo<P extends object>( Component: FunctionComponent<P>, propsAreEqual?: (prevProps: Readonly<P>, nextProps: Readonly<P>) => boolean, ): NamedExoticComponent<P>; function memo<T extends ComponentType<any>>( Component: T, propsAreEqual?: (prevProps: Readonly<ComponentProps<T>>, nextProps: Readonly<ComponentProps<T>>) => boolean, ): MemoExoticComponent<T>; interface LazyExoticComponent<T extends ComponentType<any>> extends ExoticComponent<CustomComponentPropsWithRef<T>> { readonly _result: T; } Lets you defer loading a component’s code until it is rendered for the first time. * @see {@link https://react.dev/reference/react/lazy React Docs} * @param load A function that returns a `Promise` or another thenable (a `Promise`-like object with a then method). React will not call `load` until the first time you attempt to render the returned component. After React first calls load, it will wait for it to resolve, and then render the resolved value’s `.default` as a React component. Both the returned `Promise` and the `Promise`’s resolved value will be cached, so React will not call load more than once. If the `Promise` rejects, React will throw the rejection reason for the nearest Error Boundary to handle. * @example * ```tsx import { lazy } from 'react'; * const MarkdownPreview = lazy(() => import('./MarkdownPreview.js')); ``` function lazy<T extends ComponentType<any>>( load: () => Promise<{ default: T }>, ): LazyExoticComponent<T>; // // React Hooks // ---------------------------------------------------------------------- The instruction passed to a {@link Dispatch} function in {@link useState} to tell React what the next value of the {@link useState} should be. * Often found wrapped in {@link Dispatch}. * @template S The type of the state. * @example * ```tsx // This return type correctly represents the type of // `setCount` in the example below. const useCustomState = (): Dispatch<SetStateAction<number>> => { const [count, setCount] = useState(0); * return setCount; } ``` type SetStateAction<S> = S | ((prevState: S) => S); A function that can be used to update the state of a {@link useState} or {@link useReducer} hook. type Dispatch<A> = (value: A) => void; A {@link Dispatch} function can sometimes be called without any arguments. type DispatchWithoutAction = () => void; // Limit the reducer to accept only 0 or 1 action arguments // eslint-disable-next-line @definitelytyped/no-single-element-tuple-type type AnyActionArg = [] | [any]; // Get the dispatch type from the reducer arguments (captures optional action argument correctly) type ActionDispatch<ActionArg extends AnyActionArg> = (...args: ActionArg) => void; // Unlike redux, the actions _can_ be anything type Reducer<S, A> = (prevState: S, action: A) => S; // If useReducer accepts a reducer without action, dispatch may be called without any parameters. type ReducerWithoutAction<S> = (prevState: S) => S; // types used to try and prevent the compiler from reducing S // to a supertype common with the second argument to useReducer() type ReducerState<R extends Reducer<any, any>> = R extends Reducer<infer S, any> ? S : never; type DependencyList = readonly unknown[]; // NOTE: callbacks are _only_ allowed to return either void, or a destructor. type EffectCallback = () => void | Destructor; @deprecated Use `RefObject` instead. interface MutableRefObject<T> { current: T; } // This will technically work if you give a Consumer<T> or Provider<T> but it's deprecated and warns Accepts a context object (the value returned from `React.createContext`) and returns the current context value, as given by the nearest context provider for the given context. * @version 16.8.0 @see {@link https://react.dev/reference/react/useContext} function useContext<T>(context: Context<T> /*, (not public API) observedBits?: number|boolean ): T; Returns a stateful value, and a function to update it. * @version 16.8.0 @see {@link https://react.dev/reference/react/useState} function useState<S>(initialState: S | (() => S)): [S, Dispatch<SetStateAction<S>>]; // convenience overload when first argument is omitted Returns a stateful value, and a function to update it. * @version 16.8.0 @see {@link https://react.dev/reference/react/useState} function useState<S = undefined>(): [S | undefined, Dispatch<SetStateAction<S | undefined>>]; An alternative to `useState`. * `useReducer` is usually preferable to `useState` when you have complex state logic that involves multiple sub-values. It also lets you optimize performance for components that trigger deep updates because you can pass `dispatch` down instead of callbacks. * @version 16.8.0 @see {@link https://react.dev/reference/react/useReducer} function useReducer<S, A extends AnyActionArg>( reducer: (prevState: S, ...args: A) => S, initialState: S, ): [S, ActionDispatch<A>]; An alternative to `useState`. * `useReducer` is usually preferable to `useState` when you have complex state logic that involves multiple sub-values. It also lets you optimize performance for components that trigger deep updates because you can pass `dispatch` down instead of callbacks. * @version 16.8.0 @see {@link https://react.dev/reference/react/useReducer} function useReducer<S, A extends AnyActionArg>( reducer: (prevState: S, ...args: A) => S, initialState: S, ): [S, ActionDispatch<A>]; An alternative to `useState`. * `useReducer` is usually preferable to `useState` when you have complex state logic that involves multiple sub-values. It also lets you optimize performance for components that trigger deep updates because you can pass `dispatch` down instead of callbacks. * @version 16.8.0 @see {@link https://react.dev/reference/react/useReducer} function useReducer<S, I, A extends AnyActionArg>( reducer: (prevState: S, ...args: A) => S, initialArg: I, init: (i: I) => S, ): [S, ActionDispatch<A>]; `useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument (`initialValue`). The returned object will persist for the full lifetime of the component. * Note that `useRef()` is useful for more than the `ref` attribute. It’s handy for keeping any mutable value around similar to how you’d use instance fields in classes. * @version 16.8.0 @see {@link https://react.dev/reference/react/useRef} function useRef<T>(initialValue: T): RefObject<T>; // convenience overload for refs given as a ref prop as they typically start with a null value `useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument (`initialValue`). The returned object will persist for the full lifetime of the component. * Note that `useRef()` is useful for more than the `ref` attribute. It’s handy for keeping any mutable value around similar to how you’d use instance fields in classes. * @version 16.8.0 @see {@link https://react.dev/reference/react/useRef} function useRef<T>(initialValue: T | null): RefObject<T | null>; // convenience overload for undefined initialValue `useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument (`initialValue`). The returned object will persist for the full lifetime of the component. * Note that `useRef()` is useful for more than the `ref` attribute. It’s handy for keeping any mutable value around similar to how you’d use instance fields in classes. * @version 16.8.0 @see {@link https://react.dev/reference/react/useRef} function useRef<T>(initialValue: T | undefined): RefObject<T | undefined>; The signature is identical to `useEffect`, but it fires synchronously after all DOM mutations. Use this to read layout from the DOM and synchronously re-render. Updates scheduled inside `useLayoutEffect` will be flushed synchronously, before the browser has a chance to paint. * Prefer the standard `useEffect` when possible to avoid blocking visual updates. * If you’re migrating code from a class component, `useLayoutEffect` fires in the same phase as `componentDidMount` and `componentDidUpdate`. * @version 16.8.0 @see {@link https://react.dev/reference/react/useLayoutEffect} function useLayoutEffect(effect: EffectCallback, deps?: DependencyList): void; Accepts a function that contains imperative, possibly effectful code. * @param effect Imperative function that can return a cleanup function @param deps If present, effect will only activate if the values in the list change. * @version 16.8.0 @see {@link https://react.dev/reference/react/useEffect} function useEffect(effect: EffectCallback, deps?: DependencyList): void; // NOTE: this does not accept strings, but this will have to be fixed by removing strings from type Ref<T> `useImperativeHandle` customizes the instance value that is exposed to parent components when using `ref`. As always, imperative code using refs should be avoided in most cases. * `useImperativeHandle` should be used with `React.forwardRef`. * @version 16.8.0 @see {@link https://react.dev/reference/react/useImperativeHandle} function useImperativeHandle<T, R extends T>(ref: Ref<T> | undefined, init: () => R, deps?: DependencyList): void; // I made 'inputs' required here and in useMemo as there's no point to memoizing without the memoization key // useCallback(X) is identical to just using X, useMemo(() => Y) is identical to just using Y. `useCallback` will return a memoized version of the callback that only changes if one of the `inputs` has changed. * @version 16.8.0 @see {@link https://react.dev/reference/react/useCallback} // A specific function type would not trigger implicit any. // See https://github.com/DefinitelyTyped/DefinitelyTyped/issues/52873#issuecomment-845806435 for a comparison between `Function` and more specific types. // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type function useCallback<T extends Function>(callback: T, deps: DependencyList): T; `useMemo` will only recompute the memoized value when one of the `deps` has changed. * @version 16.8.0 @see {@link https://react.dev/reference/react/useMemo} // allow undefined, but don't make it optional as that is very likely a mistake function useMemo<T>(factory: () => T, deps: DependencyList): T; `useDebugValue` can be used to display a label for custom hooks in React DevTools. * NOTE: We don’t recommend adding debug values to every custom hook. It’s most valuable for custom hooks that are part of shared libraries. * @version 16.8.0 @see {@link https://react.dev/reference/react/useDebugValue} // the name of the custom hook is itself derived from the function name at runtime: // it's just the function name without the \"use\" prefix. function useDebugValue<T>(value: T, format?: (value: T) => any): void; export type TransitionFunction = () => VoidOrUndefinedOnly | Promise<VoidOrUndefinedOnly>; // strange definition to allow vscode to show documentation on the invocation export interface TransitionStartFunction { State updates caused inside the callback are allowed to be deferred. * **If some state update causes a component to suspend, that state update should be wrapped in a transition.** * @param callback A function which causes state updates that can be deferred. (callback: TransitionFunction): void; } Returns a deferred version of the value that may “lag behind” it. * This is commonly used to keep the interface responsive when you have something that renders immediately based on user input and something that needs to wait for a data fetch. * A good example of this is a text input. * @param value The value that is going to be deferred @param initialValue A value to use during the initial render of a component. If this option is omitted, `useDeferredValue` will not defer during the initial render, because there’s no previous version of `value` that it can render instead. * @see {@link https://react.dev/reference/react/useDeferredValue} export function useDeferredValue<T>(value: T, initialValue?: T): T; Allows components to avoid undesirable loading states by waiting for content to load before transitioning to the next screen. It also allows components to defer slower, data fetching updates until subsequent renders so that more crucial updates can be rendered immediately. * The `useTransition` hook returns two values in an array. * The first is a boolean, React’s way of informing us whether we’re waiting for the transition to finish. The second is a function that takes a callback. We can use it to tell React which state we want to defer. * **If some state update causes a component to suspend, that state update should be wrapped in a transition.** * @see {@link https://react.dev/reference/react/useTransition}",
    "description": "Added new function useTransition",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nUsed to represent DOM API's where users can either pass\ntrue or false as a boolean or as its equivalent strings.\n \ntype Booleanish = boolean | \"true\" | \"false\";\n@see {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/crossorigin MDN}\n \ntype CrossOrigin = \"anonymous\" | \"use-credentials\" | \"\" | undefined;\n\ndeclare const UNDEFINED_VOID_ONLY: unique symbol;\n@internal Use `Awaited<ReactNode>` instead\n \n// Helper type to enable `Awaited<ReactNode>`.\n// Must be a copy of the non-thenables of `ReactNode`.\ntype AwaitedReactNode =\n    | React.ReactElement\n    | string\n    | number\n    | bigint\n    | Iterable<React.ReactNode>\n    | React.ReactPortal\n    | boolean\n    | null\n    | undefined\n    | React.DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES[\n        keyof React.DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES\n    ];\nThe function returned from an effect passed to {@link React.useEffect useEffect},\nwhich can be used to clean up the effect when the component unmounts.\n* @see {@link https://react.dev/reference/react/useEffect React Docs}\n \ntype Destructor = () => void | { [UNDEFINED_VOID_ONLY]: never };\ntype VoidOrUndefinedOnly = void | { [UNDEFINED_VOID_ONLY]: never };\n\n// eslint-disable-next-line @definitelytyped/export-just-namespace\nexport = React;\nexport as namespace React;\n\ndeclare namespace React {\n    //\n    // React Elements\n    // ----------------------------------------------------------------------\nUsed to retrieve the possible components which accept a given set of props.\n* Can be passed no type parameters to get a union of all possible components\nand tags.\n* Is a superset of {@link ComponentType}.\n* @template P The props to match against. If not passed, defaults to any.\n@template Tag An optional tag to match against. If not passed, attempts to match against all possible tags.\n* @example\n* ```tsx\n// All components and tags (img, embed etc.)\n// which accept `src`\ntype SrcComponents = ElementType<{ src: any }>;\n```\n* @example\n* ```tsx\n// All components\ntype AllComponents = ElementType;\n```\n* @example\n* ```tsx\n// All custom components which match `src`, and tags which\n// match `src`, narrowed down to just `audio` and `embed`\ntype SrcComponents = ElementType<{ src: any }, 'audio' | 'embed'>;\n```\n     \n    type ElementType<P = any, Tag extends keyof JSX.IntrinsicElements = keyof JSX.IntrinsicElements> =\n        | { [K in Tag]: P extends JSX.IntrinsicElements[K] ? K : never }[Tag]\n        | ComponentType<P>;\nRepresents any user-defined component, either as a function or a class.\n* Similar to {@link JSXElementConstructor}, but with extra properties like\n{@link FunctionComponent.defaultProps defaultProps }.\n* @template P The props the component accepts.\n* @see {@link ComponentClass}\n@see {@link FunctionComponent}\n     \n    type ComponentType<P = {}> = ComponentClass<P> | FunctionComponent<P>;\nRepresents any user-defined component, either as a function or a class.\n* Similar to {@link ComponentType}, but without extra properties like\n{@link FunctionComponent.defaultProps defaultProps }.\n* @template P The props the component accepts.\n     \n    type JSXElementConstructor<P> =\n        | ((\n            props: P,\n        ) => ReactNode | Promise<ReactNode>)\n        // constructor signature must match React.Component\n        | (new(props: P) => Component<any, any>);\nCreated by {@link createRef}, or {@link useRef} when passed `null`.\n* @template T The type of the ref's value.\n* @example\n* ```tsx\nconst ref = createRef<HTMLDivElement>();\n* ref.current = document.createElement('div'); // Error\n```\n     \n    interface RefObject<T> {\nThe current value of the ref.\n         \n        current: T;\n    }\n\n    interface DO_NOT_USE_OR_YOU_WILL_BE_FIRED_CALLBACK_REF_RETURN_VALUES {\n    }\nA callback fired whenever the ref's value changes.\n* @template T The type of the ref's value.\n* @see {@link https://react.dev/reference/react-dom/components/common#ref-callback React Docs}\n* @example\n* ```tsx\n<div ref={(node) => console.log(node)} />\n```\n     \n    type RefCallback<T> = {\n        bivarianceHack(\n            instance: T | null,\n        ):\n            | void\n            | (() => VoidOrUndefinedOnly)\n            | DO_NOT_USE_OR_YOU_WILL_BE_FIRED_CALLBACK_REF_RETURN_VALUES[\n                keyof DO_NOT_USE_OR_YOU_WILL_BE_FIRED_CALLBACK_REF_RETURN_VALUES\n            ];\n    }[\"bivarianceHack\"];\nA union type of all possible shapes for React refs.\n* @see {@link RefCallback}\n@see {@link RefObject}\n     \n\n    type Ref<T> = RefCallback<T> | RefObject<T | null> | null;\n@deprecated Use `Ref` instead. String refs are no longer supported.\nIf you're typing a library with support for React versions with string refs, use `RefAttributes<T>['ref']` instead.\n     \n    type LegacyRef<T> = Ref<T>;\n@deprecated Use `ComponentRef<T>` instead\n* Retrieves the type of the 'ref' prop for a given component type or tag name.\n* @template C The component type.\n* @example\n* ```tsx\ntype MyComponentRef = React.ElementRef<typeof MyComponent>;\n```\n* @example\n* ```tsx\ntype DivRef = React.ElementRef<'div'>;\n```\n     \n    type ElementRef<\n        C extends\n            | ForwardRefExoticComponent<any>\n            | { new(props: any): Component<any> }\n            | ((props: any) => ReactNode)\n            | keyof JSX.IntrinsicElements,\n    > = ComponentRef<C>;\n\n    type ComponentState = any;\nA value which uniquely identifies a node among items in an array.\n* @see {@link https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key React Docs}\n     \n    type Key = string | number | bigint;\n@internal The props any component can receive.\nYou don't have to add this type. All components automatically accept these props.\n```tsx\nconst Component = () => <div />;\n<Component key=\"one\" />\n```\n* WARNING: The implementation of a component will never have access to these attributes.\nThe following example would be incorrect usage because {@link Component} would never have access to `key`:\n```tsx\nconst Component = (props: React.Attributes) => props.key;\n```\n     \n    interface Attributes {\n        key?: Key | null | undefined;\n    }\nThe props any component accepting refs can receive.\nClass components, built-in browser components (e.g. `div`) and forwardRef components can receive refs and automatically accept these props.\n```tsx\nconst Component = forwardRef(() => <div />);\n<Component ref={(current) => console.log(current)} />\n```\n* You only need this type if you manually author the types of props that need to be compatible with legacy refs.\n```tsx\ninterface Props extends React.RefAttributes<HTMLDivElement> {}\ndeclare const Component: React.FunctionComponent<Props>;\n```\n* Otherwise it's simpler to directly use {@link Ref} since you can safely use the\nprops type to describe to props that a consumer can pass to the component\nas well as describing the props the implementation of a component \"sees\".\n{@link RefAttributes} is generally not safe to describe both consumer and seen props.\n* ```tsx\ninterface Props extends {\nref?: React.Ref<HTMLDivElement> | undefined;\n}\ndeclare const Component: React.FunctionComponent<Props>;\n```\n* WARNING: The implementation of a component will not have access to the same type in versions of React supporting string refs.\nThe following example would be incorrect usage because {@link Component} would never have access to a `ref` with type `string`\n```tsx\nconst Component = (props: React.RefAttributes) => props.ref;\n```\n     \n    interface RefAttributes<T> extends Attributes {\nAllows getting a ref to the component instance.\nOnce the component unmounts, React will set `ref.current` to `null`\n(or call the ref with `null` if you passed a callback ref).\n* @see {@link https://react.dev/learn/referencing-values-with-refs#refs-and-the-dom React Docs}\n         \n        ref?: Ref<T> | undefined;\n    }\nRepresents the built-in attributes available to class components.\n     \n    interface ClassAttributes<T> extends RefAttributes<T> {\n    }\nRepresents a JSX element.\n* Where {@link ReactNode} represents everything that can be rendered, `ReactElement`\nonly represents JSX.\n* @template P The type of the props object\n@template T The type of the component or tag\n* @example\n* ```tsx\nconst element: ReactElement = <div />;\n```\n     \n    interface ReactElement<\n        P = unknown,\n        T extends string | JSXElementConstructor<any> = string | JSXElementConstructor<any>,\n    > {\n        type: T;\n        props: P;\n        key: string | null;\n    }\n@deprecated\n     \n    interface ReactComponentElement<\n        T extends keyof JSX.IntrinsicElements | JSXElementConstructor<any>,\n        P = Pick<ComponentProps<T>, Exclude<keyof ComponentProps<T>, \"key\" | \"ref\">>,\n    > extends ReactElement<P, Exclude<T, number>> {}\n@deprecated Use `ReactElement<P, React.FunctionComponent<P>>`\n     \n    interface FunctionComponentElement<P> extends ReactElement<P, FunctionComponent<P>> {\n@deprecated Use `element.props.ref` instead.\n         \n        ref?: (\"ref\" extends keyof P ? P extends { ref?: infer R | undefined } ? R : never : never) | undefined;\n    }\n@deprecated Use `ReactElement<P, React.ComponentClass<P>>`\n     \n    type CElement<P, T extends Component<P, ComponentState>> = ComponentElement<P, T>;\n@deprecated Use `ReactElement<P, React.ComponentClass<P>>`\n     \n    interface ComponentElement<P, T extends Component<P, ComponentState>> extends ReactElement<P, ComponentClass<P>> {\n@deprecated Use `element.props.ref` instead.\n         \n        ref?: Ref<T> | undefined;\n    }\n@deprecated Use {@link ComponentElement} instead.\n     \n    type ClassicElement<P> = CElement<P, ClassicComponent<P, ComponentState>>;\n\n    // string fallback for custom web-components\n@deprecated Use `ReactElement<P, string>`\n     \n    interface DOMElement<P extends HTMLAttributes<T> | SVGAttributes<T>, T extends Element>\n        extends ReactElement<P, string>\n    {\n@deprecated Use `element.props.ref` instead.\n         \n        ref: Ref<T>;\n    }\n\n    // ReactHTML for ReactHTMLElement\n    interface ReactHTMLElement<T extends HTMLElement> extends DetailedReactHTMLElement<AllHTMLAttributes<T>, T> {}\n\n    interface DetailedReactHTMLElement<P extends HTMLAttributes<T>, T extends HTMLElement> extends DOMElement<P, T> {\n        type: HTMLElementType;\n    }\n\n    // ReactSVG for ReactSVGElement\n    interface ReactSVGElement extends DOMElement<SVGAttributes<SVGElement>, SVGElement> {\n        type: SVGElementType;\n    }\n\n    interface ReactPortal extends ReactElement {\n        children: ReactNode;\n    }\nDifferent release channels declare additional types of ReactNode this particular release channel accepts.\nApp or library types should never augment this interface.\n     \n    interface DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES {}\nRepresents all of the things React can render.\n* Where {@link ReactElement} only represents JSX, `ReactNode` represents everything that can be rendered.\n* @see {@link https://react-typescript-cheatsheet.netlify.app/docs/react-types/reactnode/ React TypeScript Cheatsheet}\n* @example\n* ```tsx\n// Typing children\ntype Props = { children: ReactNode }\n* const Component = ({ children }: Props) => <div>{children}</div>\n* <Component>hello</Component>\n```\n* @example\n* ```tsx\n// Typing a custom element\ntype Props = { customElement: ReactNode }\n* const Component = ({ customElement }: Props) => <div>{customElement}</div>\n* <Component customElement={<div>hello</div>} />\n```\n     \n    // non-thenables need to be kept in sync with AwaitedReactNode\n    type ReactNode =\n        | ReactElement\n        | string\n        | number\n        | bigint\n        | Iterable<ReactNode>\n        | ReactPortal\n        | boolean\n        | null\n        | undefined\n        | DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES[\n            keyof DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES\n        ]\n        | Promise<AwaitedReactNode>;\n\n    //\n    // Top Level API\n    // ----------------------------------------------------------------------\n\n    // DOM Elements\n    // TODO: generalize this to everything in `keyof ReactHTML`, not just \"input\"\n    function createElement(\n        type: \"input\",\n        props?: InputHTMLAttributes<HTMLInputElement> & ClassAttributes<HTMLInputElement> | null,\n        ...children: ReactNode[]\n    ): DetailedReactHTMLElement<InputHTMLAttributes<HTMLInputElement>, HTMLInputElement>;\n    function createElement<P extends HTMLAttributes<T>, T extends HTMLElement>(\n        type: HTMLElementType,\n        props?: ClassAttributes<T> & P | null,\n        ...children: ReactNode[]\n    ): DetailedReactHTMLElement<P, T>;\n    function createElement<P extends SVGAttributes<T>, T extends SVGElement>(\n        type: SVGElementType,\n        props?: ClassAttributes<T> & P | null,\n        ...children: ReactNode[]\n    ): ReactSVGElement;\n    function createElement<P extends DOMAttributes<T>, T extends Element>(\n        type: string,\n        props?: ClassAttributes<T> & P | null,\n        ...children: ReactNode[]\n    ): DOMElement<P, T>;\n\n    // Custom components\n\n    function createElement<P extends {}>(\n        type: FunctionComponent<P>,\n        props?: Attributes & P | null,\n        ...children: ReactNode[]\n    ): FunctionComponentElement<P>;\n    function createElement<P extends {}, T extends Component<P, ComponentState>, C extends ComponentClass<P>>(\n        type: ClassType<P, T, C>,\n        props?: ClassAttributes<T> & P | null,\n        ...children: ReactNode[]\n    ): CElement<P, T>;\n    function createElement<P extends {}>(\n        type: FunctionComponent<P> | ComponentClass<P> | string,\n        props?: Attributes & P | null,\n        ...children: ReactNode[]\n    ): ReactElement<P>;\n\n    // DOM Elements\n    // ReactHTMLElement\n    function cloneElement<P extends HTMLAttributes<T>, T extends HTMLElement>(\n        element: DetailedReactHTMLElement<P, T>,\n        props?: P,\n        ...children: ReactNode[]\n    ): DetailedReactHTMLElement<P, T>;\n    // ReactHTMLElement, less specific\n    function cloneElement<P extends HTMLAttributes<T>, T extends HTMLElement>(\n        element: ReactHTMLElement<T>,\n        props?: P,\n        ...children: ReactNode[]\n    ): ReactHTMLElement<T>;\n    // SVGElement\n    function cloneElement<P extends SVGAttributes<T>, T extends SVGElement>(\n        element: ReactSVGElement,\n        props?: P,\n        ...children: ReactNode[]\n    ): ReactSVGElement;\n    // DOM Element (has to be the last, because type checking stops at first overload that fits)\n    function cloneElement<P extends DOMAttributes<T>, T extends Element>(\n        element: DOMElement<P, T>,\n        props?: DOMAttributes<T> & P,\n        ...children: ReactNode[]\n    ): DOMElement<P, T>;\n\n    // Custom components\n    function cloneElement<P>(\n        element: FunctionComponentElement<P>,\n        props?: Partial<P> & Attributes,\n        ...children: ReactNode[]\n    ): FunctionComponentElement<P>;\n    function cloneElement<P, T extends Component<P, ComponentState>>(\n        element: CElement<P, T>,\n        props?: Partial<P> & ClassAttributes<T>,\n        ...children: ReactNode[]\n    ): CElement<P, T>;\n    function cloneElement<P>(\n        element: ReactElement<P>,\n        props?: Partial<P> & Attributes,\n        ...children: ReactNode[]\n    ): ReactElement<P>;\nDescribes the props accepted by a Context {@link Provider}.\n* @template T The type of the value the context provides.\n     \n    interface ProviderProps<T> {\n        value: T;\n        children?: ReactNode | undefined;\n    }\nDescribes the props accepted by a Context {@link Consumer}.\n* @template T The type of the value the context provides.\n     \n    interface ConsumerProps<T> {\n        children: (value: T) => ReactNode;\n    }\nAn object masquerading as a component. These are created by functions\nlike {@link forwardRef}, {@link memo}, and {@link createContext}.\n* In order to make TypeScript work, we pretend that they are normal\ncomponents.\n* But they are, in fact, not callable - instead, they are objects which\nare treated specially by the renderer.\n* @template P The props the component accepts.\n     \n    interface ExoticComponent<P = {}> {\n        (props: P): ReactNode;\n        readonly $$typeof: symbol;\n    }\nAn {@link ExoticComponent} with a `displayName` property applied to it.\n* @template P The props the component accepts.\n     \n    interface NamedExoticComponent<P = {}> extends ExoticComponent<P> {\nUsed in debugging messages. You might want to set it\nexplicitly if you want to display a different name for\ndebugging purposes.\n* @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs}\n         \n        displayName?: string | undefined;\n    }\nAn {@link ExoticComponent} with a `propTypes` property applied to it.\n* @template P The props the component accepts.\n     \n    interface ProviderExoticComponent<P> extends ExoticComponent<P> {\n    }\nUsed to retrieve the type of a context object from a {@link Context}.\n* @template C The context object.\n* @example\n* ```tsx\nimport { createContext } from 'react';\n* const MyContext = createContext({ foo: 'bar' });\n* type ContextType = ContextType<typeof MyContext>;\n// ContextType = { foo: string }\n```\n     \n    type ContextType<C extends Context<any>> = C extends Context<infer T> ? T : never;\nWraps your components to specify the value of this context for all components inside.\n* @see {@link https://react.dev/reference/react/createContext#provider React Docs}\n* @example\n* ```tsx\nimport { createContext } from 'react';\n* const ThemeContext = createContext('light');\n* function App() {\nreturn (\n<ThemeContext.Provider value=\"dark\">\n<Toolbar />\n</ThemeContext.Provider>\n);\n}\n```\n     \n    type Provider<T> = ProviderExoticComponent<ProviderProps<T>>;\nThe old way to read context, before {@link useContext} existed.\n* @see {@link https://react.dev/reference/react/createContext#consumer React Docs}\n* @example\n* ```tsx\nimport { UserContext } from './user-context';\n* function Avatar() {\nreturn (\n<UserContext.Consumer>\n{user => <img src={user.profileImage} alt={user.name} />}\n</UserContext.Consumer>\n);\n}\n```\n     \n    type Consumer<T> = ExoticComponent<ConsumerProps<T>>;\nContext lets components pass information deep down without explicitly\npassing props.\n* Created from {@link createContext}\n* @see {@link https://react.dev/learn/passing-data-deeply-with-context React Docs}\n@see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/context/ React TypeScript Cheatsheet}\n* @example\n* ```tsx\nimport { createContext } from 'react';\n* const ThemeContext = createContext('light');\n```\n     \n    interface Context<T> extends Provider<T> {\n        Provider: Provider<T>;\n        Consumer: Consumer<T>;\nUsed in debugging messages. You might want to set it\nexplicitly if you want to display a different name for\ndebugging purposes.\n* @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs}\n         \n        displayName?: string | undefined;\n    }\nLets you create a {@link Context} that components can provide or read.\n* @param defaultValue The value you want the context to have when there is no matching\n{@link Provider} in the tree above the component reading the context. This is meant\nas a \"last resort\" fallback.\n* @see {@link https://react.dev/reference/react/createContext#reference React Docs}\n@see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/context/ React TypeScript Cheatsheet}\n* @example\n* ```tsx\nimport { createContext } from 'react';\n* const ThemeContext = createContext('light');\nfunction App() {\nreturn (\n<ThemeContext value=\"dark\">\n<Toolbar />\n</ThemeContext>\n);\n}\n```\n     \n    function createContext<T>(\n        // If you thought this should be optional, see\n        // https://github.com/DefinitelyTyped/DefinitelyTyped/pull/24509#issuecomment-382213106\n        defaultValue: T,\n    ): Context<T>;\n\n    function isValidElement<P>(object: {} | null | undefined): object is ReactElement<P>;\n\n    const Children: {\n        map<T, C>(\n            children: C | readonly C[],\n            fn: (child: C, index: number) => T,\n        ): C extends null | undefined ? C : Array<Exclude<T, boolean | null | undefined>>;\n        forEach<C>(children: C | readonly C[], fn: (child: C, index: number) => void): void;\n        count(children: any): number;\n        only<C>(children: C): C extends any[] ? never : C;\n        toArray(children: ReactNode | ReactNode[]): Array<Exclude<ReactNode, boolean | null | undefined>>;\n    };\n\n    export interface FragmentProps {\n        children?: React.ReactNode;\n    }\nLets you group elements without a wrapper node.\n* @see {@link https://react.dev/reference/react/Fragment React Docs}\n* @example\n* ```tsx\nimport { Fragment } from 'react';\n* <Fragment>\n<td>Hello</td>\n<td>World</td>\n</Fragment>\n```\n* @example\n* ```tsx\n// Using the <></> shorthand syntax:\n* <>\n<td>Hello</td>\n<td>World</td>\n</>\n```\n     \n    const Fragment: ExoticComponent<FragmentProps>;\nLets you find common bugs in your components early during development.\n* @see {@link https://react.dev/reference/react/StrictMode React Docs}\n* @example\n* ```tsx\nimport { StrictMode } from 'react';\n* <StrictMode>\n<App />\n</StrictMode>\n```\n     \n    const StrictMode: ExoticComponent<{ children?: ReactNode | undefined }>;\nThe props accepted by {@link Suspense}.\n* @see {@link https://react.dev/reference/react/Suspense React Docs}\n     \n    interface SuspenseProps {\n        children?: ReactNode | undefined;\n\n         A fallback react tree to show when a Suspense child (like React.lazy) suspends \n        fallback?: ReactNode;\nA name for this Suspense boundary for instrumentation purposes.\nThe name will help identify this boundary in React DevTools.\n         \n        name?: string | undefined;\n    }\nLets you display a fallback until its children have finished loading.\n* @see {@link https://react.dev/reference/react/Suspense React Docs}\n* @example\n* ```tsx\nimport { Suspense } from 'react';\n* <Suspense fallback={<Loading />}>\n<ProfileDetails />\n</Suspense>\n```\n     \n    const Suspense: ExoticComponent<SuspenseProps>;\n    const version: string;\nThe callback passed to {@link ProfilerProps.onRender}.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n     \n    type ProfilerOnRenderCallback = (\nThe string id prop of the {@link Profiler} tree that has just committed. This lets\nyou identify which part of the tree was committed if you are using multiple\nprofilers.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n         \n        id: string,\nThis lets you know whether the tree has just been mounted for the first time\nor re-rendered due to a change in props, state, or hooks.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n         \n        phase: \"mount\" | \"update\" | \"nested-update\",\nThe number of milliseconds spent rendering the {@link Profiler} and its descendants\nfor the current update. This indicates how well the subtree makes use of\nmemoization (e.g. {@link memo} and {@link useMemo}). Ideally this value should decrease\nsignificantly after the initial mount as many of the descendants will only need to\nre-render if their specific props change.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n         \n        actualDuration: number,\nThe number of milliseconds estimating how much time it would take to re-render the entire\n{@link Profiler} subtree without any optimizations. It is calculated by summing up the most\nrecent render durations of each component in the tree. This value estimates a worst-case\ncost of rendering (e.g. the initial mount or a tree with no memoization). Compare\n{@link actualDuration} against it to see if memoization is working.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n         \n        baseDuration: number,\nA numeric timestamp for when React began rendering the current update.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n         \n        startTime: number,\nA numeric timestamp for when React committed the current update. This value is shared\nbetween all profilers in a commit, enabling them to be grouped if desirable.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n         \n        commitTime: number,\n    ) => void;\nThe props accepted by {@link Profiler}.\n* @see {@link https://react.dev/reference/react/Profiler React Docs}\n     \n    interface ProfilerProps {\n        children?: ReactNode | undefined;\n        id: string;\n        onRender: ProfilerOnRenderCallback;\n    }\nLets you measure rendering performance of a React tree programmatically.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n* @example\n* ```tsx\n<Profiler id=\"App\" onRender={onRender}>\n<App />\n</Profiler>\n```\n     \n    const Profiler: ExoticComponent<ProfilerProps>;\n\n    //\n    // Component API\n    // ----------------------------------------------------------------------\n\n    type ReactInstance = Component<any> | Element;\n\n    // Base component for plain JS classes\n    interface Component<P = {}, S = {}, SS = any> extends ComponentLifecycle<P, S, SS> {}\n    class Component<P, S> {\nIf set, `this.context` will be set at runtime to the current value of the given Context.\n* @example\n* ```ts\ntype MyContext = number\nconst Ctx = React.createContext<MyContext>(0)\n* class Foo extends React.Component {\nstatic contextType = Ctx\ncontext!: React.ContextType<typeof Ctx>\nrender () {\nreturn <>My context's value: {this.context}</>;\n}\n}\n```\n* @see {@link https://react.dev/reference/react/Component#static-contexttype}\n         \n        static contextType?: Context<any> | undefined;\nIgnored by React.\n@deprecated Only kept in types for backwards compatibility. Will be removed in a future major release.\n         \n        static propTypes?: any;\nIf using the new style context, re-declare this in your class to be the\n`React.ContextType` of your `static contextType`.\nShould be used with type annotation or static contextType.\n* @example\n```ts\nstatic contextType = MyContext\n// For TS pre-3.7:\ncontext!: React.ContextType<typeof MyContext>\n// For TS 3.7 and above:\ndeclare context: React.ContextType<typeof MyContext>\n```\n* @see {@link https://react.dev/reference/react/Component#context React Docs}\n         \n        context: unknown;\n\n        // Keep in sync with constructor signature of JSXElementConstructor and ComponentClass.\n        constructor(props: P);\n\n        // We MUST keep setState() as a unified signature because it allows proper checking of the method return type.\n        // See: https://github.com/DefinitelyTyped/DefinitelyTyped/issues/18365#issuecomment-351013257\n        // Also, the ` | S` allows intellisense to not be dumbisense\n        setState<K extends keyof S>(\n            state: ((prevState: Readonly<S>, props: Readonly<P>) => Pick<S, K> | S | null) | (Pick<S, K> | S | null),\n            callback?: () => void,\n        ): void;\n\n        forceUpdate(callback?: () => void): void;\n        render(): ReactNode;\n\n        readonly props: Readonly<P>;\n        state: Readonly<S>;\n    }\n\n    class PureComponent<P = {}, S = {}, SS = any> extends Component<P, S, SS> {}\n@deprecated Use `ClassicComponent` from `create-react-class`\n* @see {@link https://legacy.reactjs.org/docs/react-without-es6.html Legacy React Docs}\n@see {@link https://www.npmjs.com/package/create-react-class `create-react-class` on npm}\n     \n    interface ClassicComponent<P = {}, S = {}> extends Component<P, S> {\n        replaceState(nextState: S, callback?: () => void): void;\n        isMounted(): boolean;\n        getInitialState?(): S;\n    }\n\n    //\n    // Class Interfaces\n    // ----------------------------------------------------------------------\nRepresents the type of a function component. Can optionally\nreceive a type argument that represents the props the component\nreceives.\n* @template P The props the component accepts.\n@see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/function_components React TypeScript Cheatsheet}\n@alias for {@link FunctionComponent}\n* @example\n* ```tsx\n// With props:\ntype Props = { name: string }\n* const MyComponent: FC<Props> = (props) => {\nreturn <div>{props.name}</div>\n}\n```\n* @example\n* ```tsx\n// Without props:\nconst MyComponentWithoutProps: FC = () => {\nreturn <div>MyComponentWithoutProps</div>\n}\n```\n     \n    type FC<P = {}> = FunctionComponent<P>;\nRepresents the type of a function component. Can optionally\nreceive a type argument that represents the props the component\naccepts.\n* @template P The props the component accepts.\n@see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/function_components React TypeScript Cheatsheet}\n* @example\n* ```tsx\n// With props:\ntype Props = { name: string }\n* const MyComponent: FunctionComponent<Props> = (props) => {\nreturn <div>{props.name}</div>\n}\n```\n* @example\n* ```tsx\n// Without props:\nconst MyComponentWithoutProps: FunctionComponent = () => {\nreturn <div>MyComponentWithoutProps</div>\n}\n```\n     \n    interface FunctionComponent<P = {}> {\n        (props: P): ReactNode | Promise<ReactNode>;\nIgnored by React.\n@deprecated Only kept in types for backwards compatibility. Will be removed in a future major release.\n         \n        propTypes?: any;\nUsed in debugging messages. You might want to set it\nexplicitly if you want to display a different name for\ndebugging purposes.\n* @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs}\n* @example\n* ```tsx\n* const MyComponent: FC = () => {\nreturn <div>Hello!</div>\n}\n* MyComponent.displayName = 'MyAwesomeComponent'\n```\n         \n        displayName?: string | undefined;\n    }\nThe type of the ref received by a {@link ForwardRefRenderFunction}.\n* @see {@link ForwardRefRenderFunction}\n     \n    // Making T nullable is assuming the refs will be managed by React or the component impl will write it somewhere else.\n    // But this isn't necessarily true. We haven't heard complains about it yet and hopefully `forwardRef` is removed from React before we do.\n    type ForwardedRef<T> = ((instance: T | null) => void) | RefObject<T | null> | null;\nThe type of the function passed to {@link forwardRef}. This is considered different\nto a normal {@link FunctionComponent} because it receives an additional argument,\n* @param props Props passed to the component, if any.\n@param ref A ref forwarded to the component of type {@link ForwardedRef}.\n* @template T The type of the forwarded ref.\n@template P The type of the props the component accepts.\n* @see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/forward_and_create_ref/ React TypeScript Cheatsheet}\n@see {@link forwardRef}\n     \n    interface ForwardRefRenderFunction<T, P = {}> {\n        (props: P, ref: ForwardedRef<T>): ReactNode;\nUsed in debugging messages. You might want to set it\nexplicitly if you want to display a different name for\ndebugging purposes.\n* Will show `ForwardRef(${Component.displayName || Component.name})`\nin devtools by default, but can be given its own specific name.\n* @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs}\n         \n        displayName?: string | undefined;\nIgnored by React.\n@deprecated Only kept in types for backwards compatibility. Will be removed in a future major release.\n         \n        propTypes?: any;\n    }\nRepresents a component class in React.\n* @template P The props the component accepts.\n@template S The internal state of the component.\n     \n    interface ComponentClass<P = {}, S = ComponentState> extends StaticLifecycle<P, S> {\n        // constructor signature must match React.Component\n        new(props: P): Component<P, S>;\nIgnored by React.\n@deprecated Only kept in types for backwards compatibility. Will be removed in a future major release.\n         \n        propTypes?: any;\n        contextType?: Context<any> | undefined;\n        defaultProps?: Partial<P> | undefined;\nUsed in debugging messages. You might want to set it\nexplicitly if you want to display a different name for\ndebugging purposes.\n* @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs}\n         \n        displayName?: string | undefined;\n    }\n@deprecated Use `ClassicComponentClass` from `create-react-class`\n* @see {@link https://legacy.reactjs.org/docs/react-without-es6.html Legacy React Docs}\n@see {@link https://www.npmjs.com/package/create-react-class `create-react-class` on npm}\n     \n    interface ClassicComponentClass<P = {}> extends ComponentClass<P> {\n        new(props: P): ClassicComponent<P, ComponentState>;\n        getDefaultProps?(): P;\n    }\nUsed in {@link createElement} and {@link createFactory} to represent\na class.\n* An intersection type is used to infer multiple type parameters from\na single argument, which is useful for many top-level API defs.\nSee {@link https://github.com/Microsoft/TypeScript/issues/7234 this GitHub issue}\nfor more info.\n     \n    type ClassType<P, T extends Component<P, ComponentState>, C extends ComponentClass<P>> =\n        & C\n        & (new(props: P) => T);\n\n    //\n    // Component Specs and Lifecycle\n    // ----------------------------------------------------------------------\n\n    // This should actually be something like `Lifecycle<P, S> | DeprecatedLifecycle<P, S>`,\n    // as React will _not_ call the deprecated lifecycle methods if any of the new lifecycle\n    // methods are present.\n    interface ComponentLifecycle<P, S, SS = any> extends NewLifecycle<P, S, SS>, DeprecatedLifecycle<P, S> {\nCalled immediately after a component is mounted. Setting state here will trigger re-rendering.\n         \n        componentDidMount?(): void;\nCalled to determine whether the change in props and state should trigger a re-render.\n* `Component` always returns true.\n`PureComponent` implements a shallow comparison on props and state and returns true if any\nprops or states have changed.\n* If false is returned, {@link Component.render}, `componentWillUpdate`\nand `componentDidUpdate` will not be called.\n         \n        shouldComponentUpdate?(nextProps: Readonly<P>, nextState: Readonly<S>, nextContext: any): boolean;\nCalled immediately before a component is destroyed. Perform any necessary cleanup in this method, such as\ncancelled network requests, or cleaning up any DOM elements created in `componentDidMount`.\n         \n        componentWillUnmount?(): void;\nCatches exceptions generated in descendant components. Unhandled exceptions will cause\nthe entire component tree to unmount.\n         \n        componentDidCatch?(error: Error, errorInfo: ErrorInfo): void;\n    }\n\n    // Unfortunately, we have no way of declaring that the component constructor must implement this\n    interface StaticLifecycle<P, S> {\n        getDerivedStateFromProps?: GetDerivedStateFromProps<P, S> | undefined;\n        getDerivedStateFromError?: GetDerivedStateFromError<P, S> | undefined;\n    }\n\n    type GetDerivedStateFromProps<P, S> =\nReturns an update to a component's state based on its new props and old state.\n* Note: its presence prevents any of the deprecated lifecycle methods from being invoked\n         \n        (nextProps: Readonly<P>, prevState: S) => Partial<S> | null;\n\n    type GetDerivedStateFromError<P, S> =\nThis lifecycle is invoked after an error has been thrown by a descendant component.\nIt receives the error that was thrown as a parameter and should return a value to update state.\n* Note: its presence prevents any of the deprecated lifecycle methods from being invoked\n         \n        (error: any) => Partial<S> | null;\n\n    // This should be \"infer SS\" but can't use it yet\n    interface NewLifecycle<P, S, SS> {\nRuns before React applies the result of {@link Component.render render} to the document, and\nreturns an object to be given to {@link componentDidUpdate}. Useful for saving\nthings such as scroll position before {@link Component.render render} causes changes to it.\n* Note: the presence of this method prevents any of the deprecated\nlifecycle events from running.\n         \n        getSnapshotBeforeUpdate?(prevProps: Readonly<P>, prevState: Readonly<S>): SS | null;\nCalled immediately after updating occurs. Not called for the initial render.\n* The snapshot is only present if {@link getSnapshotBeforeUpdate} is present and returns non-null.\n         \n        componentDidUpdate?(prevProps: Readonly<P>, prevState: Readonly<S>, snapshot?: SS): void;\n    }\n\n    interface DeprecatedLifecycle<P, S> {\nCalled immediately before mounting occurs, and before {@link Component.render}.\nAvoid introducing any side-effects or subscriptions in this method.\n* Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate}\nor {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents\nthis from being invoked.\n* @deprecated 16.3, use {@link ComponentLifecycle.componentDidMount componentDidMount} or the constructor instead; will stop working in React 17\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#initializing-state}\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path}\n         \n        componentWillMount?(): void;\nCalled immediately before mounting occurs, and before {@link Component.render}.\nAvoid introducing any side-effects or subscriptions in this method.\n* This method will not stop working in React 17.\n* Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate}\nor {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents\nthis from being invoked.\n* @deprecated 16.3, use {@link ComponentLifecycle.componentDidMount componentDidMount} or the constructor instead\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#initializing-state}\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path}\n         \n        UNSAFE_componentWillMount?(): void;\nCalled when the component may be receiving new props.\nReact may call this even if props have not changed, so be sure to compare new and existing\nprops if you only want to handle changes.\n* Calling {@link Component.setState} generally does not trigger this method.\n* Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate}\nor {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents\nthis from being invoked.\n* @deprecated 16.3, use static {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} instead; will stop working in React 17\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#updating-state-based-on-props}\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path}\n         \n        componentWillReceiveProps?(nextProps: Readonly<P>, nextContext: any): void;\nCalled when the component may be receiving new props.\nReact may call this even if props have not changed, so be sure to compare new and existing\nprops if you only want to handle changes.\n* Calling {@link Component.setState} generally does not trigger this method.\n* This method will not stop working in React 17.\n* Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate}\nor {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents\nthis from being invoked.\n* @deprecated 16.3, use static {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} instead\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#updating-state-based-on-props}\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path}\n         \n        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<P>, nextContext: any): void;\nCalled immediately before rendering when new props or state is received. Not called for the initial render.\n* Note: You cannot call {@link Component.setState} here.\n* Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate}\nor {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents\nthis from being invoked.\n* @deprecated 16.3, use getSnapshotBeforeUpdate instead; will stop working in React 17\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#reading-dom-properties-before-an-update}\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path}\n         \n        componentWillUpdate?(nextProps: Readonly<P>, nextState: Readonly<S>, nextContext: any): void;\nCalled immediately before rendering when new props or state is received. Not called for the initial render.\n* Note: You cannot call {@link Component.setState} here.\n* This method will not stop working in React 17.\n* Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate}\nor {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents\nthis from being invoked.\n* @deprecated 16.3, use getSnapshotBeforeUpdate instead\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#reading-dom-properties-before-an-update}\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path}\n         \n        UNSAFE_componentWillUpdate?(nextProps: Readonly<P>, nextState: Readonly<S>, nextContext: any): void;\n    }\n\n    function createRef<T>(): RefObject<T | null>;\nThe type of the component returned from {@link forwardRef}.\n* @template P The props the component accepts, if any.\n* @see {@link ExoticComponent}\n     \n    interface ForwardRefExoticComponent<P> extends NamedExoticComponent<P> {\nIgnored by React.\n@deprecated Only kept in types for backwards compatibility. Will be removed in a future major release.\n         \n        propTypes?: any;\n    }\nLets your component expose a DOM node to a parent component\nusing a ref.\n* @see {@link https://react.dev/reference/react/forwardRef React Docs}\n@see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/forward_and_create_ref/ React TypeScript Cheatsheet}\n* @param render See the {@link ForwardRefRenderFunction}.\n* @template T The type of the DOM node.\n@template P The props the component accepts, if any.\n* @example\n* ```tsx\ninterface Props {\nchildren?: ReactNode;\ntype: \"submit\" | \"button\";\n}\n* export const FancyButton = forwardRef<HTMLButtonElement, Props>((props, ref) => (\n<button ref={ref} className=\"MyClassName\" type={props.type}>\n{props.children}\n</button>\n));\n```\n     \n    function forwardRef<T, P = {}>(\n        render: ForwardRefRenderFunction<T, PropsWithoutRef<P>>,\n    ): ForwardRefExoticComponent<PropsWithoutRef<P> & RefAttributes<T>>;\nOmits the 'ref' attribute from the given props object.\n* @template Props The props object type.\n     \n    type PropsWithoutRef<Props> =\n        // Omit would not be sufficient for this. We'd like to avoid unnecessary mapping and need a distributive conditional to support unions.\n        // see: https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types\n        // https://github.com/Microsoft/TypeScript/issues/28339\n        Props extends any ? (\"ref\" extends keyof Props ? Omit<Props, \"ref\"> : Props) : Props;\nEnsures that the props do not include string ref, which cannot be forwarded\n@deprecated Use `Props` directly. `PropsWithRef<Props>` is just an alias for `Props`\n     \n    type PropsWithRef<Props> = Props;\n\n    type PropsWithChildren<P = unknown> = P & { children?: ReactNode | undefined };\nUsed to retrieve the props a component accepts. Can either be passed a string,\nindicating a DOM element (e.g. 'div', 'span', etc.) or the type of a React\ncomponent.\n* It's usually better to use {@link ComponentPropsWithRef} or {@link ComponentPropsWithoutRef}\ninstead of this type, as they let you be explicit about whether or not to include\nthe `ref` prop.\n* @see {@link https://react-typescript-cheatsheet.netlify.app/docs/react-types/componentprops/ React TypeScript Cheatsheet}\n* @example\n* ```tsx\n// Retrieves the props an 'input' element accepts\ntype InputProps = React.ComponentProps<'input'>;\n```\n* @example\n* ```tsx\nconst MyComponent = (props: { foo: number, bar: string }) => <div />;\n* // Retrieves the props 'MyComponent' accepts\ntype MyComponentProps = React.ComponentProps<typeof MyComponent>;\n```\n     \n    type ComponentProps<T extends keyof JSX.IntrinsicElements | JSXElementConstructor<any>> = T extends\n        JSXElementConstructor<infer Props> ? Props\n        : T extends keyof JSX.IntrinsicElements ? JSX.IntrinsicElements[T]\n        : {};\nUsed to retrieve the props a component accepts with its ref. Can either be\npassed a string, indicating a DOM element (e.g. 'div', 'span', etc.) or the\ntype of a React component.\n* @see {@link https://react-typescript-cheatsheet.netlify.app/docs/react-types/componentprops/ React TypeScript Cheatsheet}\n* @example\n* ```tsx\n// Retrieves the props an 'input' element accepts\ntype InputProps = React.ComponentPropsWithRef<'input'>;\n```\n* @example\n* ```tsx\nconst MyComponent = (props: { foo: number, bar: string }) => <div />;\n* // Retrieves the props 'MyComponent' accepts\ntype MyComponentPropsWithRef = React.ComponentPropsWithRef<typeof MyComponent>;\n```\n     \n    type ComponentPropsWithRef<T extends ElementType> = T extends JSXElementConstructor<infer Props>\n        // If it's a class i.e. newable we're dealing with a class component\n        ? T extends abstract new(args: any) => any ? PropsWithoutRef<Props> & RefAttributes<InstanceType<T>>\n        : Props\n        : ComponentProps<T>;\nUsed to retrieve the props a custom component accepts with its ref.\n* Unlike {@link ComponentPropsWithRef}, this only works with custom\ncomponents, i.e. components you define yourself. This is to improve\ntype-checking performance.\n* @example\n* ```tsx\nconst MyComponent = (props: { foo: number, bar: string }) => <div />;\n* // Retrieves the props 'MyComponent' accepts\ntype MyComponentPropsWithRef = React.CustomComponentPropsWithRef<typeof MyComponent>;\n```\n     \n    type CustomComponentPropsWithRef<T extends ComponentType> = T extends JSXElementConstructor<infer Props>\n        // If it's a class i.e. newable we're dealing with a class component\n        ? T extends abstract new(args: any) => any ? PropsWithoutRef<Props> & RefAttributes<InstanceType<T>>\n        : Props\n        : never;\nUsed to retrieve the props a component accepts without its ref. Can either be\npassed a string, indicating a DOM element (e.g. 'div', 'span', etc.) or the\ntype of a React component.\n* @see {@link https://react-typescript-cheatsheet.netlify.app/docs/react-types/componentprops/ React TypeScript Cheatsheet}\n* @example\n* ```tsx\n// Retrieves the props an 'input' element accepts\ntype InputProps = React.ComponentPropsWithoutRef<'input'>;\n```\n* @example\n* ```tsx\nconst MyComponent = (props: { foo: number, bar: string }) => <div />;\n* // Retrieves the props 'MyComponent' accepts\ntype MyComponentPropsWithoutRef = React.ComponentPropsWithoutRef<typeof MyComponent>;\n```\n     \n    type ComponentPropsWithoutRef<T extends ElementType> = PropsWithoutRef<ComponentProps<T>>;\nRetrieves the type of the 'ref' prop for a given component type or tag name.\n* @template C The component type.\n* @example\n* ```tsx\ntype MyComponentRef = React.ComponentRef<typeof MyComponent>;\n```\n* @example\n* ```tsx\ntype DivRef = React.ComponentRef<'div'>;\n```\n     \n    type ComponentRef<T extends ElementType> = ComponentPropsWithRef<T> extends RefAttributes<infer Method> ? Method\n        : never;\n\n    // will show `Memo(${Component.displayName || Component.name})` in devtools by default,\n    // but can be given its own specific name\n    type MemoExoticComponent<T extends ComponentType<any>> = NamedExoticComponent<CustomComponentPropsWithRef<T>> & {\n        readonly type: T;\n    };\nLets you skip re-rendering a component when its props are unchanged.\n* @see {@link https://react.dev/reference/react/memo React Docs}\n* @param Component The component to memoize.\n@param propsAreEqual A function that will be used to determine if the props have changed.\n* @example\n* ```tsx\nimport { memo } from 'react';\n* const SomeComponent = memo(function SomeComponent(props: { foo: string }) {\n// ...\n});\n```\n     \n    function memo<P extends object>(\n        Component: FunctionComponent<P>,\n        propsAreEqual?: (prevProps: Readonly<P>, nextProps: Readonly<P>) => boolean,\n    ): NamedExoticComponent<P>;\n    function memo<T extends ComponentType<any>>(\n        Component: T,\n        propsAreEqual?: (prevProps: Readonly<ComponentProps<T>>, nextProps: Readonly<ComponentProps<T>>) => boolean,\n    ): MemoExoticComponent<T>;\n\n    interface LazyExoticComponent<T extends ComponentType<any>>\n        extends ExoticComponent<CustomComponentPropsWithRef<T>>\n    {\n        readonly _result: T;\n    }\nLets you defer loading a component’s code until it is rendered for the first time.\n* @see {@link https://react.dev/reference/react/lazy React Docs}\n* @param load A function that returns a `Promise` or another thenable (a `Promise`-like object with a\nthen method). React will not call `load` until the first time you attempt to render the returned\ncomponent. After React first calls load, it will wait for it to resolve, and then render the\nresolved value’s `.default` as a React component. Both the returned `Promise` and the `Promise`’s\nresolved value will be cached, so React will not call load more than once. If the `Promise` rejects,\nReact will throw the rejection reason for the nearest Error Boundary to handle.\n* @example\n* ```tsx\nimport { lazy } from 'react';\n* const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));\n```\n     \n    function lazy<T extends ComponentType<any>>(\n        load: () => Promise<{ default: T }>,\n    ): LazyExoticComponent<T>;\n\n    //\n    // React Hooks\n    // ----------------------------------------------------------------------\nThe instruction passed to a {@link Dispatch} function in {@link useState}\nto tell React what the next value of the {@link useState} should be.\n* Often found wrapped in {@link Dispatch}.\n* @template S The type of the state.\n* @example\n* ```tsx\n// This return type correctly represents the type of\n// `setCount` in the example below.\nconst useCustomState = (): Dispatch<SetStateAction<number>> => {\nconst [count, setCount] = useState(0);\n*   return setCount;\n}\n```\n     \n    type SetStateAction<S> = S | ((prevState: S) => S);\nA function that can be used to update the state of a {@link useState}\nor {@link useReducer} hook.\n     \n    type Dispatch<A> = (value: A) => void;\nA {@link Dispatch} function can sometimes be called without any arguments.\n     \n    type DispatchWithoutAction = () => void;\n    // Limit the reducer to accept only 0 or 1 action arguments\n    // eslint-disable-next-line @definitelytyped/no-single-element-tuple-type\n    type AnyActionArg = [] | [any];\n    // Get the dispatch type from the reducer arguments (captures optional action argument correctly)\n    type ActionDispatch<ActionArg extends AnyActionArg> = (...args: ActionArg) => void;\n    // Unlike redux, the actions _can_ be anything\n    type Reducer<S, A> = (prevState: S, action: A) => S;\n    // If useReducer accepts a reducer without action, dispatch may be called without any parameters.\n    type ReducerWithoutAction<S> = (prevState: S) => S;\n    // types used to try and prevent the compiler from reducing S\n    // to a supertype common with the second argument to useReducer()\n    type ReducerState<R extends Reducer<any, any>> = R extends Reducer<infer S, any> ? S : never;\n    type DependencyList = readonly unknown[];\n\n    // NOTE: callbacks are _only_ allowed to return either void, or a destructor.\n    type EffectCallback = () => void | Destructor;\n@deprecated Use `RefObject` instead.\n     \n    interface MutableRefObject<T> {\n        current: T;\n    }\n\n    // This will technically work if you give a Consumer<T> or Provider<T> but it's deprecated and warns\nAccepts a context object (the value returned from `React.createContext`) and returns the current\ncontext value, as given by the nearest context provider for the given context.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useContext}\n     \n    function useContext<T>(context: Context<T> /*, (not public API) observedBits?: number|boolean ): T;\nReturns a stateful value, and a function to update it.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useState}\n     \n    function useState<S>(initialState: S | (() => S)): [S, Dispatch<SetStateAction<S>>];\n    // convenience overload when first argument is omitted\nReturns a stateful value, and a function to update it.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useState}\n     \n    function useState<S = undefined>(): [S | undefined, Dispatch<SetStateAction<S | undefined>>];\nAn alternative to `useState`.\n* `useReducer` is usually preferable to `useState` when you have complex state logic that involves\nmultiple sub-values. It also lets you optimize performance for components that trigger deep\nupdates because you can pass `dispatch` down instead of callbacks.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useReducer}\n     \n    function useReducer<S, A extends AnyActionArg>(\n        reducer: (prevState: S, ...args: A) => S,\n        initialState: S,\n    ): [S, ActionDispatch<A>];\nAn alternative to `useState`.\n* `useReducer` is usually preferable to `useState` when you have complex state logic that involves\nmultiple sub-values. It also lets you optimize performance for components that trigger deep\nupdates because you can pass `dispatch` down instead of callbacks.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useReducer}\n     \n    function useReducer<S, A extends AnyActionArg>(\n        reducer: (prevState: S, ...args: A) => S,\n        initialState: S,\n    ): [S, ActionDispatch<A>];\nAn alternative to `useState`.\n* `useReducer` is usually preferable to `useState` when you have complex state logic that involves\nmultiple sub-values. It also lets you optimize performance for components that trigger deep\nupdates because you can pass `dispatch` down instead of callbacks.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useReducer}\n     \n    function useReducer<S, I, A extends AnyActionArg>(\n        reducer: (prevState: S, ...args: A) => S,\n        initialArg: I,\n        init: (i: I) => S,\n    ): [S, ActionDispatch<A>];\n`useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument\n(`initialValue`). The returned object will persist for the full lifetime of the component.\n* Note that `useRef()` is useful for more than the `ref` attribute. It’s handy for keeping any mutable\nvalue around similar to how you’d use instance fields in classes.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useRef}\n     \n    function useRef<T>(initialValue: T): RefObject<T>;\n    // convenience overload for refs given as a ref prop as they typically start with a null value\n`useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument\n(`initialValue`). The returned object will persist for the full lifetime of the component.\n* Note that `useRef()` is useful for more than the `ref` attribute. It’s handy for keeping any mutable\nvalue around similar to how you’d use instance fields in classes.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useRef}\n     \n    function useRef<T>(initialValue: T | null): RefObject<T | null>;\n    // convenience overload for undefined initialValue\n`useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument\n(`initialValue`). The returned object will persist for the full lifetime of the component.\n* Note that `useRef()` is useful for more than the `ref` attribute. It’s handy for keeping any mutable\nvalue around similar to how you’d use instance fields in classes.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useRef}\n     \n    function useRef<T>(initialValue: T | undefined): RefObject<T | undefined>;\nThe signature is identical to `useEffect`, but it fires synchronously after all DOM mutations.\nUse this to read layout from the DOM and synchronously re-render. Updates scheduled inside\n`useLayoutEffect` will be flushed synchronously, before the browser has a chance to paint.\n* Prefer the standard `useEffect` when possible to avoid blocking visual updates.\n* If you’re migrating code from a class component, `useLayoutEffect` fires in the same phase as\n`componentDidMount` and `componentDidUpdate`.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useLayoutEffect}\n     \n    function useLayoutEffect(effect: EffectCallback, deps?: DependencyList): void;\nAccepts a function that contains imperative, possibly effectful code.\n* @param effect Imperative function that can return a cleanup function\n@param deps If present, effect will only activate if the values in the list change.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useEffect}\n     \n    function useEffect(effect: EffectCallback, deps?: DependencyList): void;\n    // NOTE: this does not accept strings, but this will have to be fixed by removing strings from type Ref<T>\n`useImperativeHandle` customizes the instance value that is exposed to parent components when using\n`ref`. As always, imperative code using refs should be avoided in most cases.\n* `useImperativeHandle` should be used with `React.forwardRef`.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useImperativeHandle}\n     \n    function useImperativeHandle<T, R extends T>(ref: Ref<T> | undefined, init: () => R, deps?: DependencyList): void;\n    // I made 'inputs' required here and in useMemo as there's no point to memoizing without the memoization key\n    // useCallback(X) is identical to just using X, useMemo(() => Y) is identical to just using Y.\n`useCallback` will return a memoized version of the callback that only changes if one of the `inputs`\nhas changed.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useCallback}\n     \n    // A specific function type would not trigger implicit any.\n    // See https://github.com/DefinitelyTyped/DefinitelyTyped/issues/52873#issuecomment-845806435 for a comparison between `Function` and more specific types.\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n    function useCallback<T extends Function>(callback: T, deps: DependencyList): T;\n`useMemo` will only recompute the memoized value when one of the `deps` has changed.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useMemo}\n     \n    // allow undefined, but don't make it optional as that is very likely a mistake\n    function useMemo<T>(factory: () => T, deps: DependencyList): T;\n`useDebugValue` can be used to display a label for custom hooks in React DevTools.\n* NOTE: We don’t recommend adding debug values to every custom hook.\nIt’s most valuable for custom hooks that are part of shared libraries.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useDebugValue}\n     \n    // the name of the custom hook is itself derived from the function name at runtime:\n    // it's just the function name without the \"use\" prefix.\n    function useDebugValue<T>(value: T, format?: (value: T) => any): void;\n\n    export type TransitionFunction = () => VoidOrUndefinedOnly | Promise<VoidOrUndefinedOnly>;\n    // strange definition to allow vscode to show documentation on the invocation\n    export interface TransitionStartFunction {\nState updates caused inside the callback are allowed to be deferred.\n* **If some state update causes a component to suspend, that state update should be wrapped in a transition.**\n* @param callback A function which causes state updates that can be deferred.\n         \n        (callback: TransitionFunction): void;\n    }\nReturns a deferred version of the value that may “lag behind” it.\n* This is commonly used to keep the interface responsive when you have something that renders immediately\nbased on user input and something that needs to wait for a data fetch.\n* A good example of this is a text input.\n* @param value The value that is going to be deferred\n@param initialValue A value to use during the initial render of a component. If this option is omitted, `useDeferredValue` will not defer during the initial render, because there’s no previous version of `value` that it can render instead.\n* @see {@link https://react.dev/reference/react/useDeferredValue}\n     \n    export function useDeferredValue<T>(value: T, initialValue?: T): T;\nAllows components to avoid undesirable loading states by waiting for content to load\nbefore transitioning to the next screen. It also allows components to defer slower,\ndata fetching updates until subsequent renders so that more crucial updates can be\nrendered immediately.\n* The `useTransition` hook returns two values in an array.\n* The first is a boolean, React’s way of informing us whether we’re waiting for the transition to finish.\nThe second is a function that takes a callback. We can use it to tell React which state we want to defer.\n* **If some state update causes a component to suspend, that state update should be wrapped in a transition.**\n* @see {@link https://react.dev/reference/react/useTransition}\n\nNew source code:\n\n```typescript\nfunction useTransition\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Used to represent DOM API's where users can either pass\ntrue or false as a boolean or as its equivalent strings.\n \ntype Booleanish = boolean | \"true\" | \"false\";\n@see {@link https://developer.mozilla.org/en-US/docs/Web/HTML/Attributes/crossorigin MDN}\n \ntype CrossOrigin = \"anonymous\" | \"use-credentials\" | \"\" | undefined;\n\ndeclare const UNDEFINED_VOID_ONLY: unique symbol;\n@internal Use `Awaited<ReactNode>` instead\n \n// Helper type to enable `Awaited<ReactNode>`.\n// Must be a copy of the non-thenables of `ReactNode`.\ntype AwaitedReactNode =\n    | React.ReactElement\n    | string\n    | number\n    | bigint\n    | Iterable<React.ReactNode>\n    | React.ReactPortal\n    | boolean\n    | null\n    | undefined\n    | React.DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES[\n        keyof React.DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES\n    ];\nThe function returned from an effect passed to {@link React.useEffect useEffect},\nwhich can be used to clean up the effect when the component unmounts.\n* @see {@link https://react.dev/reference/react/useEffect React Docs}\n \ntype Destructor = () => void | { [UNDEFINED_VOID_ONLY]: never };\ntype VoidOrUndefinedOnly = void | { [UNDEFINED_VOID_ONLY]: never };\n\n// eslint-disable-next-line @definitelytyped/export-just-namespace\nexport = React;\nexport as namespace React;\n\ndeclare namespace React {\n    //\n    // React Elements\n    // ----------------------------------------------------------------------\nUsed to retrieve the possible components which accept a given set of props.\n* Can be passed no type parameters to get a union of all possible components\nand tags.\n* Is a superset of {@link ComponentType}.\n* @template P The props to match against. If not passed, defaults to any.\n@template Tag An optional tag to match against. If not passed, attempts to match against all possible tags.\n* @example\n* ```tsx\n// All components and tags (img, embed etc.)\n// which accept `src`\ntype SrcComponents = ElementType<{ src: any }>;\n```\n* @example\n* ```tsx\n// All components\ntype AllComponents = ElementType;\n```\n* @example\n* ```tsx\n// All custom components which match `src`, and tags which\n// match `src`, narrowed down to just `audio` and `embed`\ntype SrcComponents = ElementType<{ src: any }, 'audio' | 'embed'>;\n```\n     \n    type ElementType<P = any, Tag extends keyof JSX.IntrinsicElements = keyof JSX.IntrinsicElements> =\n        | { [K in Tag]: P extends JSX.IntrinsicElements[K] ? K : never }[Tag]\n        | ComponentType<P>;\nRepresents any user-defined component, either as a function or a class.\n* Similar to {@link JSXElementConstructor}, but with extra properties like\n{@link FunctionComponent.defaultProps defaultProps }.\n* @template P The props the component accepts.\n* @see {@link ComponentClass}\n@see {@link FunctionComponent}\n     \n    type ComponentType<P = {}> = ComponentClass<P> | FunctionComponent<P>;\nRepresents any user-defined component, either as a function or a class.\n* Similar to {@link ComponentType}, but without extra properties like\n{@link FunctionComponent.defaultProps defaultProps }.\n* @template P The props the component accepts.\n     \n    type JSXElementConstructor<P> =\n        | ((\n            props: P,\n        ) => ReactNode | Promise<ReactNode>)\n        // constructor signature must match React.Component\n        | (new(props: P) => Component<any, any>);\nCreated by {@link createRef}, or {@link useRef} when passed `null`.\n* @template T The type of the ref's value.\n* @example\n* ```tsx\nconst ref = createRef<HTMLDivElement>();\n* ref.current = document.createElement('div'); // Error\n```\n     \n    interface RefObject<T> {\nThe current value of the ref.\n         \n        current: T;\n    }\n\n    interface DO_NOT_USE_OR_YOU_WILL_BE_FIRED_CALLBACK_REF_RETURN_VALUES {\n    }\nA callback fired whenever the ref's value changes.\n* @template T The type of the ref's value.\n* @see {@link https://react.dev/reference/react-dom/components/common#ref-callback React Docs}\n* @example\n* ```tsx\n<div ref={(node) => console.log(node)} />\n```\n     \n    type RefCallback<T> = {\n        bivarianceHack(\n            instance: T | null,\n        ):\n            | void\n            | (() => VoidOrUndefinedOnly)\n            | DO_NOT_USE_OR_YOU_WILL_BE_FIRED_CALLBACK_REF_RETURN_VALUES[\n                keyof DO_NOT_USE_OR_YOU_WILL_BE_FIRED_CALLBACK_REF_RETURN_VALUES\n            ];\n    }[\"bivarianceHack\"];\nA union type of all possible shapes for React refs.\n* @see {@link RefCallback}\n@see {@link RefObject}\n     \n\n    type Ref<T> = RefCallback<T> | RefObject<T | null> | null;\n@deprecated Use `Ref` instead. String refs are no longer supported.\nIf you're typing a library with support for React versions with string refs, use `RefAttributes<T>['ref']` instead.\n     \n    type LegacyRef<T> = Ref<T>;\n@deprecated Use `ComponentRef<T>` instead\n* Retrieves the type of the 'ref' prop for a given component type or tag name.\n* @template C The component type.\n* @example\n* ```tsx\ntype MyComponentRef = React.ElementRef<typeof MyComponent>;\n```\n* @example\n* ```tsx\ntype DivRef = React.ElementRef<'div'>;\n```\n     \n    type ElementRef<\n        C extends\n            | ForwardRefExoticComponent<any>\n            | { new(props: any): Component<any> }\n            | ((props: any) => ReactNode)\n            | keyof JSX.IntrinsicElements,\n    > = ComponentRef<C>;\n\n    type ComponentState = any;\nA value which uniquely identifies a node among items in an array.\n* @see {@link https://react.dev/learn/rendering-lists#keeping-list-items-in-order-with-key React Docs}\n     \n    type Key = string | number | bigint;\n@internal The props any component can receive.\nYou don't have to add this type. All components automatically accept these props.\n```tsx\nconst Component = () => <div />;\n<Component key=\"one\" />\n```\n* WARNING: The implementation of a component will never have access to these attributes.\nThe following example would be incorrect usage because {@link Component} would never have access to `key`:\n```tsx\nconst Component = (props: React.Attributes) => props.key;\n```\n     \n    interface Attributes {\n        key?: Key | null | undefined;\n    }\nThe props any component accepting refs can receive.\nClass components, built-in browser components (e.g. `div`) and forwardRef components can receive refs and automatically accept these props.\n```tsx\nconst Component = forwardRef(() => <div />);\n<Component ref={(current) => console.log(current)} />\n```\n* You only need this type if you manually author the types of props that need to be compatible with legacy refs.\n```tsx\ninterface Props extends React.RefAttributes<HTMLDivElement> {}\ndeclare const Component: React.FunctionComponent<Props>;\n```\n* Otherwise it's simpler to directly use {@link Ref} since you can safely use the\nprops type to describe to props that a consumer can pass to the component\nas well as describing the props the implementation of a component \"sees\".\n{@link RefAttributes} is generally not safe to describe both consumer and seen props.\n* ```tsx\ninterface Props extends {\nref?: React.Ref<HTMLDivElement> | undefined;\n}\ndeclare const Component: React.FunctionComponent<Props>;\n```\n* WARNING: The implementation of a component will not have access to the same type in versions of React supporting string refs.\nThe following example would be incorrect usage because {@link Component} would never have access to a `ref` with type `string`\n```tsx\nconst Component = (props: React.RefAttributes) => props.ref;\n```\n     \n    interface RefAttributes<T> extends Attributes {\nAllows getting a ref to the component instance.\nOnce the component unmounts, React will set `ref.current` to `null`\n(or call the ref with `null` if you passed a callback ref).\n* @see {@link https://react.dev/learn/referencing-values-with-refs#refs-and-the-dom React Docs}\n         \n        ref?: Ref<T> | undefined;\n    }\nRepresents the built-in attributes available to class components.\n     \n    interface ClassAttributes<T> extends RefAttributes<T> {\n    }\nRepresents a JSX element.\n* Where {@link ReactNode} represents everything that can be rendered, `ReactElement`\nonly represents JSX.\n* @template P The type of the props object\n@template T The type of the component or tag\n* @example\n* ```tsx\nconst element: ReactElement = <div />;\n```\n     \n    interface ReactElement<\n        P = unknown,\n        T extends string | JSXElementConstructor<any> = string | JSXElementConstructor<any>,\n    > {\n        type: T;\n        props: P;\n        key: string | null;\n    }\n@deprecated\n     \n    interface ReactComponentElement<\n        T extends keyof JSX.IntrinsicElements | JSXElementConstructor<any>,\n        P = Pick<ComponentProps<T>, Exclude<keyof ComponentProps<T>, \"key\" | \"ref\">>,\n    > extends ReactElement<P, Exclude<T, number>> {}\n@deprecated Use `ReactElement<P, React.FunctionComponent<P>>`\n     \n    interface FunctionComponentElement<P> extends ReactElement<P, FunctionComponent<P>> {\n@deprecated Use `element.props.ref` instead.\n         \n        ref?: (\"ref\" extends keyof P ? P extends { ref?: infer R | undefined } ? R : never : never) | undefined;\n    }\n@deprecated Use `ReactElement<P, React.ComponentClass<P>>`\n     \n    type CElement<P, T extends Component<P, ComponentState>> = ComponentElement<P, T>;\n@deprecated Use `ReactElement<P, React.ComponentClass<P>>`\n     \n    interface ComponentElement<P, T extends Component<P, ComponentState>> extends ReactElement<P, ComponentClass<P>> {\n@deprecated Use `element.props.ref` instead.\n         \n        ref?: Ref<T> | undefined;\n    }\n@deprecated Use {@link ComponentElement} instead.\n     \n    type ClassicElement<P> = CElement<P, ClassicComponent<P, ComponentState>>;\n\n    // string fallback for custom web-components\n@deprecated Use `ReactElement<P, string>`\n     \n    interface DOMElement<P extends HTMLAttributes<T> | SVGAttributes<T>, T extends Element>\n        extends ReactElement<P, string>\n    {\n@deprecated Use `element.props.ref` instead.\n         \n        ref: Ref<T>;\n    }\n\n    // ReactHTML for ReactHTMLElement\n    interface ReactHTMLElement<T extends HTMLElement> extends DetailedReactHTMLElement<AllHTMLAttributes<T>, T> {}\n\n    interface DetailedReactHTMLElement<P extends HTMLAttributes<T>, T extends HTMLElement> extends DOMElement<P, T> {\n        type: HTMLElementType;\n    }\n\n    // ReactSVG for ReactSVGElement\n    interface ReactSVGElement extends DOMElement<SVGAttributes<SVGElement>, SVGElement> {\n        type: SVGElementType;\n    }\n\n    interface ReactPortal extends ReactElement {\n        children: ReactNode;\n    }\nDifferent release channels declare additional types of ReactNode this particular release channel accepts.\nApp or library types should never augment this interface.\n     \n    interface DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES {}\nRepresents all of the things React can render.\n* Where {@link ReactElement} only represents JSX, `ReactNode` represents everything that can be rendered.\n* @see {@link https://react-typescript-cheatsheet.netlify.app/docs/react-types/reactnode/ React TypeScript Cheatsheet}\n* @example\n* ```tsx\n// Typing children\ntype Props = { children: ReactNode }\n* const Component = ({ children }: Props) => <div>{children}</div>\n* <Component>hello</Component>\n```\n* @example\n* ```tsx\n// Typing a custom element\ntype Props = { customElement: ReactNode }\n* const Component = ({ customElement }: Props) => <div>{customElement}</div>\n* <Component customElement={<div>hello</div>} />\n```\n     \n    // non-thenables need to be kept in sync with AwaitedReactNode\n    type ReactNode =\n        | ReactElement\n        | string\n        | number\n        | bigint\n        | Iterable<ReactNode>\n        | ReactPortal\n        | boolean\n        | null\n        | undefined\n        | DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES[\n            keyof DO_NOT_USE_OR_YOU_WILL_BE_FIRED_EXPERIMENTAL_REACT_NODES\n        ]\n        | Promise<AwaitedReactNode>;\n\n    //\n    // Top Level API\n    // ----------------------------------------------------------------------\n\n    // DOM Elements\n    // TODO: generalize this to everything in `keyof ReactHTML`, not just \"input\"\n    function createElement(\n        type: \"input\",\n        props?: InputHTMLAttributes<HTMLInputElement> & ClassAttributes<HTMLInputElement> | null,\n        ...children: ReactNode[]\n    ): DetailedReactHTMLElement<InputHTMLAttributes<HTMLInputElement>, HTMLInputElement>;\n    function createElement<P extends HTMLAttributes<T>, T extends HTMLElement>(\n        type: HTMLElementType,\n        props?: ClassAttributes<T> & P | null,\n        ...children: ReactNode[]\n    ): DetailedReactHTMLElement<P, T>;\n    function createElement<P extends SVGAttributes<T>, T extends SVGElement>(\n        type: SVGElementType,\n        props?: ClassAttributes<T> & P | null,\n        ...children: ReactNode[]\n    ): ReactSVGElement;\n    function createElement<P extends DOMAttributes<T>, T extends Element>(\n        type: string,\n        props?: ClassAttributes<T> & P | null,\n        ...children: ReactNode[]\n    ): DOMElement<P, T>;\n\n    // Custom components\n\n    function createElement<P extends {}>(\n        type: FunctionComponent<P>,\n        props?: Attributes & P | null,\n        ...children: ReactNode[]\n    ): FunctionComponentElement<P>;\n    function createElement<P extends {}, T extends Component<P, ComponentState>, C extends ComponentClass<P>>(\n        type: ClassType<P, T, C>,\n        props?: ClassAttributes<T> & P | null,\n        ...children: ReactNode[]\n    ): CElement<P, T>;\n    function createElement<P extends {}>(\n        type: FunctionComponent<P> | ComponentClass<P> | string,\n        props?: Attributes & P | null,\n        ...children: ReactNode[]\n    ): ReactElement<P>;\n\n    // DOM Elements\n    // ReactHTMLElement\n    function cloneElement<P extends HTMLAttributes<T>, T extends HTMLElement>(\n        element: DetailedReactHTMLElement<P, T>,\n        props?: P,\n        ...children: ReactNode[]\n    ): DetailedReactHTMLElement<P, T>;\n    // ReactHTMLElement, less specific\n    function cloneElement<P extends HTMLAttributes<T>, T extends HTMLElement>(\n        element: ReactHTMLElement<T>,\n        props?: P,\n        ...children: ReactNode[]\n    ): ReactHTMLElement<T>;\n    // SVGElement\n    function cloneElement<P extends SVGAttributes<T>, T extends SVGElement>(\n        element: ReactSVGElement,\n        props?: P,\n        ...children: ReactNode[]\n    ): ReactSVGElement;\n    // DOM Element (has to be the last, because type checking stops at first overload that fits)\n    function cloneElement<P extends DOMAttributes<T>, T extends Element>(\n        element: DOMElement<P, T>,\n        props?: DOMAttributes<T> & P,\n        ...children: ReactNode[]\n    ): DOMElement<P, T>;\n\n    // Custom components\n    function cloneElement<P>(\n        element: FunctionComponentElement<P>,\n        props?: Partial<P> & Attributes,\n        ...children: ReactNode[]\n    ): FunctionComponentElement<P>;\n    function cloneElement<P, T extends Component<P, ComponentState>>(\n        element: CElement<P, T>,\n        props?: Partial<P> & ClassAttributes<T>,\n        ...children: ReactNode[]\n    ): CElement<P, T>;\n    function cloneElement<P>(\n        element: ReactElement<P>,\n        props?: Partial<P> & Attributes,\n        ...children: ReactNode[]\n    ): ReactElement<P>;\nDescribes the props accepted by a Context {@link Provider}.\n* @template T The type of the value the context provides.\n     \n    interface ProviderProps<T> {\n        value: T;\n        children?: ReactNode | undefined;\n    }\nDescribes the props accepted by a Context {@link Consumer}.\n* @template T The type of the value the context provides.\n     \n    interface ConsumerProps<T> {\n        children: (value: T) => ReactNode;\n    }\nAn object masquerading as a component. These are created by functions\nlike {@link forwardRef}, {@link memo}, and {@link createContext}.\n* In order to make TypeScript work, we pretend that they are normal\ncomponents.\n* But they are, in fact, not callable - instead, they are objects which\nare treated specially by the renderer.\n* @template P The props the component accepts.\n     \n    interface ExoticComponent<P = {}> {\n        (props: P): ReactNode;\n        readonly $$typeof: symbol;\n    }\nAn {@link ExoticComponent} with a `displayName` property applied to it.\n* @template P The props the component accepts.\n     \n    interface NamedExoticComponent<P = {}> extends ExoticComponent<P> {\nUsed in debugging messages. You might want to set it\nexplicitly if you want to display a different name for\ndebugging purposes.\n* @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs}\n         \n        displayName?: string | undefined;\n    }\nAn {@link ExoticComponent} with a `propTypes` property applied to it.\n* @template P The props the component accepts.\n     \n    interface ProviderExoticComponent<P> extends ExoticComponent<P> {\n    }\nUsed to retrieve the type of a context object from a {@link Context}.\n* @template C The context object.\n* @example\n* ```tsx\nimport { createContext } from 'react';\n* const MyContext = createContext({ foo: 'bar' });\n* type ContextType = ContextType<typeof MyContext>;\n// ContextType = { foo: string }\n```\n     \n    type ContextType<C extends Context<any>> = C extends Context<infer T> ? T : never;\nWraps your components to specify the value of this context for all components inside.\n* @see {@link https://react.dev/reference/react/createContext#provider React Docs}\n* @example\n* ```tsx\nimport { createContext } from 'react';\n* const ThemeContext = createContext('light');\n* function App() {\nreturn (\n<ThemeContext.Provider value=\"dark\">\n<Toolbar />\n</ThemeContext.Provider>\n);\n}\n```\n     \n    type Provider<T> = ProviderExoticComponent<ProviderProps<T>>;\nThe old way to read context, before {@link useContext} existed.\n* @see {@link https://react.dev/reference/react/createContext#consumer React Docs}\n* @example\n* ```tsx\nimport { UserContext } from './user-context';\n* function Avatar() {\nreturn (\n<UserContext.Consumer>\n{user => <img src={user.profileImage} alt={user.name} />}\n</UserContext.Consumer>\n);\n}\n```\n     \n    type Consumer<T> = ExoticComponent<ConsumerProps<T>>;\nContext lets components pass information deep down without explicitly\npassing props.\n* Created from {@link createContext}\n* @see {@link https://react.dev/learn/passing-data-deeply-with-context React Docs}\n@see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/context/ React TypeScript Cheatsheet}\n* @example\n* ```tsx\nimport { createContext } from 'react';\n* const ThemeContext = createContext('light');\n```\n     \n    interface Context<T> extends Provider<T> {\n        Provider: Provider<T>;\n        Consumer: Consumer<T>;\nUsed in debugging messages. You might want to set it\nexplicitly if you want to display a different name for\ndebugging purposes.\n* @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs}\n         \n        displayName?: string | undefined;\n    }\nLets you create a {@link Context} that components can provide or read.\n* @param defaultValue The value you want the context to have when there is no matching\n{@link Provider} in the tree above the component reading the context. This is meant\nas a \"last resort\" fallback.\n* @see {@link https://react.dev/reference/react/createContext#reference React Docs}\n@see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/context/ React TypeScript Cheatsheet}\n* @example\n* ```tsx\nimport { createContext } from 'react';\n* const ThemeContext = createContext('light');\nfunction App() {\nreturn (\n<ThemeContext value=\"dark\">\n<Toolbar />\n</ThemeContext>\n);\n}\n```\n     \n    function createContext<T>(\n        // If you thought this should be optional, see\n        // https://github.com/DefinitelyTyped/DefinitelyTyped/pull/24509#issuecomment-382213106\n        defaultValue: T,\n    ): Context<T>;\n\n    function isValidElement<P>(object: {} | null | undefined): object is ReactElement<P>;\n\n    const Children: {\n        map<T, C>(\n            children: C | readonly C[],\n            fn: (child: C, index: number) => T,\n        ): C extends null | undefined ? C : Array<Exclude<T, boolean | null | undefined>>;\n        forEach<C>(children: C | readonly C[], fn: (child: C, index: number) => void): void;\n        count(children: any): number;\n        only<C>(children: C): C extends any[] ? never : C;\n        toArray(children: ReactNode | ReactNode[]): Array<Exclude<ReactNode, boolean | null | undefined>>;\n    };\n\n    export interface FragmentProps {\n        children?: React.ReactNode;\n    }\nLets you group elements without a wrapper node.\n* @see {@link https://react.dev/reference/react/Fragment React Docs}\n* @example\n* ```tsx\nimport { Fragment } from 'react';\n* <Fragment>\n<td>Hello</td>\n<td>World</td>\n</Fragment>\n```\n* @example\n* ```tsx\n// Using the <></> shorthand syntax:\n* <>\n<td>Hello</td>\n<td>World</td>\n</>\n```\n     \n    const Fragment: ExoticComponent<FragmentProps>;\nLets you find common bugs in your components early during development.\n* @see {@link https://react.dev/reference/react/StrictMode React Docs}\n* @example\n* ```tsx\nimport { StrictMode } from 'react';\n* <StrictMode>\n<App />\n</StrictMode>\n```\n     \n    const StrictMode: ExoticComponent<{ children?: ReactNode | undefined }>;\nThe props accepted by {@link Suspense}.\n* @see {@link https://react.dev/reference/react/Suspense React Docs}\n     \n    interface SuspenseProps {\n        children?: ReactNode | undefined;\n\n         A fallback react tree to show when a Suspense child (like React.lazy) suspends \n        fallback?: ReactNode;\nA name for this Suspense boundary for instrumentation purposes.\nThe name will help identify this boundary in React DevTools.\n         \n        name?: string | undefined;\n    }\nLets you display a fallback until its children have finished loading.\n* @see {@link https://react.dev/reference/react/Suspense React Docs}\n* @example\n* ```tsx\nimport { Suspense } from 'react';\n* <Suspense fallback={<Loading />}>\n<ProfileDetails />\n</Suspense>\n```\n     \n    const Suspense: ExoticComponent<SuspenseProps>;\n    const version: string;\nThe callback passed to {@link ProfilerProps.onRender}.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n     \n    type ProfilerOnRenderCallback = (\nThe string id prop of the {@link Profiler} tree that has just committed. This lets\nyou identify which part of the tree was committed if you are using multiple\nprofilers.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n         \n        id: string,\nThis lets you know whether the tree has just been mounted for the first time\nor re-rendered due to a change in props, state, or hooks.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n         \n        phase: \"mount\" | \"update\" | \"nested-update\",\nThe number of milliseconds spent rendering the {@link Profiler} and its descendants\nfor the current update. This indicates how well the subtree makes use of\nmemoization (e.g. {@link memo} and {@link useMemo}). Ideally this value should decrease\nsignificantly after the initial mount as many of the descendants will only need to\nre-render if their specific props change.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n         \n        actualDuration: number,\nThe number of milliseconds estimating how much time it would take to re-render the entire\n{@link Profiler} subtree without any optimizations. It is calculated by summing up the most\nrecent render durations of each component in the tree. This value estimates a worst-case\ncost of rendering (e.g. the initial mount or a tree with no memoization). Compare\n{@link actualDuration} against it to see if memoization is working.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n         \n        baseDuration: number,\nA numeric timestamp for when React began rendering the current update.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n         \n        startTime: number,\nA numeric timestamp for when React committed the current update. This value is shared\nbetween all profilers in a commit, enabling them to be grouped if desirable.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n         \n        commitTime: number,\n    ) => void;\nThe props accepted by {@link Profiler}.\n* @see {@link https://react.dev/reference/react/Profiler React Docs}\n     \n    interface ProfilerProps {\n        children?: ReactNode | undefined;\n        id: string;\n        onRender: ProfilerOnRenderCallback;\n    }\nLets you measure rendering performance of a React tree programmatically.\n* @see {@link https://react.dev/reference/react/Profiler#onrender-callback React Docs}\n* @example\n* ```tsx\n<Profiler id=\"App\" onRender={onRender}>\n<App />\n</Profiler>\n```\n     \n    const Profiler: ExoticComponent<ProfilerProps>;\n\n    //\n    // Component API\n    // ----------------------------------------------------------------------\n\n    type ReactInstance = Component<any> | Element;\n\n    // Base component for plain JS classes\n    interface Component<P = {}, S = {}, SS = any> extends ComponentLifecycle<P, S, SS> {}\n    class Component<P, S> {\nIf set, `this.context` will be set at runtime to the current value of the given Context.\n* @example\n* ```ts\ntype MyContext = number\nconst Ctx = React.createContext<MyContext>(0)\n* class Foo extends React.Component {\nstatic contextType = Ctx\ncontext!: React.ContextType<typeof Ctx>\nrender () {\nreturn <>My context's value: {this.context}</>;\n}\n}\n```\n* @see {@link https://react.dev/reference/react/Component#static-contexttype}\n         \n        static contextType?: Context<any> | undefined;\nIgnored by React.\n@deprecated Only kept in types for backwards compatibility. Will be removed in a future major release.\n         \n        static propTypes?: any;\nIf using the new style context, re-declare this in your class to be the\n`React.ContextType` of your `static contextType`.\nShould be used with type annotation or static contextType.\n* @example\n```ts\nstatic contextType = MyContext\n// For TS pre-3.7:\ncontext!: React.ContextType<typeof MyContext>\n// For TS 3.7 and above:\ndeclare context: React.ContextType<typeof MyContext>\n```\n* @see {@link https://react.dev/reference/react/Component#context React Docs}\n         \n        context: unknown;\n\n        // Keep in sync with constructor signature of JSXElementConstructor and ComponentClass.\n        constructor(props: P);\n\n        // We MUST keep setState() as a unified signature because it allows proper checking of the method return type.\n        // See: https://github.com/DefinitelyTyped/DefinitelyTyped/issues/18365#issuecomment-351013257\n        // Also, the ` | S` allows intellisense to not be dumbisense\n        setState<K extends keyof S>(\n            state: ((prevState: Readonly<S>, props: Readonly<P>) => Pick<S, K> | S | null) | (Pick<S, K> | S | null),\n            callback?: () => void,\n        ): void;\n\n        forceUpdate(callback?: () => void): void;\n        render(): ReactNode;\n\n        readonly props: Readonly<P>;\n        state: Readonly<S>;\n    }\n\n    class PureComponent<P = {}, S = {}, SS = any> extends Component<P, S, SS> {}\n@deprecated Use `ClassicComponent` from `create-react-class`\n* @see {@link https://legacy.reactjs.org/docs/react-without-es6.html Legacy React Docs}\n@see {@link https://www.npmjs.com/package/create-react-class `create-react-class` on npm}\n     \n    interface ClassicComponent<P = {}, S = {}> extends Component<P, S> {\n        replaceState(nextState: S, callback?: () => void): void;\n        isMounted(): boolean;\n        getInitialState?(): S;\n    }\n\n    //\n    // Class Interfaces\n    // ----------------------------------------------------------------------\nRepresents the type of a function component. Can optionally\nreceive a type argument that represents the props the component\nreceives.\n* @template P The props the component accepts.\n@see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/function_components React TypeScript Cheatsheet}\n@alias for {@link FunctionComponent}\n* @example\n* ```tsx\n// With props:\ntype Props = { name: string }\n* const MyComponent: FC<Props> = (props) => {\nreturn <div>{props.name}</div>\n}\n```\n* @example\n* ```tsx\n// Without props:\nconst MyComponentWithoutProps: FC = () => {\nreturn <div>MyComponentWithoutProps</div>\n}\n```\n     \n    type FC<P = {}> = FunctionComponent<P>;\nRepresents the type of a function component. Can optionally\nreceive a type argument that represents the props the component\naccepts.\n* @template P The props the component accepts.\n@see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/function_components React TypeScript Cheatsheet}\n* @example\n* ```tsx\n// With props:\ntype Props = { name: string }\n* const MyComponent: FunctionComponent<Props> = (props) => {\nreturn <div>{props.name}</div>\n}\n```\n* @example\n* ```tsx\n// Without props:\nconst MyComponentWithoutProps: FunctionComponent = () => {\nreturn <div>MyComponentWithoutProps</div>\n}\n```\n     \n    interface FunctionComponent<P = {}> {\n        (props: P): ReactNode | Promise<ReactNode>;\nIgnored by React.\n@deprecated Only kept in types for backwards compatibility. Will be removed in a future major release.\n         \n        propTypes?: any;\nUsed in debugging messages. You might want to set it\nexplicitly if you want to display a different name for\ndebugging purposes.\n* @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs}\n* @example\n* ```tsx\n* const MyComponent: FC = () => {\nreturn <div>Hello!</div>\n}\n* MyComponent.displayName = 'MyAwesomeComponent'\n```\n         \n        displayName?: string | undefined;\n    }\nThe type of the ref received by a {@link ForwardRefRenderFunction}.\n* @see {@link ForwardRefRenderFunction}\n     \n    // Making T nullable is assuming the refs will be managed by React or the component impl will write it somewhere else.\n    // But this isn't necessarily true. We haven't heard complains about it yet and hopefully `forwardRef` is removed from React before we do.\n    type ForwardedRef<T> = ((instance: T | null) => void) | RefObject<T | null> | null;\nThe type of the function passed to {@link forwardRef}. This is considered different\nto a normal {@link FunctionComponent} because it receives an additional argument,\n* @param props Props passed to the component, if any.\n@param ref A ref forwarded to the component of type {@link ForwardedRef}.\n* @template T The type of the forwarded ref.\n@template P The type of the props the component accepts.\n* @see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/forward_and_create_ref/ React TypeScript Cheatsheet}\n@see {@link forwardRef}\n     \n    interface ForwardRefRenderFunction<T, P = {}> {\n        (props: P, ref: ForwardedRef<T>): ReactNode;\nUsed in debugging messages. You might want to set it\nexplicitly if you want to display a different name for\ndebugging purposes.\n* Will show `ForwardRef(${Component.displayName || Component.name})`\nin devtools by default, but can be given its own specific name.\n* @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs}\n         \n        displayName?: string | undefined;\nIgnored by React.\n@deprecated Only kept in types for backwards compatibility. Will be removed in a future major release.\n         \n        propTypes?: any;\n    }\nRepresents a component class in React.\n* @template P The props the component accepts.\n@template S The internal state of the component.\n     \n    interface ComponentClass<P = {}, S = ComponentState> extends StaticLifecycle<P, S> {\n        // constructor signature must match React.Component\n        new(props: P): Component<P, S>;\nIgnored by React.\n@deprecated Only kept in types for backwards compatibility. Will be removed in a future major release.\n         \n        propTypes?: any;\n        contextType?: Context<any> | undefined;\n        defaultProps?: Partial<P> | undefined;\nUsed in debugging messages. You might want to set it\nexplicitly if you want to display a different name for\ndebugging purposes.\n* @see {@link https://legacy.reactjs.org/docs/react-component.html#displayname Legacy React Docs}\n         \n        displayName?: string | undefined;\n    }\n@deprecated Use `ClassicComponentClass` from `create-react-class`\n* @see {@link https://legacy.reactjs.org/docs/react-without-es6.html Legacy React Docs}\n@see {@link https://www.npmjs.com/package/create-react-class `create-react-class` on npm}\n     \n    interface ClassicComponentClass<P = {}> extends ComponentClass<P> {\n        new(props: P): ClassicComponent<P, ComponentState>;\n        getDefaultProps?(): P;\n    }\nUsed in {@link createElement} and {@link createFactory} to represent\na class.\n* An intersection type is used to infer multiple type parameters from\na single argument, which is useful for many top-level API defs.\nSee {@link https://github.com/Microsoft/TypeScript/issues/7234 this GitHub issue}\nfor more info.\n     \n    type ClassType<P, T extends Component<P, ComponentState>, C extends ComponentClass<P>> =\n        & C\n        & (new(props: P) => T);\n\n    //\n    // Component Specs and Lifecycle\n    // ----------------------------------------------------------------------\n\n    // This should actually be something like `Lifecycle<P, S> | DeprecatedLifecycle<P, S>`,\n    // as React will _not_ call the deprecated lifecycle methods if any of the new lifecycle\n    // methods are present.\n    interface ComponentLifecycle<P, S, SS = any> extends NewLifecycle<P, S, SS>, DeprecatedLifecycle<P, S> {\nCalled immediately after a component is mounted. Setting state here will trigger re-rendering.\n         \n        componentDidMount?(): void;\nCalled to determine whether the change in props and state should trigger a re-render.\n* `Component` always returns true.\n`PureComponent` implements a shallow comparison on props and state and returns true if any\nprops or states have changed.\n* If false is returned, {@link Component.render}, `componentWillUpdate`\nand `componentDidUpdate` will not be called.\n         \n        shouldComponentUpdate?(nextProps: Readonly<P>, nextState: Readonly<S>, nextContext: any): boolean;\nCalled immediately before a component is destroyed. Perform any necessary cleanup in this method, such as\ncancelled network requests, or cleaning up any DOM elements created in `componentDidMount`.\n         \n        componentWillUnmount?(): void;\nCatches exceptions generated in descendant components. Unhandled exceptions will cause\nthe entire component tree to unmount.\n         \n        componentDidCatch?(error: Error, errorInfo: ErrorInfo): void;\n    }\n\n    // Unfortunately, we have no way of declaring that the component constructor must implement this\n    interface StaticLifecycle<P, S> {\n        getDerivedStateFromProps?: GetDerivedStateFromProps<P, S> | undefined;\n        getDerivedStateFromError?: GetDerivedStateFromError<P, S> | undefined;\n    }\n\n    type GetDerivedStateFromProps<P, S> =\nReturns an update to a component's state based on its new props and old state.\n* Note: its presence prevents any of the deprecated lifecycle methods from being invoked\n         \n        (nextProps: Readonly<P>, prevState: S) => Partial<S> | null;\n\n    type GetDerivedStateFromError<P, S> =\nThis lifecycle is invoked after an error has been thrown by a descendant component.\nIt receives the error that was thrown as a parameter and should return a value to update state.\n* Note: its presence prevents any of the deprecated lifecycle methods from being invoked\n         \n        (error: any) => Partial<S> | null;\n\n    // This should be \"infer SS\" but can't use it yet\n    interface NewLifecycle<P, S, SS> {\nRuns before React applies the result of {@link Component.render render} to the document, and\nreturns an object to be given to {@link componentDidUpdate}. Useful for saving\nthings such as scroll position before {@link Component.render render} causes changes to it.\n* Note: the presence of this method prevents any of the deprecated\nlifecycle events from running.\n         \n        getSnapshotBeforeUpdate?(prevProps: Readonly<P>, prevState: Readonly<S>): SS | null;\nCalled immediately after updating occurs. Not called for the initial render.\n* The snapshot is only present if {@link getSnapshotBeforeUpdate} is present and returns non-null.\n         \n        componentDidUpdate?(prevProps: Readonly<P>, prevState: Readonly<S>, snapshot?: SS): void;\n    }\n\n    interface DeprecatedLifecycle<P, S> {\nCalled immediately before mounting occurs, and before {@link Component.render}.\nAvoid introducing any side-effects or subscriptions in this method.\n* Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate}\nor {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents\nthis from being invoked.\n* @deprecated 16.3, use {@link ComponentLifecycle.componentDidMount componentDidMount} or the constructor instead; will stop working in React 17\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#initializing-state}\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path}\n         \n        componentWillMount?(): void;\nCalled immediately before mounting occurs, and before {@link Component.render}.\nAvoid introducing any side-effects or subscriptions in this method.\n* This method will not stop working in React 17.\n* Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate}\nor {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents\nthis from being invoked.\n* @deprecated 16.3, use {@link ComponentLifecycle.componentDidMount componentDidMount} or the constructor instead\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#initializing-state}\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path}\n         \n        UNSAFE_componentWillMount?(): void;\nCalled when the component may be receiving new props.\nReact may call this even if props have not changed, so be sure to compare new and existing\nprops if you only want to handle changes.\n* Calling {@link Component.setState} generally does not trigger this method.\n* Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate}\nor {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents\nthis from being invoked.\n* @deprecated 16.3, use static {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} instead; will stop working in React 17\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#updating-state-based-on-props}\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path}\n         \n        componentWillReceiveProps?(nextProps: Readonly<P>, nextContext: any): void;\nCalled when the component may be receiving new props.\nReact may call this even if props have not changed, so be sure to compare new and existing\nprops if you only want to handle changes.\n* Calling {@link Component.setState} generally does not trigger this method.\n* This method will not stop working in React 17.\n* Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate}\nor {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents\nthis from being invoked.\n* @deprecated 16.3, use static {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} instead\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#updating-state-based-on-props}\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path}\n         \n        UNSAFE_componentWillReceiveProps?(nextProps: Readonly<P>, nextContext: any): void;\nCalled immediately before rendering when new props or state is received. Not called for the initial render.\n* Note: You cannot call {@link Component.setState} here.\n* Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate}\nor {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents\nthis from being invoked.\n* @deprecated 16.3, use getSnapshotBeforeUpdate instead; will stop working in React 17\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#reading-dom-properties-before-an-update}\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path}\n         \n        componentWillUpdate?(nextProps: Readonly<P>, nextState: Readonly<S>, nextContext: any): void;\nCalled immediately before rendering when new props or state is received. Not called for the initial render.\n* Note: You cannot call {@link Component.setState} here.\n* This method will not stop working in React 17.\n* Note: the presence of {@link NewLifecycle.getSnapshotBeforeUpdate getSnapshotBeforeUpdate}\nor {@link StaticLifecycle.getDerivedStateFromProps getDerivedStateFromProps} prevents\nthis from being invoked.\n* @deprecated 16.3, use getSnapshotBeforeUpdate instead\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#reading-dom-properties-before-an-update}\n@see {@link https://legacy.reactjs.org/blog/2018/03/27/update-on-async-rendering.html#gradual-migration-path}\n         \n        UNSAFE_componentWillUpdate?(nextProps: Readonly<P>, nextState: Readonly<S>, nextContext: any): void;\n    }\n\n    function createRef<T>(): RefObject<T | null>;\nThe type of the component returned from {@link forwardRef}.\n* @template P The props the component accepts, if any.\n* @see {@link ExoticComponent}\n     \n    interface ForwardRefExoticComponent<P> extends NamedExoticComponent<P> {\nIgnored by React.\n@deprecated Only kept in types for backwards compatibility. Will be removed in a future major release.\n         \n        propTypes?: any;\n    }\nLets your component expose a DOM node to a parent component\nusing a ref.\n* @see {@link https://react.dev/reference/react/forwardRef React Docs}\n@see {@link https://react-typescript-cheatsheet.netlify.app/docs/basic/getting-started/forward_and_create_ref/ React TypeScript Cheatsheet}\n* @param render See the {@link ForwardRefRenderFunction}.\n* @template T The type of the DOM node.\n@template P The props the component accepts, if any.\n* @example\n* ```tsx\ninterface Props {\nchildren?: ReactNode;\ntype: \"submit\" | \"button\";\n}\n* export const FancyButton = forwardRef<HTMLButtonElement, Props>((props, ref) => (\n<button ref={ref} className=\"MyClassName\" type={props.type}>\n{props.children}\n</button>\n));\n```\n     \n    function forwardRef<T, P = {}>(\n        render: ForwardRefRenderFunction<T, PropsWithoutRef<P>>,\n    ): ForwardRefExoticComponent<PropsWithoutRef<P> & RefAttributes<T>>;\nOmits the 'ref' attribute from the given props object.\n* @template Props The props object type.\n     \n    type PropsWithoutRef<Props> =\n        // Omit would not be sufficient for this. We'd like to avoid unnecessary mapping and need a distributive conditional to support unions.\n        // see: https://www.typescriptlang.org/docs/handbook/2/conditional-types.html#distributive-conditional-types\n        // https://github.com/Microsoft/TypeScript/issues/28339\n        Props extends any ? (\"ref\" extends keyof Props ? Omit<Props, \"ref\"> : Props) : Props;\nEnsures that the props do not include string ref, which cannot be forwarded\n@deprecated Use `Props` directly. `PropsWithRef<Props>` is just an alias for `Props`\n     \n    type PropsWithRef<Props> = Props;\n\n    type PropsWithChildren<P = unknown> = P & { children?: ReactNode | undefined };\nUsed to retrieve the props a component accepts. Can either be passed a string,\nindicating a DOM element (e.g. 'div', 'span', etc.) or the type of a React\ncomponent.\n* It's usually better to use {@link ComponentPropsWithRef} or {@link ComponentPropsWithoutRef}\ninstead of this type, as they let you be explicit about whether or not to include\nthe `ref` prop.\n* @see {@link https://react-typescript-cheatsheet.netlify.app/docs/react-types/componentprops/ React TypeScript Cheatsheet}\n* @example\n* ```tsx\n// Retrieves the props an 'input' element accepts\ntype InputProps = React.ComponentProps<'input'>;\n```\n* @example\n* ```tsx\nconst MyComponent = (props: { foo: number, bar: string }) => <div />;\n* // Retrieves the props 'MyComponent' accepts\ntype MyComponentProps = React.ComponentProps<typeof MyComponent>;\n```\n     \n    type ComponentProps<T extends keyof JSX.IntrinsicElements | JSXElementConstructor<any>> = T extends\n        JSXElementConstructor<infer Props> ? Props\n        : T extends keyof JSX.IntrinsicElements ? JSX.IntrinsicElements[T]\n        : {};\nUsed to retrieve the props a component accepts with its ref. Can either be\npassed a string, indicating a DOM element (e.g. 'div', 'span', etc.) or the\ntype of a React component.\n* @see {@link https://react-typescript-cheatsheet.netlify.app/docs/react-types/componentprops/ React TypeScript Cheatsheet}\n* @example\n* ```tsx\n// Retrieves the props an 'input' element accepts\ntype InputProps = React.ComponentPropsWithRef<'input'>;\n```\n* @example\n* ```tsx\nconst MyComponent = (props: { foo: number, bar: string }) => <div />;\n* // Retrieves the props 'MyComponent' accepts\ntype MyComponentPropsWithRef = React.ComponentPropsWithRef<typeof MyComponent>;\n```\n     \n    type ComponentPropsWithRef<T extends ElementType> = T extends JSXElementConstructor<infer Props>\n        // If it's a class i.e. newable we're dealing with a class component\n        ? T extends abstract new(args: any) => any ? PropsWithoutRef<Props> & RefAttributes<InstanceType<T>>\n        : Props\n        : ComponentProps<T>;\nUsed to retrieve the props a custom component accepts with its ref.\n* Unlike {@link ComponentPropsWithRef}, this only works with custom\ncomponents, i.e. components you define yourself. This is to improve\ntype-checking performance.\n* @example\n* ```tsx\nconst MyComponent = (props: { foo: number, bar: string }) => <div />;\n* // Retrieves the props 'MyComponent' accepts\ntype MyComponentPropsWithRef = React.CustomComponentPropsWithRef<typeof MyComponent>;\n```\n     \n    type CustomComponentPropsWithRef<T extends ComponentType> = T extends JSXElementConstructor<infer Props>\n        // If it's a class i.e. newable we're dealing with a class component\n        ? T extends abstract new(args: any) => any ? PropsWithoutRef<Props> & RefAttributes<InstanceType<T>>\n        : Props\n        : never;\nUsed to retrieve the props a component accepts without its ref. Can either be\npassed a string, indicating a DOM element (e.g. 'div', 'span', etc.) or the\ntype of a React component.\n* @see {@link https://react-typescript-cheatsheet.netlify.app/docs/react-types/componentprops/ React TypeScript Cheatsheet}\n* @example\n* ```tsx\n// Retrieves the props an 'input' element accepts\ntype InputProps = React.ComponentPropsWithoutRef<'input'>;\n```\n* @example\n* ```tsx\nconst MyComponent = (props: { foo: number, bar: string }) => <div />;\n* // Retrieves the props 'MyComponent' accepts\ntype MyComponentPropsWithoutRef = React.ComponentPropsWithoutRef<typeof MyComponent>;\n```\n     \n    type ComponentPropsWithoutRef<T extends ElementType> = PropsWithoutRef<ComponentProps<T>>;\nRetrieves the type of the 'ref' prop for a given component type or tag name.\n* @template C The component type.\n* @example\n* ```tsx\ntype MyComponentRef = React.ComponentRef<typeof MyComponent>;\n```\n* @example\n* ```tsx\ntype DivRef = React.ComponentRef<'div'>;\n```\n     \n    type ComponentRef<T extends ElementType> = ComponentPropsWithRef<T> extends RefAttributes<infer Method> ? Method\n        : never;\n\n    // will show `Memo(${Component.displayName || Component.name})` in devtools by default,\n    // but can be given its own specific name\n    type MemoExoticComponent<T extends ComponentType<any>> = NamedExoticComponent<CustomComponentPropsWithRef<T>> & {\n        readonly type: T;\n    };\nLets you skip re-rendering a component when its props are unchanged.\n* @see {@link https://react.dev/reference/react/memo React Docs}\n* @param Component The component to memoize.\n@param propsAreEqual A function that will be used to determine if the props have changed.\n* @example\n* ```tsx\nimport { memo } from 'react';\n* const SomeComponent = memo(function SomeComponent(props: { foo: string }) {\n// ...\n});\n```\n     \n    function memo<P extends object>(\n        Component: FunctionComponent<P>,\n        propsAreEqual?: (prevProps: Readonly<P>, nextProps: Readonly<P>) => boolean,\n    ): NamedExoticComponent<P>;\n    function memo<T extends ComponentType<any>>(\n        Component: T,\n        propsAreEqual?: (prevProps: Readonly<ComponentProps<T>>, nextProps: Readonly<ComponentProps<T>>) => boolean,\n    ): MemoExoticComponent<T>;\n\n    interface LazyExoticComponent<T extends ComponentType<any>>\n        extends ExoticComponent<CustomComponentPropsWithRef<T>>\n    {\n        readonly _result: T;\n    }\nLets you defer loading a component’s code until it is rendered for the first time.\n* @see {@link https://react.dev/reference/react/lazy React Docs}\n* @param load A function that returns a `Promise` or another thenable (a `Promise`-like object with a\nthen method). React will not call `load` until the first time you attempt to render the returned\ncomponent. After React first calls load, it will wait for it to resolve, and then render the\nresolved value’s `.default` as a React component. Both the returned `Promise` and the `Promise`’s\nresolved value will be cached, so React will not call load more than once. If the `Promise` rejects,\nReact will throw the rejection reason for the nearest Error Boundary to handle.\n* @example\n* ```tsx\nimport { lazy } from 'react';\n* const MarkdownPreview = lazy(() => import('./MarkdownPreview.js'));\n```\n     \n    function lazy<T extends ComponentType<any>>(\n        load: () => Promise<{ default: T }>,\n    ): LazyExoticComponent<T>;\n\n    //\n    // React Hooks\n    // ----------------------------------------------------------------------\nThe instruction passed to a {@link Dispatch} function in {@link useState}\nto tell React what the next value of the {@link useState} should be.\n* Often found wrapped in {@link Dispatch}.\n* @template S The type of the state.\n* @example\n* ```tsx\n// This return type correctly represents the type of\n// `setCount` in the example below.\nconst useCustomState = (): Dispatch<SetStateAction<number>> => {\nconst [count, setCount] = useState(0);\n*   return setCount;\n}\n```\n     \n    type SetStateAction<S> = S | ((prevState: S) => S);\nA function that can be used to update the state of a {@link useState}\nor {@link useReducer} hook.\n     \n    type Dispatch<A> = (value: A) => void;\nA {@link Dispatch} function can sometimes be called without any arguments.\n     \n    type DispatchWithoutAction = () => void;\n    // Limit the reducer to accept only 0 or 1 action arguments\n    // eslint-disable-next-line @definitelytyped/no-single-element-tuple-type\n    type AnyActionArg = [] | [any];\n    // Get the dispatch type from the reducer arguments (captures optional action argument correctly)\n    type ActionDispatch<ActionArg extends AnyActionArg> = (...args: ActionArg) => void;\n    // Unlike redux, the actions _can_ be anything\n    type Reducer<S, A> = (prevState: S, action: A) => S;\n    // If useReducer accepts a reducer without action, dispatch may be called without any parameters.\n    type ReducerWithoutAction<S> = (prevState: S) => S;\n    // types used to try and prevent the compiler from reducing S\n    // to a supertype common with the second argument to useReducer()\n    type ReducerState<R extends Reducer<any, any>> = R extends Reducer<infer S, any> ? S : never;\n    type DependencyList = readonly unknown[];\n\n    // NOTE: callbacks are _only_ allowed to return either void, or a destructor.\n    type EffectCallback = () => void | Destructor;\n@deprecated Use `RefObject` instead.\n     \n    interface MutableRefObject<T> {\n        current: T;\n    }\n\n    // This will technically work if you give a Consumer<T> or Provider<T> but it's deprecated and warns\nAccepts a context object (the value returned from `React.createContext`) and returns the current\ncontext value, as given by the nearest context provider for the given context.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useContext}\n     \n    function useContext<T>(context: Context<T> /*, (not public API) observedBits?: number|boolean ): T;\nReturns a stateful value, and a function to update it.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useState}\n     \n    function useState<S>(initialState: S | (() => S)): [S, Dispatch<SetStateAction<S>>];\n    // convenience overload when first argument is omitted\nReturns a stateful value, and a function to update it.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useState}\n     \n    function useState<S = undefined>(): [S | undefined, Dispatch<SetStateAction<S | undefined>>];\nAn alternative to `useState`.\n* `useReducer` is usually preferable to `useState` when you have complex state logic that involves\nmultiple sub-values. It also lets you optimize performance for components that trigger deep\nupdates because you can pass `dispatch` down instead of callbacks.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useReducer}\n     \n    function useReducer<S, A extends AnyActionArg>(\n        reducer: (prevState: S, ...args: A) => S,\n        initialState: S,\n    ): [S, ActionDispatch<A>];\nAn alternative to `useState`.\n* `useReducer` is usually preferable to `useState` when you have complex state logic that involves\nmultiple sub-values. It also lets you optimize performance for components that trigger deep\nupdates because you can pass `dispatch` down instead of callbacks.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useReducer}\n     \n    function useReducer<S, A extends AnyActionArg>(\n        reducer: (prevState: S, ...args: A) => S,\n        initialState: S,\n    ): [S, ActionDispatch<A>];\nAn alternative to `useState`.\n* `useReducer` is usually preferable to `useState` when you have complex state logic that involves\nmultiple sub-values. It also lets you optimize performance for components that trigger deep\nupdates because you can pass `dispatch` down instead of callbacks.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useReducer}\n     \n    function useReducer<S, I, A extends AnyActionArg>(\n        reducer: (prevState: S, ...args: A) => S,\n        initialArg: I,\n        init: (i: I) => S,\n    ): [S, ActionDispatch<A>];\n`useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument\n(`initialValue`). The returned object will persist for the full lifetime of the component.\n* Note that `useRef()` is useful for more than the `ref` attribute. It’s handy for keeping any mutable\nvalue around similar to how you’d use instance fields in classes.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useRef}\n     \n    function useRef<T>(initialValue: T): RefObject<T>;\n    // convenience overload for refs given as a ref prop as they typically start with a null value\n`useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument\n(`initialValue`). The returned object will persist for the full lifetime of the component.\n* Note that `useRef()` is useful for more than the `ref` attribute. It’s handy for keeping any mutable\nvalue around similar to how you’d use instance fields in classes.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useRef}\n     \n    function useRef<T>(initialValue: T | null): RefObject<T | null>;\n    // convenience overload for undefined initialValue\n`useRef` returns a mutable ref object whose `.current` property is initialized to the passed argument\n(`initialValue`). The returned object will persist for the full lifetime of the component.\n* Note that `useRef()` is useful for more than the `ref` attribute. It’s handy for keeping any mutable\nvalue around similar to how you’d use instance fields in classes.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useRef}\n     \n    function useRef<T>(initialValue: T | undefined): RefObject<T | undefined>;\nThe signature is identical to `useEffect`, but it fires synchronously after all DOM mutations.\nUse this to read layout from the DOM and synchronously re-render. Updates scheduled inside\n`useLayoutEffect` will be flushed synchronously, before the browser has a chance to paint.\n* Prefer the standard `useEffect` when possible to avoid blocking visual updates.\n* If you’re migrating code from a class component, `useLayoutEffect` fires in the same phase as\n`componentDidMount` and `componentDidUpdate`.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useLayoutEffect}\n     \n    function useLayoutEffect(effect: EffectCallback, deps?: DependencyList): void;\nAccepts a function that contains imperative, possibly effectful code.\n* @param effect Imperative function that can return a cleanup function\n@param deps If present, effect will only activate if the values in the list change.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useEffect}\n     \n    function useEffect(effect: EffectCallback, deps?: DependencyList): void;\n    // NOTE: this does not accept strings, but this will have to be fixed by removing strings from type Ref<T>\n`useImperativeHandle` customizes the instance value that is exposed to parent components when using\n`ref`. As always, imperative code using refs should be avoided in most cases.\n* `useImperativeHandle` should be used with `React.forwardRef`.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useImperativeHandle}\n     \n    function useImperativeHandle<T, R extends T>(ref: Ref<T> | undefined, init: () => R, deps?: DependencyList): void;\n    // I made 'inputs' required here and in useMemo as there's no point to memoizing without the memoization key\n    // useCallback(X) is identical to just using X, useMemo(() => Y) is identical to just using Y.\n`useCallback` will return a memoized version of the callback that only changes if one of the `inputs`\nhas changed.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useCallback}\n     \n    // A specific function type would not trigger implicit any.\n    // See https://github.com/DefinitelyTyped/DefinitelyTyped/issues/52873#issuecomment-845806435 for a comparison between `Function` and more specific types.\n    // eslint-disable-next-line @typescript-eslint/no-unsafe-function-type\n    function useCallback<T extends Function>(callback: T, deps: DependencyList): T;\n`useMemo` will only recompute the memoized value when one of the `deps` has changed.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useMemo}\n     \n    // allow undefined, but don't make it optional as that is very likely a mistake\n    function useMemo<T>(factory: () => T, deps: DependencyList): T;\n`useDebugValue` can be used to display a label for custom hooks in React DevTools.\n* NOTE: We don’t recommend adding debug values to every custom hook.\nIt’s most valuable for custom hooks that are part of shared libraries.\n* @version 16.8.0\n@see {@link https://react.dev/reference/react/useDebugValue}\n     \n    // the name of the custom hook is itself derived from the function name at runtime:\n    // it's just the function name without the \"use\" prefix.\n    function useDebugValue<T>(value: T, format?: (value: T) => any): void;\n\n    export type TransitionFunction = () => VoidOrUndefinedOnly | Promise<VoidOrUndefinedOnly>;\n    // strange definition to allow vscode to show documentation on the invocation\n    export interface TransitionStartFunction {\nState updates caused inside the callback are allowed to be deferred.\n* **If some state update causes a component to suspend, that state update should be wrapped in a transition.**\n* @param callback A function which causes state updates that can be deferred.\n         \n        (callback: TransitionFunction): void;\n    }\nReturns a deferred version of the value that may “lag behind” it.\n* This is commonly used to keep the interface responsive when you have something that renders immediately\nbased on user input and something that needs to wait for a data fetch.\n* A good example of this is a text input.\n* @param value The value that is going to be deferred\n@param initialValue A value to use during the initial render of a component. If this option is omitted, `useDeferredValue` will not defer during the initial render, because there’s no previous version of `value` that it can render instead.\n* @see {@link https://react.dev/reference/react/useDeferredValue}\n     \n    export function useDeferredValue<T>(value: T, initialValue?: T): T;\nAllows components to avoid undesirable loading states by waiting for content to load\nbefore transitioning to the next screen. It also allows components to defer slower,\ndata fetching updates until subsequent renders so that more crucial updates can be\nrendered immediately.\n* The `useTransition` hook returns two values in an array.\n* The first is a boolean, React’s way of informing us whether we’re waiting for the transition to finish.\nThe second is a function that takes a callback. We can use it to tell React which state we want to defer.\n* **If some state update causes a component to suspend, that state update should be wrapped in a transition.**\n* @see {@link https://react.dev/reference/react/useTransition}",
    "packageType": "javascript"
  },
  {
    "objectName": "useTransition",
    "signature": "useTransition: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/useTransition",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "useTransition: any",
    "documentation": "Exported variable useTransition",
    "description": "Added new variable useTransition",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable useTransition\n\nNew source code:\n\n```typescript\nuseTransition: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable useTransition",
    "packageType": "javascript"
  },
  {
    "objectName": "useTransition",
    "signature": "property useTransition",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/useTransition",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property useTransition",
    "documentation": "Property useTransition",
    "description": "Added new property useTransition",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty useTransition\n\nNew source code:\n\n```typescript\nproperty useTransition\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property useTransition",
    "packageType": "javascript"
  },
  {
    "objectName": "v",
    "signature": "property v",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/react-server/development/v",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property v",
    "documentation": "Property v",
    "description": "Added new property v",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty v\n\nNew source code:\n\n```typescript\nproperty v\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property v",
    "packageType": "javascript"
  },
  {
    "objectName": "value",
    "signature": "property value",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/value",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property value",
    "documentation": "Property value",
    "description": "Added new property value",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty value\n\nNew source code:\n\n```typescript\nproperty value\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property value",
    "packageType": "javascript"
  },
  {
    "objectName": "version",
    "signature": "function version",
    "objectType": "function",
    "objectIdentifier": "react/cjs/react/development/version",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "function version",
    "documentation": "Module: cjs/react.development",
    "description": "Added new function version",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nModule: cjs/react.development\n\nNew source code:\n\n```typescript\nfunction version\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Module: cjs/react.development",
    "packageType": "javascript"
  },
  {
    "objectName": "version",
    "signature": "version: any",
    "objectType": "variable",
    "objectIdentifier": "react/cjs/react/development/version",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "version: any",
    "documentation": "Exported variable version",
    "description": "Added new variable version",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nExported variable version\n\nNew source code:\n\n```typescript\nversion: any\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Exported variable version",
    "packageType": "javascript"
  },
  {
    "objectName": "version",
    "signature": "property version",
    "objectType": "property",
    "objectIdentifier": "react/cjs/react/development/version",
    "packagePath": "cjs",
    "changeType": "added",
    "isBreaking": false,
    "oldSource": "",
    "newSource": "property version",
    "documentation": "Property version",
    "description": "Added new property version",
    "message": "This is a added change.\n\nPackage type: javascript\n\nDocumentation:\n\nProperty version\n\nNew source code:\n\n```typescript\nproperty version\n```",
    "jsDoc": "",
    "comments": "",
    "readmeDoc": "",
    "examples": [],
    "sourceComments": "",
    "fullDocumentation": "Property version",
    "packageType": "javascript"
  }
]